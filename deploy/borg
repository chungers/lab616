#!/bin/bash

OPTION=$1
PACKAGE=$2
PROFILE=$3

shift; shift; shift;

DEPLOY_DIR=`dirname $0`
TARGET_DIR=${DEPLOY_DIR}/../runtime/${PACKAGE}
SOURCE_DIR=${DEPLOY_DIR}/packages/${PACKAGE}
BINARY_FILES=${SOURCE_DIR}/bin
PROFILE_FILES=${SOURCE_DIR}/profiles
SCRIPT_FILES=${SOURCE_DIR}/${PACKAGE}.sh
TOMCAT_NATIVE=${DEPLOY_DIR}/../third_party/java/tomcat-native/platforms/
NATIVE_FILES="${TOMCAT_NATIVE}/linux/lib/libtcnative*.so ${TOMCAT_NATIVE}/macosx/lib/libtcnative*.jnilib"
TEMPLATES_DIR=${SOURCE_DIR}/templates
LOCAL_FILES=${TEMPLATES_DIR}/local
REMOTE_USER=lab616
REMOTE_ID_FILE=${DEPLOY_DIR}/accounts/${REMOTE_USER}.id_dsa
REMOTE_HOST=dev.lab616.com
REMOTE_SCRIPT=${PACKAGE}.sh
REMOTE_LOG=${REMOTE_SCRIPT}.${PROFILE}.log
REMOTE_PID=${REMOTE_SCRIPT}.${PROFILE}.pid

# Execute remotely
function run_remote {
    ssh -i ${REMOTE_ID_FILE} ${REMOTE_USER}@${REMOTE_HOST} $@
}

# Execute locally
function run_local {
    $@
}

echo "PACKAGE=${PACKAGE}, TARGET=${TARGET_DIR}"

case "${OPTION}" in 
--newpackage)
    if [ ! -d ${SOURCE_DIR} ]; then
	echo "Directory ${SOURCE_DIR} missing.  Creating."
	mkdir -p ${SOURCE_DIR}
	mkdir -p ${BINARY_FILES}
	mkdir -p ${PROFILE_FILES}
	mkdir -p ${TEMPLATES_DIR}
	mkdir -p ${LOCAL_FILES}
	cp ${DEPLOY_DIR}/template.sh ${SOURCE_DIR}/${PACKAGE}.sh
	chmod a+x ${SOURCE_DIR}/${PACKAGE}.sh
    fi
;;
--stagelocal)
    if [ ! -d ${TARGET_DIR} ]; then
	echo "Directory ${TARGET_DIR} missing.  Creating."
	mkdir -p ${TARGET_DIR}
    fi

    # Copy the files over from the template directory
    cp -r ${BINARY_FILES} ${TARGET_DIR}
    cp -r ${PROFILE_FILES} ${TARGET_DIR}
    cp -r ${SCRIPT_FILES} ${TARGET_DIR}
    cp -r ${LOCAL_FILES} ${TARGET_DIR}
    for n in ${NATIVE_FILES}; do
	cp $n ${TARGET_DIR}/bin
    done
;;
--rsync)
   # Simple case of just copy from local source to remote machine.
   # This deployment simply uses rsync.
   pushd ${TARGET_DIR}
   SRC=`pwd`
   popd
   rsync -zav --delete --links --rsh="ssh -i ${REMOTE_ID_FILE}" ${SRC} ${REMOTE_USER}@${REMOTE_HOST}:/home/${REMOTE_USER}/runtime
;;
--git)
   # Normally this should be done over ssh and the deployed server will just
   # checkout a given branch from git repository for production.
;;
--start)
   # Start remotely.
   run_remote /home/${REMOTE_USER}/runtime/${PACKAGE}/${REMOTE_SCRIPT} ${PROFILE} $@
;;
--stop)
   # Stop remote server.
   PID=`run_remote cat /home/${REMOTE_USER}/runtime/${PACKAGE}/${REMOTE_PID}`
   run_remote kill -s TERM ${PID}
;;
--startlocal)
   # Start remotely.
   run_local /home/${REMOTE_USER}/runtime/${PACKAGE}/${REMOTE_SCRIPT} ${PROFILE} $@
;;
--stoplocal)
   # Stop remote server.
   PID=`cat /home/${REMOTE_USER}/runtime/${PACKAGE}/${REMOTE_PID}`
   run_local kill -s TERM ${PID}
;;
--viewlog)
   # View the remote log file.
   run_remote tail -f /home/${REMOTE_USER}/runtime/${PACKAGE}/${REMOTE_LOG}
;;
--tunnel)
   # SSH tunnel
   REMOTE_PORT=$1
   LOCAL_PORT=$2
   shift; shift;
   ssh -i ${REMOTE_ID_FILE} -L ${LOCAL_PORT}:localhost:${REMOTE_PORT} ${REMOTE_USER}@${REMOTE_HOST}
;;
esac

