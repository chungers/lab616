--- packet_test.c	2010-10-24 12:05:26.000000000 +0800
+++ packet_test.c89.c	2010-10-24 12:43:34.000000000 +0800
@@ -61,11 +61,12 @@
 	if (len < (sizeof(struct pgm_ip) + sizeof(struct pgm_header))) 
 	{
 		printf ("Packet size too small: %" PRIzu " bytes, expecting at least %" PRIzu " bytes.\n",
-			len, sizeof(struct pgm_ip) + sizeof(struct pgm_header));
+			(unsigned long)len, (unsigned long)(sizeof(struct pgm_ip) + sizeof(struct pgm_header)));
 		return FALSE;
 	}
 
 /* decode IP header */
+	{
 	const struct pgm_ip* ip = (const struct pgm_ip*)data;
 	if (ip->ip_v != 4) 				/* IP version, 4 or 6 */
 	{
@@ -74,6 +75,7 @@
 	}
 	printf ("IP ");
 
+	{
 	const size_t ip_header_length = ip->ip_hl * 4;		/* IP header length in 32bit octets */
 	if (ip_header_length < sizeof(struct pgm_ip)) 
 	{
@@ -81,6 +83,7 @@
 		return FALSE;
 	}
 
+	{
 	size_t packet_length = ntohs(ip->ip_len);	/* total packet length */
 
 /* ip_len can equal packet_length - ip_header_length in FreeBSD/NetBSD
@@ -103,6 +106,7 @@
 		return FALSE;
 	}
 
+	{
 	const uint16_t offset = ntohs(ip->ip_off);
 
 /* 3 bits routing priority, 4 bits type of service: delay, throughput, reliability, cost */
@@ -129,7 +133,7 @@
 		(offset & 0x1fff) * 8,
 		((offset & IP_DF) ? "DF" : ""),
 		((offset & IP_MF) ? "+" : ""));
-	printf (", length %" PRIzu "", packet_length);
+	printf (", length %" PRIzu "", (unsigned long)packet_length);
 
 /* IP options */
 	if ((ip_header_length - sizeof(struct pgm_ip)) > 0) {
@@ -140,6 +144,7 @@
 
 /* packets that fail checksum will generally not be passed upstream except with rfc3828
  */
+	{
 	const uint16_t ip_sum = pgm_inet_checksum(data, packet_length, 0);
 	if (ip_sum != 0) {
 		const uint16_t encoded_ip_sum = ntohs(ip->ip_sum);
@@ -170,6 +175,7 @@
  * | Type specific data ...
  * +-+-+-+-+-+-+-+-+-+- ...
  */
+	{
 	const struct pgm_header* pgm_header = (const struct pgm_header*)((const char*)data + ip_header_length);
 	const size_t pgm_length = packet_length - ip_header_length;
 
@@ -221,6 +227,7 @@
 	}
 
 /* now decode PGM packet types */
+	{
 	const void* pgm_data = pgm_header + 1;
 	const size_t pgm_data_length = pgm_length - sizeof(pgm_header);		/* can equal zero for SPMR's */
 
@@ -240,6 +247,13 @@
 	}
 
 	return err;
+	}
+	}
+	}
+	}
+	}
+	}
+	}
 }
 
 /* 8.1.  Source Path Messages (SPM)
@@ -287,6 +301,7 @@
 		return FALSE;
 	}
 
+	{
 	const struct pgm_spm * spm  = (const struct pgm_spm *)data;
 	const struct pgm_spm6* spm6 = (const struct pgm_spm6*)data;
 	const uint16_t spm_nla_afi = ntohs (spm->spm_nla_afi);
@@ -297,6 +312,7 @@
 		ntohl(spm->spm_lead),
 		spm_nla_afi);	/* address family indicator */
 
+	{
 	char s[INET6_ADDRSTRLEN];
 	const void* pgm_opt;
 	size_t pgm_opt_len;
@@ -334,6 +350,8 @@
 
 	printf ("\n");
 	return TRUE;
+	}
+	}
 }
 
 /* 14.7.1.  Poll Request
@@ -383,6 +401,7 @@
 		return FALSE;
 	}
 
+	{
 	const struct pgm_poll * poll4 = (const struct pgm_poll *)data;
 	const struct pgm_poll6* poll6 = (const struct pgm_poll6*)data;
 	const uint16_t poll_nla_afi = ntohs (poll4->poll_nla_afi);
@@ -393,6 +412,7 @@
 		ntohs(poll4->poll_s_type),
 		poll_nla_afi);	/* address family indicator */
 
+	{
 	char s[INET6_ADDRSTRLEN];
 	const void* pgm_opt;
 	size_t pgm_opt_len;
@@ -457,6 +477,8 @@
 
 	printf ("\n");
 	return TRUE;
+	}
+	}
 }
 
 /* 14.7.2.  Poll Response
@@ -492,12 +514,14 @@
 		return FALSE;
 	}
 
+	{
 	const struct pgm_polr* polr = (const struct pgm_polr*)data;
 
 	printf("sqn %" PRIu32 " round %u",
 		ntohl(polr->polr_sqn),
 		ntohs(polr->polr_round));
 
+	{
 	const void* pgm_opt = (const uint8_t*)data + sizeof(struct pgm_polr);
 	size_t pgm_opt_len = len - sizeof(struct pgm_polr);
 
@@ -510,6 +534,8 @@
 
 	printf ("\n");
 	return TRUE;
+	}
+	}
 }
 
 /* 8.2.  Data Packet
@@ -547,6 +573,7 @@
 		return FALSE;
 	}
 
+	{
 	const struct pgm_data* odata = (const struct pgm_data*)data;
 
 	printf ("sqn %" PRIu32 " trail %" PRIu32 " [",
@@ -554,6 +581,7 @@
 		ntohl(odata->data_trail));
 
 /* option extensions */
+	{
 	const void* pgm_opt = (const uint8_t*)data + sizeof(struct pgm_data);
 	size_t pgm_opt_len = len - sizeof(struct pgm_data);
 	const char* payload = pgm_opt;
@@ -566,6 +594,7 @@
 	}
 
 /* data */
+	{
 	const char* end = payload + ntohs (header->pgm_tsdu_length);
 	while (payload < end) {
 		if (isprint (*payload))
@@ -577,6 +606,9 @@
 
 	printf ("]\n");
 	return TRUE;
+	}
+	}
+	}
 }
 
 /* 8.2.  Repair Data
@@ -602,6 +634,7 @@
 		return FALSE;
 	}
 
+	{
 	const struct pgm_data* rdata = (const struct pgm_data*)data;
 
 	printf ("sqn %" PRIu32 " trail %" PRIu32 " [",
@@ -609,6 +642,7 @@
 		ntohl (rdata->data_trail));
 
 /* option extensions */
+	{
 	const void* pgm_opt = (const uint8_t*)data + sizeof(struct pgm_data);
 	size_t pgm_opt_len = len - sizeof(struct pgm_data);
 	const char* payload = pgm_opt;
@@ -621,6 +655,7 @@
 	}
 
 /* data */
+	{
 	const char* end = payload + ntohs (header->pgm_tsdu_length);
 	while (payload < end) {
 		if (isprint (*payload))
@@ -632,6 +667,9 @@
 
 	printf ("]\n");
 	return TRUE;
+	}
+	}
+	}
 }
 
 /* 8.3.  NAK
@@ -680,6 +718,7 @@
 		return FALSE;
 	}
 
+	{
 	const struct pgm_nak * nak  = (const struct pgm_nak *)data;
 	const struct pgm_nak6* nak6 = (const struct pgm_nak6*)data;
 	const uint16_t nak_src_nla_afi = ntohs (nak->nak_src_nla_afi);
@@ -687,6 +726,7 @@
 	printf ("sqn %" PRIu32 " src ", 
 		ntohl(nak->nak_sqn));
 
+	{
 	char s[INET6_ADDRSTRLEN];
 	const void* pgm_opt;
 	size_t pgm_opt_len;
@@ -716,6 +756,7 @@
 			return FALSE;
 		}
 
+		{
 		const uint16_t nak_grp_nla_afi = ntohs (nak6->nak6_grp_nla_afi);
 		if (nak_src_nla_afi != nak_grp_nla_afi) {
 			puts ("different source & group afi very wibbly wobbly :(");
@@ -730,6 +771,7 @@
 		pgm_inet_ntop (AF_INET6, &nak6->nak6_grp_nla, s, sizeof(s));
 		printf ("%s", s);
 		break;
+		}
 	}
 
 	default:
@@ -747,6 +789,8 @@
 
 	printf ("\n");
 	return TRUE;
+	}
+	}
 }
 
 /* 8.3.  N-NAK
@@ -867,11 +911,15 @@
 
 	printf ("ACK: ");
 
+	{
 	const struct pgm_ack* ack = (const struct pgm_ack*)data;
 	char bitmap[33];
 
-	for (unsigned i = 31; i; i--)
+	{
+	unsigned i;
+	for (i = 31; i; i--)
 		bitmap[i] = (ack->ack_bitmap & (1 << i)) ? '1' : '0';
+	}
 	bitmap[32] = '\0';
 
 	printf ("rx_max %" PRIu32 " bitmap [%s] ",
@@ -886,6 +934,7 @@
 
 	printf ("\n");
 	return TRUE;
+	}
 }
 
 
@@ -911,12 +960,14 @@
 		return -1;
 	}
 
+	{
 	const struct pgm_opt_length* opt_len = (const struct pgm_opt_length*)data;
 	if (opt_len->opt_length != sizeof(struct pgm_opt_length)) {
 		printf (" bad opt_length length %u\n", (unsigned)opt_len->opt_length);
 		return -1;
 	}
 
+	{
 	uint16_t opt_total_length = ntohs (opt_len->opt_total_length);
 	printf (" total len %u ", opt_total_length);
 	if (opt_total_length < (sizeof(struct pgm_opt_length) + sizeof(struct pgm_opt_header)) ||
@@ -928,6 +979,7 @@
 
 /* total length includes opt_length option */
 	opt_total_length -= sizeof(struct pgm_opt_length);
+	{
 	const struct pgm_opt_header* opt_header = (const struct pgm_opt_header*)(opt_len + 1);
 
 /* iterate through options (max 16) */
@@ -1031,6 +1083,9 @@
 	}
 
 	return ((const uint8_t*)opt_header - (const uint8_t*)data);
+	}
+	}
+	}
 }
 
 const char*
@@ -1068,12 +1123,14 @@
 		services = pgm_hashtable_new (pgm_int_hash, pgm_int_equal);
 	}
 
+	{
 	const int hash_key = port;
 	void* service_string = pgm_hashtable_lookup (services, &hash_key);
 	if (service_string != NULL) {
 		return service_string;
 	}
 
+	{
 	struct servent* se = getservbyport (port, "udp");
 	if (se == NULL) {
 		char buf[sizeof("00000")];
@@ -1084,6 +1141,8 @@
 	}
 	pgm_hashtable_insert (services, &hash_key, service_string);
 	return service_string;
+	}
+	}
 }
 
 const char*
@@ -1097,12 +1156,14 @@
 		hosts = pgm_hashtable_new (pgm_str_hash, pgm_int_equal);
 	}
 
+	{
 	const int hash_key = (int)ap->s_addr;
 	void* host_string = pgm_hashtable_lookup (hosts, &hash_key);
 	if (host_string != NULL) {
 		return host_string;
 	}
 
+	{
 	struct hostent* he = gethostbyaddr((const char*)ap, sizeof(struct in_addr), AF_INET);
 	if (he == NULL) {
 		struct in_addr in;
@@ -1113,6 +1174,8 @@
 	}
 	pgm_hashtable_insert (hosts, &hash_key, host_string);
 	return host_string;
+	}
+	}
 }
 
 void
@@ -1124,6 +1187,7 @@
 /* pre-conditions */
 	pgm_assert (NULL != ipopt);
 
+	{
 	const char* op = ipopt;
 
 	while (length)
@@ -1151,6 +1215,7 @@
 		op += len;
 		length -= len;
 	}
+	}
 }
 
 /* eof */
