--- getnodeaddr.c	2010-10-12 20:58:37.000000000 +0800
+++ getnodeaddr.c89.c	2010-10-12 20:59:26.000000000 +0800
@@ -58,6 +58,7 @@
 	pgm_debug ("pgm_if_getnodeaddr (family:%s addr:%p cnt:%d error:%p)",
 		pgm_family_string (family), (const void*)addr, cnt, (const void*)error);
 
+	{
 	char hostname[NI_MAXHOST + 1];
 	struct hostent* he;
 
@@ -73,15 +74,22 @@
 		return FALSE;
 	}
 
+/* sa_family_t may be ADDRESS_FAMILY on Vista+ which is a USHORT, whilst ULONG
+ * on earlier targets.
+ */
+#pragma warning( disable : 4244 )
 	addr->sa_family = family;
-	struct addrinfo hints = {
-		.ai_family	= family,
-		.ai_socktype	= SOCK_STREAM,		/* not really */
-		.ai_protocol	= IPPROTO_TCP,		/* not really */
-		.ai_flags	= AI_ADDRCONFIG,
-	}, *res;
+#pragma warning( default : 4244 )
+	{
+	int e;
+	struct addrinfo hints, *res;
+	memset (&hints, 0, sizeof(hints));
+	hints.ai_family		= family;
+	hints.ai_socktype	= SOCK_STREAM;		/* not really */
+	hints.ai_protocol	= IPPROTO_TCP;		/* not really */
+	hints.ai_flags		= AI_ADDRCONFIG;
 
-	int e = getaddrinfo (hostname, NULL, &hints, &res);
+	e = getaddrinfo (hostname, NULL, &hints, &res);
 	if (0 == e) {
 		const socklen_t addrlen = res->ai_addrlen;
 		memcpy (addr, res->ai_addr, addrlen);
@@ -124,7 +132,9 @@
 				);
 		return FALSE;
 	}
+	}
 
+	{
 	struct pgm_ifaddrs_t *ifap, *ifa, *ifa6;
 	if (!pgm_getifaddrs (&ifap, error)) {
 		pgm_prefix_error (error,
@@ -171,6 +181,8 @@
 
 	memcpy (addr, ifa6->ifa_addr, pgm_sockaddr_len (ifa6->ifa_addr));
 	pgm_freeifaddrs (ifap);
+	}
+	}
 	return TRUE;
 }
 
