<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head>
<title>SQLite Virtual Machine Opcodes</title>
<style type="text/css">
body {
    margin: auto;
    font-family: Verdana, sans-serif;
    padding: 8px 1%;
}

a { color: #45735f }
a:visited { color: #734559 }

.logo { position:absolute; margin:3px; }
.tagline {
  float:right;
  text-align:right;
  font-style:italic;
  width:300px;
  margin:12px;
  margin-top:58px;
}

.toolbar {
  text-align: center;
  line-height: 1.6em;
  margin: 0;
  padding: 0px 8px;
}
.toolbar a { color: white; text-decoration: none; padding: 6px 12px; }
.toolbar a:visited { color: white; }
.toolbar a:hover { color: #80a796; background: white; }

.content    { margin: 5%; }
.content dt { font-weight:bold; }
.content dd { margin-bottom: 25px; margin-left:20%; }
.content ul { padding:0px; padding-left: 15px; margin:0px; }

/* rounded corners */
.se  { background: url(images/se.png) 100% 100% no-repeat #80a796}
.sw  { background: url(images/sw.png) 0% 100% no-repeat }
.ne  { background: url(images/ne.png) 100% 0% no-repeat }
.nw  { background: url(images/nw.png) 0% 0% no-repeat }

/* Things for "fancyformat" documents start here. */
.fancy img+p {font-style:italic}
.fancy .codeblock i { color: darkblue; }
.fancy h1,.fancy h2,.fancy h3,.fancy h4 {font-weight:normal;color:#80a796}
.fancy h2 { margin-left: 10px }
.fancy h3 { margin-left: 20px }
.fancy h4 { margin-left: 30px }
.fancy th {white-space:nowrap;text-align:left;border-bottom:solid 1px #444}
.fancy th, .fancy td {padding: 0.2em 1ex; vertical-align:top}
.fancy #toc a        { color: darkblue ; text-decoration: none }
.fancy .todo         { color: #AA3333 ; font-style : italic }
.fancy .todo:before  { content: 'TODO:' }
.fancy p.todo        { border: solid #AA3333 1px; padding: 1ex }
.fancy img { display:block; }
.fancy :link:hover, .fancy :visited:hover { background: wheat }
.fancy p,.fancy ul,.fancy ol { margin: 1em 5ex }
.fancy li p { margin: 1em 0 }
/* End of "fancyformat" specific rules. */

</style>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
  
</head>
<body>
<div><!-- container div to satisfy validator -->

<a href="index.html">
<img class="logo" src="images/SQLite.gif" alt="SQLite Logo"
 border="0"></a>
<div><!-- IE hack to prevent disappearing logo--></div>
<div class="tagline">Small. Fast. Reliable.<br>Choose any three.</div>

<table width=100% style="clear:both"><tr><td>
  <div class="se"><div class="sw"><div class="ne"><div class="nw">
  <table width=100% style="padding:0;margin:0;cell-spacing:0"><tr>
  <td width=100%>
  <div class="toolbar">
    <a href="about.html">About</a>
    <a href="sitemap.html">Sitemap</a>
    <a href="docs.html">Documentation</a>
    <a href="download.html">Download</a>
    <a href="copyright.html">License</a>
    <a href="news.html">News</a>
    <a href="support.html">Support</a>
  </div>
<td>
    <div style="padding:0 1em 0px 0;white-space:nowrap">
    <form name=f method="GET" action="http://www.sqlite.org/search">
      <input id=q name=q type=text value=""
       onfocus="entersearch()" onblur="leavesearch()" style="width:24ex;padding:1px 1ex; border:solid white 1px; font-size:0.9em">
      <input type=submit value="Go" style="border:solid white 1px;background-color:#80a796;color:white;font-size:0.9em;padding:0 1ex">
    </form>
    </div>
  </table>
</div></div></div></div>
</td></tr></table>
<div class=startsearch></div>
  
<script>
  gMsg = "Search SQLite Docs..."
  function entersearch() {
    var q = document.getElementById("q");
    if( q.value == gMsg ) { q.value = "" }
    q.style.color = "black"
    q.style.fontStyle = "normal"
  }
  function leavesearch() {
    var q = document.getElementById("q");
    if( q.value == "" ) { 
      q.value = gMsg
      q.style.color = "#80a796"
      q.style.fontStyle = "italic"
    }
  }
  function initsearch() {
    var q = document.getElementById("q");
    q.value = ""
      q.value = gMsg
      q.style.color = "#80a796"
      q.style.fontStyle = "italic"
  }
  window.onload = initsearch
</script>



<h2>SQLite Virtual Machine Opcodes</h2>



<h3>Introduction</h3>

<p>In order to execute an SQL statement, the SQLite library first parses
the SQL, analyzes the statement, then generates a short program to execute
the statement.  The program is generated for a "virtual machine" implemented
by the SQLite library.  This document describes the operation of that
virtual machine.</p>

<p>This document is intended as a reference, not a tutorial.
A separate <a href="vdbe.html">Virtual Machine Tutorial</a> is 
available.  If you are looking for a narrative description
of how the virtual machine works, you should read the tutorial
and not this document.  Once you have a basic idea of what the
virtual machine does, you can refer back to this document for
the details on a particular opcode.
Unfortunately, the virtual machine tutorial was written for
SQLite version 1.0.  There are substantial changes in the virtual
machine for version 2.0 and and again for version 3.0.0 and again
for version 3.5.5 and the document has not been updated.  But the
basic concepts behind the virtual machine still apply.
</p>

<p>The source code to the virtual machine is in the <b>vdbe.c</b> source
file.  All of the opcode definitions further down in this document are
contained in comments in the source file.  In fact, the opcode table
in this document
was generated by scanning the <b>vdbe.c</b> source file 
and extracting the necessary information from comments.  So the 
source code comments are really the canonical source of information
about the virtual machine.  When in doubt, refer to the source code.</p>

<p>Each instruction in the virtual machine consists of an opcode and
up to five operands named P1, P2  P3, P4, and P5.  P1, P2, and P3 
are 32-bit signed integers.  These operands often refer to registers.
P2 is always the
jump destination in any operation that might cause a jump.
P4 may be a 32-bit signed integer, a 64-bit signed integer, a
64-bit floating point value, a string literal, a Blob literal,
a pointer to a collating sequence comparison function, or a
pointer to the implemantation of an application-defined SQL
function, or various other things.  P5 is an unsigned character
normally used as a flag.
Some operators use all five operands.  Some use
one or two.  Some operators use none of the operands.<p>

<p>The virtual machine begins execution on instruction number 0.
Execution continues until a Halt instruction is seen, or 
the program counter becomes one greater than the address of
last instruction, or there is an execution error.
When the virtual machine halts, all memory
that it allocated is released and all database cursors it may
have had open are closed.  If the execution stopped due to an
error, any pending transactions are terminated and changes made
to the database are rolled back.</p>

<p>The virtual machine can have zero or more cursors.  Each cursor
is a pointer into a single table or index within the database.
There can be multiple cursors pointing at the same index or table.
All cursors operate independently, even cursors pointing to the same
indices or tables.
The only way for the virtual machine to interact with a database
file is through a cursor.
Instructions in the virtual
machine can create a new cursor (OpenRead or OpenWrite),
read data from a cursor
(Column), advance the cursor to the next entry in the table
(Next) or index (NextIdx), and many other operations.
All cursors are automatically
closed when the virtual machine terminates.</p>

<p>The virtual machine contains an arbitrary number of registers
locations with addresses beginning at one and growing upward.
Each memory location can hold an arbitrary string.  The registers
hold all intermediate results of a calculation.</p>

<h3>Viewing Programs Generated By SQLite</h3>

<p>Every SQL statement that SQLite interprets results in a program
for the virtual machine.  But if you precede the SQL statement with
the keyword <a href="lang_explain.html">EXPLAIN</a> the virtual machine will not execute the
program.  Instead, the instructions of the program will be returned
like a query result.  This feature is useful for debugging and
for learning how the virtual machine operates.</p>

<p>You can use the <b>sqlite3.exe</b> command-line interface (CLI)
tool to see the
instructions generated by an SQL statement.  The following is
an example:</p>

<blockquote><tt>$&nbsp;<b>sqlite3&nbsp;ex1.db</b><br>
sqlite&gt;&nbsp;<b>.explain</b><br>
sqlite&gt;&nbsp;<b>explain&nbsp;delete&nbsp;from&nbsp;tbl1&nbsp;where&nbsp;two&lt;20;</b><br>
addr&nbsp;&nbsp;opcode&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p1&nbsp;&nbsp;&nbsp;&nbsp;p2&nbsp;&nbsp;&nbsp;&nbsp;p3&nbsp;&nbsp;&nbsp;&nbsp;p4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p5&nbsp;&nbsp;comment<br>
----&nbsp;&nbsp;-------------&nbsp;&nbsp;----&nbsp;&nbsp;----&nbsp;&nbsp;----&nbsp;&nbsp;---------&nbsp;&nbsp;--&nbsp;&nbsp;-------<br>
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Trace&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;explain..&nbsp;&nbsp;00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Goto&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;20&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenRead&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;00&nbsp;&nbsp;tbl&nbsp;&nbsp;&nbsp;&nbsp;<br>
3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SetNumColumns&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Rewind&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Column&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;00&nbsp;&nbsp;tbl.two<br>
6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;20&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ge&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cs(BINARY)&nbsp;6a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Rowid&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FifoWrite&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
10&nbsp;&nbsp;&nbsp;&nbsp;Next&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
11&nbsp;&nbsp;&nbsp;&nbsp;Close&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
12&nbsp;&nbsp;&nbsp;&nbsp;OpenWrite&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;00&nbsp;&nbsp;tbl&nbsp;&nbsp;&nbsp;&nbsp;<br>
13&nbsp;&nbsp;&nbsp;&nbsp;SetNumColumns&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
14&nbsp;&nbsp;&nbsp;&nbsp;FifoRead&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
15&nbsp;&nbsp;&nbsp;&nbsp;NotExists&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
16&nbsp;&nbsp;&nbsp;&nbsp;Delete&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tbl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
17&nbsp;&nbsp;&nbsp;&nbsp;Goto&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;14&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
18&nbsp;&nbsp;&nbsp;&nbsp;Close&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
19&nbsp;&nbsp;&nbsp;&nbsp;Halt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
20&nbsp;&nbsp;&nbsp;&nbsp;Transaction&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
21&nbsp;&nbsp;&nbsp;&nbsp;VerifyCookie&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
22&nbsp;&nbsp;&nbsp;&nbsp;TableLock&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-1&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tbl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
23&nbsp;&nbsp;&nbsp;&nbsp;Goto&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;00</tt></blockquote>

<p>All you have to do is add the <a href="lang_explain.html">EXPLAIN</a> keyword to the front of the
SQL statement.  But if you use the ".explain" command in the CLI,
it will set up the output mode to make the program more easily
viewable.</p>

<p>Depending on compile-time options, you 
can put the SQLite virtual machine in a mode where it will trace its
execution by writing messages to standard output.  The non-standard
SQL "PRAGMA" comments can be used to turn tracing on and off.  To
turn tracing on, enter:
</p>

<blockquote><pre>
PRAGMA vdbe_trace=on;
</pre></blockquote>

<p>
You can turn tracing back off by entering a similar statement but
changing the value "on" to "off".</p>

<h3>The Opcodes</h3>

<p>There are currently 138
opcodes defined by the virtual machine.
All currently defined opcodes are described in the table below.
This table was generated automatically by scanning the source code
from the file <b>vdbe.c</b>.</p>

<p><table cellspacing="1" border="1" cellpadding="10">
<tr><th>Opcode&nbsp;Name</th><th>Description</th></tr>

<tr><td valign="top" align="center"><a name="Add"></a><p>Add</p><td><p>Add the value in register P1 to the value in register P2
and store the result in register P3.
If either input is NULL, the result is NULL.</td></tr><tr><td valign="top" align="center"><a name="AddImm"></a><p>AddImm</p><td><p>Add the constant P2 to the value in register P1.
The result is always an integer.</p>

<p>To force any register to be an integer, just add 0.</td></tr><tr><td valign="top" align="center"><a name="Affinity"></a><p>Affinity</p><td><p>Apply affinities to a range of P2 registers starting with P1.</p>

<p>P4 is a string that is P2 characters long. The nth character of the
string indicates the column affinity that should be used for the nth
memory cell in the range.</td></tr><tr><td valign="top" align="center"><a name="AggFinal"></a><p>AggFinal</p><td><p>Execute the finalizer function for an aggregate.  P1 is
the memory location that is the accumulator for the aggregate.</p>

<p>P2 is the number of arguments that the step function takes and
P4 is a pointer to the FuncDef for this function.  The P2
argument is not used by this opcode.  It is only there to disambiguate
functions that can take varying numbers of arguments.  The
P4 argument is only needed for the degenerate case where
the step function was not previously called.</td></tr><tr><td valign="top" align="center"><a name="AggStep"></a><p>AggStep</p><td><p>Execute the step function for an aggregate.  The
function has P5 arguments.   P4 is a pointer to the FuncDef
structure that specifies the function.  Use register
P3 as the accumulator.</p>

<p>The P5 arguments are taken from register P2 and its
successors.</td></tr><tr><td valign="top" align="center"><a name="And"></a><p>And</p><td><p>Take the logical AND of the values in registers P1 and P2 and
write the result into register P3.</p>

<p>If either P1 or P2 is 0 (false) then the result is 0 even if
the other input is NULL.  A NULL and true or two NULLs give
a NULL output.</td></tr><tr><td valign="top" align="center"><a name="AutoCommit"></a><p>AutoCommit</p><td><p>Set the database auto-commit flag to P1 (1 or 0). If P2 is true, roll
back any currently active btree transactions. If there are any active
VMs (apart from this one), then a ROLLBACK fails.  A COMMIT fails if
there are active writing VMs or active VMs that use shared cache.</p>

<p>This instruction causes the VM to halt.</td></tr><tr><td valign="top" align="center"><a name="BitAnd"></a><p>BitAnd</p><td><p>Take the bit-wise AND of the values in register P1 and P2 and
store the result in register P3.
If either input is NULL, the result is NULL.</td></tr><tr><td valign="top" align="center"><a name="BitNot"></a><p>BitNot</p><td><p>Interpret the content of register P1 as an integer.  Store the
ones-complement of the P1 value into register P2.  If P1 holds
a NULL then store a NULL in P2.</td></tr><tr><td valign="top" align="center"><a name="BitOr"></a><p>BitOr</p><td><p>Take the bit-wise OR of the values in register P1 and P2 and
store the result in register P3.
If either input is NULL, the result is NULL.</td></tr><tr><td valign="top" align="center"><a name="Blob"></a><p>Blob</p><td><p>P4 points to a blob of data P1 bytes long.  Store this
blob in register P2. This instruction is not coded directly
by the compiler. Instead, the compiler layer specifies
an OP_HexBlob opcode, with the hex string representation of
the blob as P4. This opcode is transformed to an OP_Blob
the first time it is executed.</td></tr><tr><td valign="top" align="center"><a name="Clear"></a><p>Clear</p><td><p>Delete all contents of the database table or index whose root page
in the database file is given by P1.  But, unlike Destroy, do not
remove the table or index from the database file.</p>

<p>The table being clear is in the main database file if P2==0.  If
P2==1 then the table to be clear is in the auxiliary database file
that is used to store tables create using CREATE TEMPORARY TABLE.</p>

<p>If the P3 value is non-zero, then the table referred to must be an
intkey table (an SQL table, not an index). In this case the row change
count is incremented by the number of rows in the table being cleared.
If P3 is greater than zero, then the value stored in register P3 is
also incremented by the number of rows in the table being cleared.</p>

<p>See also: Destroy</td></tr><tr><td valign="top" align="center"><a name="Close"></a><p>Close</p><td><p>Close a cursor previously opened as P1.  If P1 is not
currently open, this instruction is a no-op.</td></tr><tr><td valign="top" align="center"><a name="CollSeq"></a><p>CollSeq</p><td><p>P4 is a pointer to a CollSeq struct. If the next call to a user function
or aggregate calls sqlite3GetFuncCollSeq(), this collation sequence will
be returned. This is used by the built-in min(), max() and nullif()
functions.</p>

<p>The interface used by the implementation of the aforementioned functions
to retrieve the collation sequence set by this opcode is not available
publicly, only to user functions defined in func.c.</td></tr><tr><td valign="top" align="center"><a name="Column"></a><p>Column</p><td><p>Interpret the data that cursor P1 points to as a structure built using
the MakeRecord instruction.  (See the MakeRecord opcode for additional
information about the format of the data.)  Extract the P2-th column
from this record.  If there are less that (P2+1)
values in the record, extract a NULL.</p>

<p>The value extracted is stored in register P3.</p>

<p>If the column contains fewer than P2 fields, then extract a NULL.  Or,
if the P4 argument is a P4_MEM use the value of the P4 argument as
the result.</p>

<p>If the OPFLAG_CLEARCACHE bit is set on P5 and P1 is a pseudo-table cursor,
then the cache of the cursor is reset prior to extracting the column.
The first OP_Column against a pseudo-table after the value of the content
register has changed should have this bit set.</td></tr><tr><td valign="top" align="center"><a name="Compare"></a><p>Compare</p><td><p>Compare to vectors of registers in reg(P1)..reg(P1+P3-1) (all this
one "A") and in reg(P2)..reg(P2+P3-1) ("B").  Save the result of
the comparison for use by the next OP_Jump instruct.</p>

<p>P4 is a KeyInfo structure that defines collating sequences and sort
orders for the comparison.  The permutation applies to registers
only.  The KeyInfo elements are used sequentially.</p>

<p>The comparison is a sort comparison, so NULLs compare equal,
NULLs are less than numbers, numbers are less than strings,
and strings are less than blobs.</td></tr><tr><td valign="top" align="center"><a name="Concat"></a><p>Concat</p><td><p>Add the text in register P1 onto the end of the text in
register P2 and store the result in register P3.
If either the P1 or P2 text are NULL then store NULL in P3.</p>

<p>P3 = P2 || P1</p>

<p>It is illegal for P1 and P3 to be the same register. Sometimes,
if P3 is the same register as P2, the implementation is able
to avoid a memcpy().</td></tr><tr><td valign="top" align="center"><a name="Copy"></a><p>Copy</p><td><p>Make a copy of register P1 into register P2.</p>

<p>This instruction makes a deep copy of the value.  A duplicate
is made of any string or blob constant.  See also OP_SCopy.</td></tr><tr><td valign="top" align="center"><a name="Count"></a><p>Count</p><td><p>Store the number of entries (an integer value) in the table or index
opened by cursor P1 in register P2</td></tr><tr><td valign="top" align="center"><a name="CreateIndex"></a><p>CreateIndex</p><td><p>Allocate a new index in the main database file if P1==0 or in the
auxiliary database file if P1==1 or in an attached database if
P1&gt;1.  Write the root page number of the new table into
register P2.</p>

<p>See documentation on OP_CreateTable for additional information.</td></tr><tr><td valign="top" align="center"><a name="CreateTable"></a><p>CreateTable</p><td><p>Allocate a new table in the main database file if P1==0 or in the
auxiliary database file if P1==1 or in an attached database if
P1&gt;1.  Write the root page number of the new table into
register P2</p>

<p>The difference between a table and an index is this:  A table must
have a 4-byte integer key and can have arbitrary data.  An index
has an arbitrary key but no data.</p>

<p>See also: CreateIndex</td></tr><tr><td valign="top" align="center"><a name="Delete"></a><p>Delete</p><td><p>Delete the record at which the P1 cursor is currently pointing.</p>

<p>The cursor will be left pointing at either the next or the previous
record in the table. If it is left pointing at the next record, then
the next Next instruction will be a no-op.  Hence it is OK to delete
a record from within an Next loop.</p>

<p>If the OPFLAG_NCHANGE flag of P2 is set, then the row change count is
incremented (otherwise not).</p>

<p>P1 must not be pseudo-table.  It has to be a real table with
multiple rows.</p>

<p>If P4 is not NULL, then it is the name of the table that P1 is
pointing to.  The update hook will be invoked, if it exists.
If P4 is not NULL then the P1 cursor must have been positioned
using OP_NotFound prior to invoking this opcode.</td></tr><tr><td valign="top" align="center"><a name="Destroy"></a><p>Destroy</p><td><p>Delete an entire database table or index whose root page in the database
file is given by P1.</p>

<p>The table being destroyed is in the main database file if P3==0.  If
P3==1 then the table to be clear is in the auxiliary database file
that is used to store tables create using CREATE TEMPORARY TABLE.</p>

<p>If AUTOVACUUM is enabled then it is possible that another root page
might be moved into the newly deleted root page in order to keep all
root pages contiguous at the beginning of the database.  The former
value of the root page that moved - its value before the move occurred -
is stored in register P2.  If no page
movement was required (because the table being dropped was already
the last one in the database) then a zero is stored in register P2.
If AUTOVACUUM is disabled then a zero is stored in register P2.</p>

<p>See also: Clear</td></tr><tr><td valign="top" align="center"><a name="Divide"></a><p>Divide</p><td><p>Divide the value in register P1 by the value in register P2
and store the result in register P3 (P3=P2/P1). If the value in
register P1 is zero, then the result is NULL. If either input is
NULL, the result is NULL.</td></tr><tr><td valign="top" align="center"><a name="DropIndex"></a><p>DropIndex</p><td><p>Remove the internal (in-memory) data structures that describe
the index named P4 in database P1.  This is called after an index
is dropped in order to keep the internal representation of the
schema consistent with what is on disk.</td></tr><tr><td valign="top" align="center"><a name="DropTable"></a><p>DropTable</p><td><p>Remove the internal (in-memory) data structures that describe
the table named P4 in database P1.  This is called after a table
is dropped in order to keep the internal representation of the
schema consistent with what is on disk.</td></tr><tr><td valign="top" align="center"><a name="DropTrigger"></a><p>DropTrigger</p><td><p>Remove the internal (in-memory) data structures that describe
the trigger named P4 in database P1.  This is called after a trigger
is dropped in order to keep the internal representation of the
schema consistent with what is on disk.</td></tr><tr><td valign="top" align="center"><a name="Eq"></a><p>Eq</p><td><p>This works just like the Lt opcode except that the jump is taken if
the operands in registers P1 and P3 are equal.
See the Lt opcode for additional information.</p>

<p>If SQLITE_NULLEQ is set in P5 then the result of comparison is always either
true or false and is never NULL.  If both operands are NULL then the result
of comparison is true.  If either operand is NULL then the result is false.
If neither operand is NULL the the result is the same as it would be if
the SQLITE_NULLEQ flag were omitted from P5.</td></tr><tr><td valign="top" align="center"><a name="Expire"></a><p>Expire</p><td><p>Cause precompiled statements to become expired. An expired statement
fails with an error code of SQLITE_SCHEMA if it is ever executed
(via sqlite3_step()).</p>

<p>If P1 is 0, then all SQL statements become expired. If P1 is non-zero,
then only the currently executing statement is affected.</td></tr><tr><td valign="top" align="center"><a name="FkCounter"></a><p>FkCounter</p><td><p>Increment a "constraint counter" by P2 (P2 may be negative or positive).
If P1 is non-zero, the database constraint counter is incremented
(deferred foreign key constraints). Otherwise, if P1 is zero, the
statement counter is incremented (immediate foreign key constraints).</td></tr><tr><td valign="top" align="center"><a name="FkIfZero"></a><p>FkIfZero</p><td><p>This opcode tests if a foreign key constraint-counter is currently zero.
If so, jump to instruction P2. Otherwise, fall through to the next
instruction.</p>

<p>If P1 is non-zero, then the jump is taken if the database constraint-counter
is zero (the one that counts deferred constraint violations). If P1 is
zero, the jump is taken if the statement constraint-counter is zero
(immediate foreign key constraint violations).</td></tr><tr><td valign="top" align="center"><a name="Found"></a><p>Found</p><td><p>If P4==0 then register P3 holds a blob constructed by MakeRecord.  If
P4&gt;0 then register P3 is the first of P4 registers that form an unpacked
record.</p>

<p>Cursor P1 is on an index btree.  If the record identified by P3 and P4
is a prefix of any entry in P1 then a jump is made to P2 and
P1 is left pointing at the matching entry.</td></tr><tr><td valign="top" align="center"><a name="Function"></a><p>Function</p><td><p>Invoke a user function (P4 is a pointer to a Function structure that
defines the function) with P5 arguments taken from register P2 and
successors.  The result of the function is stored in register P3.
Register P3 must not be one of the function inputs.</p>

<p>P1 is a 32-bit bitmask indicating whether or not each argument to the
function was determined to be constant at compile time. If the first
argument was constant then bit 0 of P1 is set. This is used to determine
whether meta data associated with a user function argument using the
sqlite3_set_auxdata() API may be safely retained until the next
invocation of this opcode.</p>

<p>See also: AggStep and AggFinal</td></tr><tr><td valign="top" align="center"><a name="Ge"></a><p>Ge</p><td><p>This works just like the Lt opcode except that the jump is taken if
the content of register P3 is greater than or equal to the content of
register P1.  See the Lt opcode for additional information.</td></tr><tr><td valign="top" align="center"><a name="Gosub"></a><p>Gosub</p><td><p>Write the current address onto register P1
and then jump to address P2.</td></tr><tr><td valign="top" align="center"><a name="Goto"></a><p>Goto</p><td><p>An unconditional jump to address P2.
The next instruction executed will be
the one at index P2 from the beginning of
the program.</td></tr><tr><td valign="top" align="center"><a name="Gt"></a><p>Gt</p><td><p>This works just like the Lt opcode except that the jump is taken if
the content of register P3 is greater than the content of
register P1.  See the Lt opcode for additional information.</td></tr><tr><td valign="top" align="center"><a name="Halt"></a><p>Halt</p><td><p>Exit immediately.  All open cursors, etc are closed
automatically.</p>

<p>P1 is the result code returned by sqlite3_exec(), sqlite3_reset(),
or sqlite3_finalize().  For a normal halt, this should be SQLITE_OK (0).
For errors, it can be some other value.  If P1!=0 then P2 will determine
whether or not to rollback the current transaction.  Do not rollback
if P2==OE_Fail. Do the rollback if P2==OE_Rollback.  If P2==OE_Abort,
then back out all changes that have occurred during this execution of the
VDBE, but do not rollback the transaction.</p>

<p>If P4 is not null then it is an error message string.</p>

<p>There is an implied "Halt 0 0 0" instruction inserted at the very end of
every program.  So a jump past the last instruction of the program
is the same as executing Halt.</td></tr><tr><td valign="top" align="center"><a name="HaltIfNull"></a><p>HaltIfNull</p><td><p>Check the value in register P3.  If is is NULL then Halt using
parameter P1, P2, and P4 as if this were a Halt instruction.  If the
value in register P3 is not NULL, then this routine is a no-op.</td></tr><tr><td valign="top" align="center"><a name="IdxDelete"></a><p>IdxDelete</p><td><p>The content of P3 registers starting at register P2 form
an unpacked index key. This opcode removes that entry from the
index opened by cursor P1.</td></tr><tr><td valign="top" align="center"><a name="IdxGE"></a><p>IdxGE</p><td><p>The P4 register values beginning with P3 form an unpacked index
key that omits the ROWID.  Compare this key value against the index
that P1 is currently pointing to, ignoring the ROWID on the P1 index.</p>

<p>If the P1 index entry is greater than or equal to the key value
then jump to P2.  Otherwise fall through to the next instruction.</p>

<p>If P5 is non-zero then the key value is increased by an epsilon
prior to the comparison.  This make the opcode work like IdxGT except
that if the key from register P3 is a prefix of the key in the cursor,
the result is false whereas it would be true with IdxGT.</td></tr><tr><td valign="top" align="center"><a name="IdxInsert"></a><p>IdxInsert</p><td><p>Register P2 holds a SQL index key made using the
MakeRecord instructions.  This opcode writes that key
into the index P1.  Data for the entry is nil.</p>

<p>P3 is a flag that provides a hint to the b-tree layer that this
insert is likely to be an append.</p>

<p>This instruction only works for indices.  The equivalent instruction
for tables is OP_Insert.</td></tr><tr><td valign="top" align="center"><a name="IdxLT"></a><p>IdxLT</p><td><p>The P4 register values beginning with P3 form an unpacked index
key that omits the ROWID.  Compare this key value against the index
that P1 is currently pointing to, ignoring the ROWID on the P1 index.</p>

<p>If the P1 index entry is less than the key value then jump to P2.
Otherwise fall through to the next instruction.</p>

<p>If P5 is non-zero then the key value is increased by an epsilon prior
to the comparison.  This makes the opcode work like IdxLE.</td></tr><tr><td valign="top" align="center"><a name="IdxRowid"></a><p>IdxRowid</p><td><p>Write into register P2 an integer which is the last entry in the record at
the end of the index key pointed to by cursor P1.  This integer should be
the rowid of the table entry to which this index entry points.</p>

<p>See also: Rowid, MakeRecord.</td></tr><tr><td valign="top" align="center"><a name="If"></a><p>If</p><td><p>Jump to P2 if the value in register P1 is true.  The value is
is considered true if it is numeric and non-zero.  If the value
in P1 is NULL then take the jump if P3 is true.</td></tr><tr><td valign="top" align="center"><a name="IfNeg"></a><p>IfNeg</p><td><p>If the value of register P1 is less than zero, jump to P2.</p>

<p>It is illegal to use this instruction on a register that does
not contain an integer.  An assertion fault will result if you try.</td></tr><tr><td valign="top" align="center"><a name="IfNot"></a><p>IfNot</p><td><p>Jump to P2 if the value in register P1 is False.  The value is
is considered true if it has a numeric value of zero.  If the value
in P1 is NULL then take the jump if P3 is true.</td></tr><tr><td valign="top" align="center"><a name="IfPos"></a><p>IfPos</p><td><p>If the value of register P1 is 1 or greater, jump to P2.</p>

<p>It is illegal to use this instruction on a register that does
not contain an integer.  An assertion fault will result if you try.</td></tr><tr><td valign="top" align="center"><a name="IfZero"></a><p>IfZero</p><td><p>The register P1 must contain an integer.  Add literal P3 to the
value in register P1.  If the result is exactly 0, jump to P2.</p>

<p>It is illegal to use this instruction on a register that does
not contain an integer.  An assertion fault will result if you try.</td></tr><tr><td valign="top" align="center"><a name="IncrVacuum"></a><p>IncrVacuum</p><td><p>Perform a single step of the incremental vacuum procedure on
the P1 database. If the vacuum has finished, jump to instruction
P2. Otherwise, fall through to the next instruction.</td></tr><tr><td valign="top" align="center"><a name="Insert"></a><p>Insert</p><td><p>Write an entry into the table of cursor P1.  A new entry is
created if it doesn't already exist or the data for an existing
entry is overwritten.  The data is the value MEM_Blob stored in register
number P2. The key is stored in register P3. The key must
be a MEM_Int.</p>

<p>If the OPFLAG_NCHANGE flag of P5 is set, then the row change count is
incremented (otherwise not).  If the OPFLAG_LASTROWID flag of P5 is set,
then rowid is stored for subsequent return by the
sqlite3_last_insert_rowid() function (otherwise it is unmodified).</p>

<p>If the OPFLAG_USESEEKRESULT flag of P5 is set and if the result of
the last seek operation (OP_NotExists) was a success, then this
operation will not attempt to find the appropriate row before doing
the insert but will instead overwrite the row that the cursor is
currently pointing to.  Presumably, the prior OP_NotExists opcode
has already positioned the cursor correctly.  This is an optimization
that boosts performance by avoiding redundant seeks.</p>

<p>If the OPFLAG_ISUPDATE flag is set, then this opcode is part of an
UPDATE operation.  Otherwise (if the flag is clear) then this opcode
is part of an INSERT operation.  The difference is only important to
the update hook.</p>

<p>Parameter P4 may point to a string containing the table-name, or
may be NULL. If it is not NULL, then the update-hook
(sqlite3.xUpdateCallback) is invoked following a successful insert.</p>

<p>(WARNING/TODO: If P1 is a pseudo-cursor and P2 is dynamically
allocated, then ownership of P2 is transferred to the pseudo-cursor
and register P2 becomes ephemeral.  If the cursor is changed, the
value of register P2 will then change.  Make sure this does not
cause any problems.)</p>

<p>This instruction only works on tables.  The equivalent instruction
for indices is OP_IdxInsert.</td></tr><tr><td valign="top" align="center"><a name="InsertInt"></a><p>InsertInt</p><td><p>This works exactly like OP_Insert except that the key is the
integer value P3, not the value of the integer stored in register P3.</td></tr><tr><td valign="top" align="center"><a name="Int64"></a><p>Int64</p><td><p>P4 is a pointer to a 64-bit integer value.
Write that value into register P2.</td></tr><tr><td valign="top" align="center"><a name="Integer"></a><p>Integer</p><td><p>The 32-bit integer value P1 is written into register P2.</td></tr><tr><td valign="top" align="center"><a name="IntegrityCk"></a><p>IntegrityCk</p><td><p>Do an analysis of the currently open database.  Store in
register P1 the text of an error message describing any problems.
If no problems are found, store a NULL in register P1.</p>

<p>The register P3 contains the maximum number of allowed errors.
At most reg(P3) errors will be reported.
In other words, the analysis stops as soon as reg(P1) errors are
seen.  Reg(P1) is updated with the number of errors remaining.</p>

<p>The root page numbers of all tables in the database are integer
stored in reg(P1), reg(P1+1), reg(P1+2), ....  There are P2 tables
total.</p>

<p>If P5 is not zero, the check is done on the auxiliary database
file, not the main database file.</p>

<p>This opcode is used to implement the integrity_check pragma.</td></tr><tr><td valign="top" align="center"><a name="IsNull"></a><p>IsNull</p><td><p>Jump to P2 if the value in register P1 is NULL.</td></tr><tr><td valign="top" align="center"><a name="IsUnique"></a><p>IsUnique</p><td><p>Cursor P1 is open on an index b-tree - that is to say, a btree which
no data and where the key are records generated by OP_MakeRecord with
the list field being the integer ROWID of the entry that the index
entry refers to.</p>

<p>The P3 register contains an integer record number. Call this record
number R. Register P4 is the first in a set of N contiguous registers
that make up an unpacked index key that can be used with cursor P1.
The value of N can be inferred from the cursor. N includes the rowid
value appended to the end of the index record. This rowid value may
or may not be the same as R.</p>

<p>If any of the N registers beginning with register P4 contains a NULL
value, jump immediately to P2.</p>

<p>Otherwise, this instruction checks if cursor P1 contains an entry
where the first (N-1) fields match but the rowid value at the end
of the index entry is not R. If there is no such entry, control jumps
to instruction P2. Otherwise, the rowid of the conflicting index
entry is copied to register P3 and control falls through to the next
instruction.</p>

<p>See also: NotFound, NotExists, Found</td></tr><tr><td valign="top" align="center"><a name="Jump"></a><p>Jump</p><td><p>Jump to the instruction at address P1, P2, or P3 depending on whether
in the most recent OP_Compare instruction the P1 vector was less than
equal to, or greater than the P2 vector, respectively.</td></tr><tr><td valign="top" align="center"><a name="Last"></a><p>Last</p><td><p>The next use of the Rowid or Column or Next instruction for P1
will refer to the last entry in the database table or index.
If the table or index is empty and P2&gt;0, then jump immediately to P2.
If P2 is 0 or if the table or index is not empty, fall through
to the following instruction.</td></tr><tr><td valign="top" align="center"><a name="Le"></a><p>Le</p><td><p>This works just like the Lt opcode except that the jump is taken if
the content of register P3 is less than or equal to the content of
register P1.  See the Lt opcode for additional information.</td></tr><tr><td valign="top" align="center"><a name="LoadAnalysis"></a><p>LoadAnalysis</p><td><p>Read the sqlite_stat1 table for database P1 and load the content
of that table into the internal index hash table.  This will cause
the analysis to be used when preparing all subsequent queries.</td></tr><tr><td valign="top" align="center"><a name="Lt"></a><p>Lt</p><td><p>Compare the values in register P1 and P3.  If reg(P3)&lt;reg(P1) then
jump to address P2.</p>

<p>If the SQLITE_JUMPIFNULL bit of P5 is set and either reg(P1) or
reg(P3) is NULL then take the jump.  If the SQLITE_JUMPIFNULL
bit is clear then fall thru if either operand is NULL.</p>

<p>The SQLITE_AFF_MASK portion of P5 must be an affinity character -
SQLITE_AFF_TEXT, SQLITE_AFF_INTEGER, and so forth. An attempt is made
to coerce both inputs according to this affinity before the
comparison is made. If the SQLITE_AFF_MASK is 0x00, then numeric
affinity is used. Note that the affinity conversions are stored
back into the input registers P1 and P3.  So this opcode can cause
persistent changes to registers P1 and P3.</p>

<p>Once any conversions have taken place, and neither value is NULL,
the values are compared. If both values are blobs then memcmp() is
used to determine the results of the comparison.  If both values
are text, then the appropriate collating function specified in
P4 is  used to do the comparison.  If P4 is not specified then
memcmp() is used to compare text string.  If both values are
numeric, then a numeric comparison is used. If the two values
are of different types, then numbers are considered less than
strings and strings are considered less than blobs.</p>

<p>If the SQLITE_STOREP2 bit of P5 is set, then do not jump.  Instead,
store a boolean result (either 0, or 1, or NULL) in register P2.</td></tr><tr><td valign="top" align="center"><a name="MakeRecord"></a><p>MakeRecord</p><td><p>Convert P2 registers beginning with P1 into a single entry
suitable for use as a data record in a database table or as a key
in an index.  The details of the format are irrelevant as long as
the OP_Column opcode can decode the record later.
Refer to source code comments for the details of the record
format.</p>

<p>P4 may be a string that is P2 characters long.  The nth character of the
string indicates the column affinity that should be used for the nth
field of the index key.</p>

<p>The mapping from character to affinity is given by the SQLITE_AFF_
macros defined in sqliteInt.h.</p>

<p>If P4 is NULL then all index fields have the affinity NONE.</td></tr><tr><td valign="top" align="center"><a name="MemMax"></a><p>MemMax</p><td><p>P1 is a register in the root frame of this VM (the root frame is
different from the current frame if this instruction is being executed
within a sub-program). Set the value of register P1 to the maximum of
its current value and the value in register P2.</p>

<p>This instruction throws an error if the memory cell is not initially
an integer.</td></tr><tr><td valign="top" align="center"><a name="Move"></a><p>Move</p><td><p>Move the values in register P1..P1+P3-1 over into
registers P2..P2+P3-1.  Registers P1..P1+P1-1 are
left holding a NULL.  It is an error for register ranges
P1..P1+P3-1 and P2..P2+P3-1 to overlap.</td></tr><tr><td valign="top" align="center"><a name="Multiply"></a><p>Multiply</p><td><p>Multiply the value in register P1 by the value in register P2
and store the result in register P3.
If either input is NULL, the result is NULL.</td></tr><tr><td valign="top" align="center"><a name="MustBeInt"></a><p>MustBeInt</p><td><p>Force the value in register P1 to be an integer.  If the value
in P1 is not an integer and cannot be converted into an integer
without data loss, then jump immediately to P2, or if P2==0
raise an SQLITE_MISMATCH exception.</td></tr><tr><td valign="top" align="center"><a name="Ne"></a><p>Ne</p><td><p>This works just like the Lt opcode except that the jump is taken if
the operands in registers P1 and P3 are not equal.  See the Lt opcode for
additional information.</p>

<p>If SQLITE_NULLEQ is set in P5 then the result of comparison is always either
true or false and is never NULL.  If both operands are NULL then the result
of comparison is false.  If either operand is NULL then the result is true.
If neither operand is NULL the the result is the same as it would be if
the SQLITE_NULLEQ flag were omitted from P5.</td></tr><tr><td valign="top" align="center"><a name="NewRowid"></a><p>NewRowid</p><td><p>Get a new integer record number (a.k.a "rowid") used as the key to a table.
The record number is not previously used as a key in the database
table that cursor P1 points to.  The new record number is written
written to register P2.</p>

<p>If P3&gt;0 then P3 is a register in the root frame of this VDBE that holds
the largest previously generated record number. No new record numbers are
allowed to be less than this value. When this value reaches its maximum,
a SQLITE_FULL error is generated. The P3 register is updated with the '
generated record number. This P3 mechanism is used to help implement the
AUTOINCREMENT feature.</td></tr><tr><td valign="top" align="center"><a name="Next"></a><p>Next</p><td><p>Advance cursor P1 so that it points to the next key/data pair in its
table or index.  If there are no more key/value pairs then fall through
to the following instruction.  But if the cursor advance was successful,
jump immediately to P2.</p>

<p>The P1 cursor must be for a real table, not a pseudo-table.</p>

<p>See also: Prev</td></tr><tr><td valign="top" align="center"><a name="Noop"></a><p>Noop</p><td><p>Do nothing.  This instruction is often useful as a jump
destination.</td></tr><tr><td valign="top" align="center"><a name="Not"></a><p>Not</p><td><p>Interpret the value in register P1 as a boolean value.  Store the
boolean complement in register P2.  If the value in register P1 is
NULL, then a NULL is stored in P2.</td></tr><tr><td valign="top" align="center"><a name="NotExists"></a><p>NotExists</p><td><p>Use the content of register P3 as a integer key.  If a record
with that key does not exist in table of P1, then jump to P2.
If the record does exist, then fall thru.  The cursor is left
pointing to the record if it exists.</p>

<p>The difference between this operation and NotFound is that this
operation assumes the key is an integer and that P1 is a table whereas
NotFound assumes key is a blob constructed from MakeRecord and
P1 is an index.</p>

<p>See also: Found, NotFound, IsUnique</td></tr><tr><td valign="top" align="center"><a name="NotFound"></a><p>NotFound</p><td><p>If P4==0 then register P3 holds a blob constructed by MakeRecord.  If
P4&gt;0 then register P3 is the first of P4 registers that form an unpacked
record.</p>

<p>Cursor P1 is on an index btree.  If the record identified by P3 and P4
is not the prefix of any entry in P1 then a jump is made to P2.  If P1
does contain an entry whose prefix matches the P3/P4 record then control
falls through to the next instruction and P1 is left pointing at the
matching entry.</p>

<p>See also: Found, NotExists, IsUnique</td></tr><tr><td valign="top" align="center"><a name="NotNull"></a><p>NotNull</p><td><p>Jump to P2 if the value in register P1 is not NULL.</td></tr><tr><td valign="top" align="center"><a name="Null"></a><p>Null</p><td><p>Write a NULL into register P2.</td></tr><tr><td valign="top" align="center"><a name="NullRow"></a><p>NullRow</p><td><p>Move the cursor P1 to a null row.  Any OP_Column operations
that occur while the cursor is on the null row will always
write a NULL.</td></tr><tr><td valign="top" align="center"><a name="OpenEphemeral"></a><p>OpenEphemeral</p><td><p>Open a new cursor P1 to a transient table.
The cursor is always opened read/write even if
the main database is read-only.  The transient or virtual
table is deleted automatically when the cursor is closed.</p>

<p>P2 is the number of columns in the virtual table.
The cursor points to a BTree table if P4==0 and to a BTree index
if P4 is not 0.  If P4 is not NULL, it points to a KeyInfo structure
that defines the format of keys in the index.</p>

<p>This opcode was once called OpenTemp.  But that created
confusion because the term "temp table", might refer either
to a TEMP table at the SQL level, or to a table opened by
this opcode.  Then this opcode was call OpenVirtual.  But
that created confusion with the whole virtual-table idea.</td></tr><tr><td valign="top" align="center"><a name="OpenPseudo"></a><p>OpenPseudo</p><td><p>Open a new cursor that points to a fake table that contains a single
row of data.  The content of that one row in the content of memory
register P2.  In other words, cursor P1 becomes an alias for the
MEM_Blob content contained in register P2.</p>

<p>A pseudo-table created by this opcode is used to hold a single
row output from the sorter so that the row can be decomposed into
individual columns using the OP_Column opcode.  The OP_Column opcode
is the only cursor opcode that works with a pseudo-table.</p>

<p>P3 is the number of fields in the records that will be stored by
the pseudo-table.</td></tr><tr><td valign="top" align="center"><a name="OpenRead"></a><p>OpenRead</p><td><p>Open a read-only cursor for the database table whose root page is
P2 in a database file.  The database file is determined by P3.
P3==0 means the main database, P3==1 means the database used for
temporary tables, and P3&gt;1 means used the corresponding attached
database.  Give the new cursor an identifier of P1.  The P1
values need not be contiguous but all P1 values should be small integers.
It is an error for P1 to be negative.</p>

<p>If P5!=0 then use the content of register P2 as the root page, not
the value of P2 itself.</p>

<p>There will be a read lock on the database whenever there is an
open cursor.  If the database was unlocked prior to this instruction
then a read lock is acquired as part of this instruction.  A read
lock allows other processes to read the database but prohibits
any other process from modifying the database.  The read lock is
released when all cursors are closed.  If this instruction attempts
to get a read lock but fails, the script terminates with an
SQLITE_BUSY error code.</p>

<p>The P4 value may be either an integer (P4_INT32) or a pointer to
a KeyInfo structure (P4_KEYINFO). If it is a pointer to a KeyInfo
structure, then said structure defines the content and collating
sequence of the index being opened. Otherwise, if P4 is an integer
value, it is set to the number of columns in the table.</p>

<p>See also OpenWrite.</td></tr><tr><td valign="top" align="center"><a name="OpenWrite"></a><p>OpenWrite</p><td><p>Open a read/write cursor named P1 on the table or index whose root
page is P2.  Or if P5!=0 use the content of register P2 to find the
root page.</p>

<p>The P4 value may be either an integer (P4_INT32) or a pointer to
a KeyInfo structure (P4_KEYINFO). If it is a pointer to a KeyInfo
structure, then said structure defines the content and collating
sequence of the index being opened. Otherwise, if P4 is an integer
value, it is set to the number of columns in the table, or to the
largest index of any column of the table that is actually used.</p>

<p>This instruction works just like OpenRead except that it opens the cursor
in read/write mode.  For a given table, there can be one or more read-only
cursors or a single read/write cursor but not both.</p>

<p>See also OpenRead.</td></tr><tr><td valign="top" align="center"><a name="Or"></a><p>Or</p><td><p>Take the logical OR of the values in register P1 and P2 and
store the answer in register P3.</p>

<p>If either P1 or P2 is nonzero (true) then the result is 1 (true)
even if the other input is NULL.  A NULL and false or two NULLs
give a NULL output.</td></tr><tr><td valign="top" align="center"><a name="Pagecount"></a><p>Pagecount</p><td><p>Write the current number of pages in database P1 to memory cell P2.</td></tr><tr><td valign="top" align="center"><a name="Param"></a><p>Param</p><td><p>This opcode is only ever present in sub-programs called via the
OP_Program instruction. Copy a value currently stored in a memory
cell of the calling (parent) frame to cell P2 in the current frames
address space. This is used by trigger programs to access the new.*
and old.* values.</p>

<p>The address of the cell in the parent frame is determined by adding
the value of the P1 argument to the value of the P1 argument to the
calling OP_Program instruction.</td></tr><tr><td valign="top" align="center"><a name="ParseSchema"></a><p>ParseSchema</p><td><p>Read and parse all entries from the SQLITE_MASTER table of database P1
that match the WHERE clause P4.  P2 is the "force" flag.   Always do
the parsing if P2 is true.  If P2 is false, then this routine is a
no-op if the schema is not currently loaded.  In other words, if P2
is false, the SQLITE_MASTER table is only parsed if the rest of the
schema is already loaded into the symbol table.</p>

<p>This opcode invokes the parser to create a new virtual machine,
then runs the new virtual machine.  It is thus a re-entrant opcode.</td></tr><tr><td valign="top" align="center"><a name="Permutation"></a><p>Permutation</p><td><p>Set the permutation used by the OP_Compare operator to be the array
of integers in P4.</p>

<p>The permutation is only valid until the next OP_Permutation, OP_Compare,
OP_Halt, or OP_ResultRow.  Typically the OP_Permutation should occur
immediately prior to the OP_Compare.</td></tr><tr><td valign="top" align="center"><a name="Prev"></a><p>Prev</p><td><p>Back up cursor P1 so that it points to the previous key/data pair in its
table or index.  If there is no previous key/value pairs then fall through
to the following instruction.  But if the cursor backup was successful,
jump immediately to P2.</p>

<p>The P1 cursor must be for a real table, not a pseudo-table.</td></tr><tr><td valign="top" align="center"><a name="Program"></a><p>Program</p><td><p>Execute the trigger program passed as P4 (type P4_SUBPROGRAM).</p>

<p>P1 contains the address of the memory cell that contains the first memory
cell in an array of values used as arguments to the sub-program. P2
contains the address to jump to if the sub-program throws an IGNORE
exception using the RAISE() function. Register P3 contains the address
of a memory cell in this (the parent) VM that is used to allocate the
memory required by the sub-vdbe at runtime.</p>

<p>P4 is a pointer to the VM containing the trigger program.</td></tr><tr><td valign="top" align="center"><a name="ReadCookie"></a><p>ReadCookie</p><td><p>Read cookie number P3 from database P1 and write it into register P2.
P3==1 is the schema version.  P3==2 is the database format.
P3==3 is the recommended pager cache size, and so forth.  P1==0 is
the main database file and P1==1 is the database file used to store
temporary tables.</p>

<p>There must be a read-lock on the database (either a transaction
must be started or there must be an open cursor) before
executing this instruction.</td></tr><tr><td valign="top" align="center"><a name="Real"></a><p>Real</p><td><p>P4 is a pointer to a 64-bit floating point value.
Write that value into register P2.</td></tr><tr><td valign="top" align="center"><a name="RealAffinity"></a><p>RealAffinity</p><td><p>If register P1 holds an integer convert it to a real value.</p>

<p>This opcode is used when extracting information from a column that
has REAL affinity.  Such column values may still be stored as
integers, for space efficiency, but after extraction we want them
to have only a real value.</td></tr><tr><td valign="top" align="center"><a name="Remainder"></a><p>Remainder</p><td><p>Compute the remainder after integer division of the value in
register P1 by the value in register P2 and store the result in P3.
If the value in register P2 is zero the result is NULL.
If either operand is NULL, the result is NULL.</td></tr><tr><td valign="top" align="center"><a name="ResetCount"></a><p>ResetCount</p><td><p>The value of the change counter is copied to the database handle
change counter (returned by subsequent calls to sqlite3_changes()).
Then the VMs internal change counter resets to 0.
This is used by trigger programs.</td></tr><tr><td valign="top" align="center"><a name="ResultRow"></a><p>ResultRow</p><td><p>The registers P1 through P1+P2-1 contain a single row of
results. This opcode causes the sqlite3_step() call to terminate
with an SQLITE_ROW return code and it sets up the sqlite3_stmt
structure to provide access to the top P1 values as the result
row.</td></tr><tr><td valign="top" align="center"><a name="Return"></a><p>Return</p><td><p>Jump to the next instruction after the address in register P1.</td></tr><tr><td valign="top" align="center"><a name="Rewind"></a><p>Rewind</p><td><p>The next use of the Rowid or Column or Next instruction for P1
will refer to the first entry in the database table or index.
If the table or index is empty and P2&gt;0, then jump immediately to P2.
If P2 is 0 or if the table or index is not empty, fall through
to the following instruction.</td></tr><tr><td valign="top" align="center"><a name="RowData"></a><p>RowData</p><td><p>Write into register P2 the complete row data for cursor P1.
There is no interpretation of the data.
It is just copied onto the P2 register exactly as
it is found in the database file.</p>

<p>If the P1 cursor must be pointing to a valid row (not a NULL row)
of a real table, not a pseudo-table.</td></tr><tr><td valign="top" align="center"><a name="Rowid"></a><p>Rowid</p><td><p>Store in register P2 an integer which is the key of the table entry that
P1 is currently point to.</p>

<p>P1 can be either an ordinary table or a virtual table.  There used to
be a separate OP_VRowid opcode for use with virtual tables, but this
one opcode now works for both table types.</td></tr><tr><td valign="top" align="center"><a name="RowKey"></a><p>RowKey</p><td><p>Write into register P2 the complete row key for cursor P1.
There is no interpretation of the data.
The key is copied onto the P3 register exactly as
it is found in the database file.</p>

<p>If the P1 cursor must be pointing to a valid row (not a NULL row)
of a real table, not a pseudo-table.</td></tr><tr><td valign="top" align="center"><a name="RowSetAdd"></a><p>RowSetAdd</p><td><p>Insert the integer value held by register P2 into a boolean index
held in register P1.</p>

<p>An assertion fails if P2 is not an integer.</td></tr><tr><td valign="top" align="center"><a name="RowSetRead"></a><p>RowSetRead</p><td><p>Extract the smallest value from boolean index P1 and put that value into
register P3.  Or, if boolean index P1 is initially empty, leave P3
unchanged and jump to instruction P2.</td></tr><tr><td valign="top" align="center"><a name="RowSetTest"></a><p>RowSetTest</p><td><p>Register P3 is assumed to hold a 64-bit integer value. If register P1
contains a RowSet object and that RowSet object contains
the value held in P3, jump to register P2. Otherwise, insert the
integer in P3 into the RowSet and continue on to the
next opcode.</p>

<p>The RowSet object is optimized for the case where successive sets
of integers, where each set contains no duplicates. Each set
of values is identified by a unique P4 value. The first set
must have P4==0, the final set P4=-1.  P4 must be either -1 or
non-negative.  For non-negative values of P4 only the lower 4
bits are significant.</p>

<p>This allows optimizations: (a) when P4==0 there is no need to test
the rowset object for P3, as it is guaranteed not to contain it,
(b) when P4==-1 there is no need to insert the value, as it will
never be tested for, and (c) when a value that is part of set X is
inserted, there is no need to search to see if the same value was
previously inserted as part of set X (only if it was previously
inserted as part of some other set).</td></tr><tr><td valign="top" align="center"><a name="Savepoint"></a><p>Savepoint</p><td><p>Open, release or rollback the savepoint named by parameter P4, depending
on the value of P1. To open a new savepoint, P1==0. To release (commit) an
existing savepoint, P1==1, or to rollback an existing savepoint P1==2.</td></tr><tr><td valign="top" align="center"><a name="SCopy"></a><p>SCopy</p><td><p>Make a shallow copy of register P1 into register P2.</p>

<p>This instruction makes a shallow copy of the value.  If the value
is a string or blob, then the copy is only a pointer to the
original and hence if the original changes so will the copy.
Worse, if the original is deallocated, the copy becomes invalid.
Thus the program must guarantee that the original will not change
during the lifetime of the copy.  Use OP_Copy to make a complete
copy.</td></tr><tr><td valign="top" align="center"><a name="Seek"></a><p>Seek</p><td><p>P1 is an open table cursor and P2 is a rowid integer.  Arrange
for P1 to move so that it points to the rowid given by P2.</p>

<p>This is actually a deferred seek.  Nothing actually happens until
the cursor is used to read a record.  That way, if no reads
occur, no unnecessary I/O happens.</td></tr><tr><td valign="top" align="center"><a name="SeekGe"></a><p>SeekGe</p><td><p>If cursor P1 refers to an SQL table (B-Tree that uses integer keys),
use the value in register P3 as the key.  If cursor P1 refers
to an SQL index, then P3 is the first in an array of P4 registers
that are used as an unpacked index key.</p>

<p>Reposition cursor P1 so that  it points to the smallest entry that
is greater than or equal to the key value. If there are no records
greater than or equal to the key and P2 is not zero, then jump to P2.</p>

<p>See also: Found, NotFound, Distinct, SeekLt, SeekGt, SeekLe</td></tr><tr><td valign="top" align="center"><a name="SeekGt"></a><p>SeekGt</p><td><p>If cursor P1 refers to an SQL table (B-Tree that uses integer keys),
use the value in register P3 as a key. If cursor P1 refers
to an SQL index, then P3 is the first in an array of P4 registers
that are used as an unpacked index key.</p>

<p>Reposition cursor P1 so that  it points to the smallest entry that
is greater than the key value. If there are no records greater than
the key and P2 is not zero, then jump to P2.</p>

<p>See also: Found, NotFound, Distinct, SeekLt, SeekGe, SeekLe</td></tr><tr><td valign="top" align="center"><a name="SeekLe"></a><p>SeekLe</p><td><p>If cursor P1 refers to an SQL table (B-Tree that uses integer keys),
use the value in register P3 as a key. If cursor P1 refers
to an SQL index, then P3 is the first in an array of P4 registers
that are used as an unpacked index key.</p>

<p>Reposition cursor P1 so that it points to the largest entry that
is less than or equal to the key value. If there are no records
less than or equal to the key and P2 is not zero, then jump to P2.</p>

<p>See also: Found, NotFound, Distinct, SeekGt, SeekGe, SeekLt</td></tr><tr><td valign="top" align="center"><a name="SeekLt"></a><p>SeekLt</p><td><p>If cursor P1 refers to an SQL table (B-Tree that uses integer keys),
use the value in register P3 as a key. If cursor P1 refers
to an SQL index, then P3 is the first in an array of P4 registers
that are used as an unpacked index key.</p>

<p>Reposition cursor P1 so that  it points to the largest entry that
is less than the key value. If there are no records less than
the key and P2 is not zero, then jump to P2.</p>

<p>See also: Found, NotFound, Distinct, SeekGt, SeekGe, SeekLe</td></tr><tr><td valign="top" align="center"><a name="Sequence"></a><p>Sequence</p><td><p>Find the next available sequence number for cursor P1.
Write the sequence number into register P2.
The sequence number on the cursor is incremented after this
instruction.</td></tr><tr><td valign="top" align="center"><a name="SetCookie"></a><p>SetCookie</p><td><p>Write the content of register P3 (interpreted as an integer)
into cookie number P2 of database P1.  P2==1 is the schema version.
P2==2 is the database format. P2==3 is the recommended pager cache
size, and so forth.  P1==0 is the main database file and P1==1 is the
database file used to store temporary tables.</p>

<p>A transaction must be started before executing this opcode.</td></tr><tr><td valign="top" align="center"><a name="ShiftLeft"></a><p>ShiftLeft</p><td><p>Shift the integer value in register P2 to the left by the
number of bits specified by the integer in regiser P1.
Store the result in register P3.
If either input is NULL, the result is NULL.</td></tr><tr><td valign="top" align="center"><a name="ShiftRight"></a><p>ShiftRight</p><td><p>Shift the integer value in register P2 to the right by the
number of bits specified by the integer in register P1.
Store the result in register P3.
If either input is NULL, the result is NULL.</td></tr><tr><td valign="top" align="center"><a name="Sort"></a><p>Sort</p><td><p>This opcode does exactly the same thing as OP_Rewind except that
it increments an undocumented global variable used for testing.</p>

<p>Sorting is accomplished by writing records into a sorting index,
then rewinding that index and playing it back from beginning to
end.  We use the OP_Sort opcode instead of OP_Rewind to do the
rewinding so that the global variable will be incremented and
regression tests can determine whether or not the optimizer is
correctly optimizing out sorts.</td></tr><tr><td valign="top" align="center"><a name="String"></a><p>String</p><td><p>The string value P4 of length P1 (bytes) is stored in register P2.</td></tr><tr><td valign="top" align="center"><a name="String8"></a><p>String8</p><td><p>P4 points to a nul terminated UTF-8 string. This opcode is transformed
into an OP_String before it is executed for the first time.</td></tr><tr><td valign="top" align="center"><a name="Subtract"></a><p>Subtract</p><td><p>Subtract the value in register P1 from the value in register P2
and store the result in register P3.
If either input is NULL, the result is NULL.</td></tr><tr><td valign="top" align="center"><a name="TableLock"></a><p>TableLock</p><td><p>Obtain a lock on a particular table. This instruction is only used when
the shared-cache feature is enabled.</p>

<p>P1 is the index of the database in sqlite3.aDb[] of the database
on which the lock is acquired.  A readlock is obtained if P3==0 or
a write lock if P3==1.</p>

<p>P2 contains the root-page of the table to lock.</p>

<p>P4 contains a pointer to the name of the table being locked. This is only
used to generate an error message if the lock cannot be obtained.</td></tr><tr><td valign="top" align="center"><a name="ToBlob"></a><p>ToBlob</p><td><p>Force the value in register P1 to be a BLOB.
If the value is numeric, convert it to a string first.
Strings are simply reinterpreted as blobs with no change
to the underlying data.</p>

<p>A NULL value is not changed by this routine.  It remains NULL.</td></tr><tr><td valign="top" align="center"><a name="ToInt"></a><p>ToInt</p><td><p>Force the value in register P1 be an integer.  If
The value is currently a real number, drop its fractional part.
If the value is text or blob, try to convert it to an integer using the
equivalent of atoi() and store 0 if no such conversion is possible.</p>

<p>A NULL value is not changed by this routine.  It remains NULL.</td></tr><tr><td valign="top" align="center"><a name="ToNumeric"></a><p>ToNumeric</p><td><p>Force the value in register P1 to be numeric (either an
integer or a floating-point number.)
If the value is text or blob, try to convert it to an using the
equivalent of atoi() or atof() and store 0 if no such conversion
is possible.</p>

<p>A NULL value is not changed by this routine.  It remains NULL.</td></tr><tr><td valign="top" align="center"><a name="ToReal"></a><p>ToReal</p><td><p>Force the value in register P1 to be a floating point number.
If The value is currently an integer, convert it.
If the value is text or blob, try to convert it to an integer using the
equivalent of atoi() and store 0.0 if no such conversion is possible.</p>

<p>A NULL value is not changed by this routine.  It remains NULL.</td></tr><tr><td valign="top" align="center"><a name="ToText"></a><p>ToText</p><td><p>Force the value in register P1 to be text.
If the value is numeric, convert it to a string using the
equivalent of printf().  Blob values are unchanged and
are afterwards simply interpreted as text.</p>

<p>A NULL value is not changed by this routine.  It remains NULL.</td></tr><tr><td valign="top" align="center"><a name="Trace"></a><p>Trace</p><td><p>If tracing is enabled (by the sqlite3_trace()) interface, then
the UTF-8 string contained in P4 is emitted on the trace callback.</td></tr><tr><td valign="top" align="center"><a name="Transaction"></a><p>Transaction</p><td><p>Begin a transaction.  The transaction ends when a Commit or Rollback
opcode is encountered.  Depending on the ON CONFLICT setting, the
transaction might also be rolled back if an error is encountered.</p>

<p>P1 is the index of the database file on which the transaction is
started.  Index 0 is the main database file and index 1 is the
file used for temporary tables.  Indices of 2 or more are used for
attached databases.</p>

<p>If P2 is non-zero, then a write-transaction is started.  A RESERVED lock is
obtained on the database file when a write-transaction is started.  No
other process can start another write transaction while this transaction is
underway.  Starting a write transaction also creates a rollback journal. A
write transaction must be started before any changes can be made to the
database.  If P2 is 2 or greater then an EXCLUSIVE lock is also obtained
on the file.</p>

<p>If a write-transaction is started and the Vdbe.usesStmtJournal flag is
true (this flag is set if the Vdbe may modify more than one row and may
throw an ABORT exception), a statement transaction may also be opened.
More specifically, a statement transaction is opened iff the database
connection is currently not in autocommit mode, or if there are other
active statements. A statement transaction allows the affects of this
VDBE to be rolled back after an error without having to roll back the
entire transaction. If no error is encountered, the statement transaction
will automatically commit when the VDBE halts.</p>

<p>If P2 is zero, then a read-lock is obtained on the database file.</td></tr><tr><td valign="top" align="center"><a name="Vacuum"></a><p>Vacuum</p><td><p>Vacuum the entire database.  This opcode will cause other virtual
machines to be created and run.  It may not be called from within
a transaction.</td></tr><tr><td valign="top" align="center"><a name="Variable"></a><p>Variable</p><td><p>Transfer the values of bound parameters P1..P1+P3-1 into registers
P2..P2+P3-1.</p>

<p>If the parameter is named, then its name appears in P4 and P3==1.
The P4 value is used by sqlite3_bind_parameter_name().</td></tr><tr><td valign="top" align="center"><a name="VBegin"></a><p>VBegin</p><td><p>P4 may be a pointer to an sqlite3_vtab structure. If so, call the
xBegin method for that table.</p>

<p>Also, whether or not P4 is set, check that this is not being called from
within a callback to a virtual table xSync() method. If it is, the error
code will be set to SQLITE_LOCKED.</td></tr><tr><td valign="top" align="center"><a name="VColumn"></a><p>VColumn</p><td><p>Store the value of the P2-th column of
the row of the virtual-table that the
P1 cursor is pointing to into register P3.</td></tr><tr><td valign="top" align="center"><a name="VCreate"></a><p>VCreate</p><td><p>P4 is the name of a virtual table in database P1. Call the xCreate method
for that table.</td></tr><tr><td valign="top" align="center"><a name="VDestroy"></a><p>VDestroy</p><td><p>P4 is the name of a virtual table in database P1.  Call the xDestroy method
of that table.</td></tr><tr><td valign="top" align="center"><a name="VerifyCookie"></a><p>VerifyCookie</p><td><p>Check the value of global database parameter number 0 (the
schema version) and make sure it is equal to P2.
P1 is the database number which is 0 for the main database file
and 1 for the file holding temporary tables and some higher number
for auxiliary databases.</p>

<p>The cookie changes its value whenever the database schema changes.
This operation is used to detect when that the cookie has changed
and that the current process needs to reread the schema.</p>

<p>Either a transaction needs to have been started or an OP_Open needs
to be executed (to establish a read lock) before this opcode is
invoked.</td></tr><tr><td valign="top" align="center"><a name="VFilter"></a><p>VFilter</p><td><p>P1 is a cursor opened using VOpen.  P2 is an address to jump to if
the filtered result set is empty.</p>

<p>P4 is either NULL or a string that was generated by the xBestIndex
method of the module.  The interpretation of the P4 string is left
to the module implementation.</p>

<p>This opcode invokes the xFilter method on the virtual table specified
by P1.  The integer query plan parameter to xFilter is stored in register
P3. Register P3+1 stores the argc parameter to be passed to the
xFilter method. Registers P3+2..P3+1+argc are the argc
additional parameters which are passed to
xFilter as argv. Register P3+2 becomes argv[0] when passed to xFilter.</p>

<p>A jump is made to P2 if the result set after filtering would be empty.</td></tr><tr><td valign="top" align="center"><a name="VNext"></a><p>VNext</p><td><p>Advance virtual table P1 to the next row in its result set and
jump to instruction P2.  Or, if the virtual table has reached
the end of its result set, then fall through to the next instruction.</td></tr><tr><td valign="top" align="center"><a name="VOpen"></a><p>VOpen</p><td><p>P4 is a pointer to a virtual table object, an sqlite3_vtab structure.
P1 is a cursor number.  This opcode opens a cursor to the virtual
table and stores that cursor in P1.</td></tr><tr><td valign="top" align="center"><a name="VRename"></a><p>VRename</p><td><p>P4 is a pointer to a virtual table object, an sqlite3_vtab structure.
This opcode invokes the corresponding xRename method. The value
in register P1 is passed as the zName argument to the xRename method.</td></tr><tr><td valign="top" align="center"><a name="VUpdate"></a><p>VUpdate</p><td><p>P4 is a pointer to a virtual table object, an sqlite3_vtab structure.
This opcode invokes the corresponding xUpdate method. P2 values
are contiguous memory cells starting at P3 to pass to the xUpdate
invocation. The value in register (P3+P2-1) corresponds to the
p2th element of the argv array passed to xUpdate.</p>

<p>The xUpdate method will do a DELETE or an INSERT or both.
The argv[0] element (which corresponds to memory cell P3)
is the rowid of a row to delete.  If argv[0] is NULL then no
deletion occurs.  The argv[1] element is the rowid of the new
row.  This can be NULL to have the virtual table select the new
rowid for itself.  The subsequent elements in the array are
the values of columns in the new row.</p>

<p>If P2==1 then no insert is performed.  argv[0] is the rowid of
a row to delete.</p>

<p>P1 is a boolean flag. If it is set to true and the xUpdate call
is successful, then the value returned by sqlite3_last_insert_rowid()
is set to the value of the rowid for the row just inserted.</td></tr><tr><td valign="top" align="center"><a name="Yield"></a><p>Yield</p><td><p>Swap the program counter with the value in register P1.</td></tr>
</table></p>

