<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html>
        <head>
          <title>Scaladoc for scala.util.parsing.combinator.RegexParsers</title>
          <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
		      <script type="text/javascript" src="../../../../lib/jquery.js"></script>
          
		  <style type="text/css">
		    @import url(../../../../lib/template.css) screen;
		  </style>
		  <script type="text/javascript" src="../../../../lib/template.js"></script>
    
        </head>
        <body class="type">
      
      <p id="owner"><a href="../../../package.html">scala</a>.<a href="../../package.html">util</a>.<a href="../package.html">parsing</a>.<a href="package.html">combinator</a></p>

      <div id="definition">
        <img src="../../../../lib/trait_big.png" />
        <h1>RegexParsers</h1>
      </div>

      <h4 class="signature">
      <span class="kind">trait</span>
      <span class="symbol">
        <span class="name">RegexParsers</span><span class="result"> extends <a href="Parsers.html" class="extype" name="scala.util.parsing.combinator.Parsers">Parsers</a></span>
      </span>
      </h4>
      <div class="fullcomment" id="comment">
      
      
      
      
      <div class="block">
                known subclasses: <a href="testing/RegexTest$.html">RegexTest</a>, <a href="JavaTokenParsers.html">JavaTokenParsers</a>
              </div>
    </div>
      
      <div id="template">
      
        <div id="mbrsel">
              <div id="ancestors">
                <h3>Inherits</h3>
                <ol><li class="in" name="scala.util.parsing.combinator.Parsers">Parsers</li><li class="in" name="scala.AnyRef">AnyRef</li><li class="in" name="scala.Any">Any</li></ol>
              </div>
            </div>
        
        <div class="members" id="types">
              <h3>Type Members</h3>
              <ol><li name="scala.util.parsing.combinator.RegexParsers#Elem">
      <h4 class="signature">
      <span class="kind">type</span>
      <span class="symbol">
        <span class="name">Elem</span><span class="result"> = <span class="extype" name="scala.Char">Char</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">the type of input elements</p><div class="fullcomment">
      <div class="comment cmt"><p>the type of input elements</p></div>
      
      
      
      
    </div>
    </li><li name="scala.util.parsing.combinator.Parsers.Error">
      <h4 class="signature"><a href="RegexParsers$Error.html">
      <span class="kind">class</span>
      <span class="symbol">
        <span class="name">Error</span><span class="params">(<span name="msg">msg: String</span>, <span name="next">next: Reader[Elem]</span>)</span><span class="result"> extends NoSuccess with Product</span>
      </span>
      </a></h4>
      <p class="comment cmt">The fatal failure case of ParseResult: contains an error-message and the remaining input</p>
    </li><li name="scala.util.parsing.combinator.Parsers.Failure">
      <h4 class="signature"><a href="RegexParsers$Failure.html">
      <span class="kind">class</span>
      <span class="symbol">
        <span class="name">Failure</span><span class="params">(<span name="msg">msg: String</span>, <span name="next">next: Reader[Elem]</span>)</span><span class="result"> extends NoSuccess with Product</span>
      </span>
      </a></h4>
      <p class="comment cmt">The failure case of ParseResult: contains an error-message and the remaining input</p>
    </li><li name="scala.util.parsing.combinator.Parsers#Input">
      <h4 class="signature">
      <span class="kind">type</span>
      <span class="symbol">
        <span class="name">Input</span><span class="result"> = <a href="../input/Reader.html" class="extype" name="scala.util.parsing.input.Reader">Reader</a>[<span class="extype" name="scala.Char">Char</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">The parser input is an abstract reader of input elements</p><div class="fullcomment">
      <div class="comment cmt"><p>The parser input is an abstract reader of input elements</p></div>
      
      
      <div class="block">
            definition classes: <a href="Parsers.html">Parsers</a>
          </div>
      
    </div>
    </li><li name="scala.util.parsing.combinator.Parsers.NoSuccess">
      <h4 class="signature"><a href="RegexParsers$NoSuccess.html">
      <span class="kind">class</span>
      <span class="symbol">
        <span class="name">NoSuccess</span><span class="result"> extends ParseResult[Nothing]</span>
      </span>
      </a></h4>
      <p class="comment cmt">A common super-class for unsuccessful parse results</p>
    </li><li name="scala.util.parsing.combinator.Parsers.OnceParser">
      <h4 class="signature"><a href="RegexParsers$OnceParser.html">
      <span class="kind">trait</span>
      <span class="symbol">
        <span class="name">OnceParser</span><span class="tparams">[<span name="T">+T</span>]</span><span class="result"> extends Parser[T]</span>
      </span>
      </a></h4>
      <p class="comment cmt">A parser whose ~ combinator disallows back-tracking</p>
    </li><li name="scala.util.parsing.combinator.Parsers.ParseResult">
      <h4 class="signature"><a href="RegexParsers$ParseResult.html">
      <span class="kind">class</span>
      <span class="symbol">
        <span class="name">ParseResult</span><span class="tparams">[<span name="T">+T</span>]</span><span class="result"> extends AnyRef</span>
      </span>
      </a></h4>
      <p class="comment cmt">A base class for parser results</p>
    </li><li name="scala.util.parsing.combinator.Parsers.Parser">
      <h4 class="signature"><a href="RegexParsers$Parser.html">
      <span class="kind">class</span>
      <span class="symbol">
        <span class="name">Parser</span><span class="tparams">[<span name="T">+T</span>]</span><span class="result"> extends (Reader[Elem]) ⇒ ParseResult[T]</span>
      </span>
      </a></h4>
      <p class="comment cmt">The root class of parsers</p>
    </li><li name="scala.util.parsing.combinator.Parsers.Success">
      <h4 class="signature"><a href="RegexParsers$Success.html">
      <span class="kind">class</span>
      <span class="symbol">
        <span class="name">Success</span><span class="tparams">[<span name="T">+T</span>]</span><span class="params">(<span name="result">result: T</span>, <span name="next">next: Reader[Elem]</span>)</span><span class="result"> extends ParseResult[T] with Product</span>
      </span>
      </a></h4>
      <p class="comment cmt">The success case of ParseResult: contains the result and the remaining input</p>
    </li><li name="scala.util.parsing.combinator.Parsers.~">
      <h4 class="signature"><a href="RegexParsers$$tilde.html">
      <span class="kind">class</span>
      <span class="symbol">
        <span class="name">~</span><span class="tparams">[<span name="a">+a</span>, <span name="b">+b</span>]</span><span class="params">(<span name="_1">_1: a</span>, <span name="_2">_2: b</span>)</span><span class="result"> extends Product</span>
      </span>
      </a></h4>
      
    </li></ol>
            </div>
        
        <div class="members" id="values">
              <h3>Value Members</h3>
              <ol><li name="scala.util.parsing.combinator.Parsers.NoSuccess">
      <h4 class="signature"><a href="RegexParsers$NoSuccess$.html">
      <span class="kind">object</span>
      <span class="symbol">
        <span class="name">NoSuccess</span><span class="result"> extends AnyRef</span>
      </span>
      </a></h4>
      <p class="comment cmt">An extractor so NoSuccess(msg, next) can be used in matches</p>
    </li><li name="scala.util.parsing.combinator.Parsers#OnceParser">
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">OnceParser</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="f">f: (<a href="../input/Reader.html" class="extype" name="scala.util.parsing.input.Reader">Reader</a>[<span class="extype" name="scala.Char">Char</span>]) ⇒ <a href="Parsers$ParseResult.html" class="extype" name="scala.util.parsing.combinator.Parsers.ParseResult">ParseResult</a>[T]</span>)</span><span class="result">: <a href="Parsers$Parser.html" class="extype" name="scala.util.parsing.combinator.Parsers.Parser">Parser</a>[T] with <a href="Parsers$OnceParser.html" class="extype" name="scala.util.parsing.combinator.Parsers.OnceParser">OnceParser</a>[T]</span>
      </span>
      </h4>
      
    </li><li name="scala.util.parsing.combinator.Parsers#Parser">
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">Parser</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="f">f: (<a href="../input/Reader.html" class="extype" name="scala.util.parsing.input.Reader">Reader</a>[<span class="extype" name="scala.Char">Char</span>]) ⇒ <a href="Parsers$ParseResult.html" class="extype" name="scala.util.parsing.combinator.Parsers.ParseResult">ParseResult</a>[T]</span>)</span><span class="result">: <a href="Parsers$Parser.html" class="extype" name="scala.util.parsing.combinator.Parsers.Parser">Parser</a>[T]</span>
      </span>
      </h4>
      
    </li><li name="scala.util.parsing.combinator.Parsers#accept">
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">accept</span><span class="tparams">[<span name="U">U</span>]</span><span class="params">(<span name="expected">expected: <span class="extype" name="java.lang.String">String</span></span>, <span name="f">f: <a href="../../../PartialFunction.html" class="extype" name="scala.PartialFunction">PartialFunction</a>[<span class="extype" name="scala.Char">Char</span>, U]</span>)</span><span class="result">: <a href="Parsers$Parser.html" class="extype" name="scala.util.parsing.combinator.Parsers.Parser">Parser</a>[U]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">The parser that matches an element in the domain of the partial function <code>f'

If </code>f' is defined on the first element in the input, <code>f' is applied to it to produce
this parser's result</code></p><div class="fullcomment">
      <div class="comment cmt"><p>The parser that matches an element in the domain of the partial function <code>f'
<p>
If </code>f' is defined on the first element in the input, <code>f' is applied to it to produce
this parser's result.</p>
<p>
Example: The parser <code>accept("name", {case Identifier(n) => Name(n)})</code>
         accepts an <code>Identifier(n)</code> and returns a <code>Name(n)</code>.</p>
</code></p></div>
      <dl class="paramcmts block"><dt class="param">expected</dt><dd class="cmt"><p>a description of the kind of element this parser expects (for error messages)</p></dd><dt class="param">f</dt><dd class="cmt"><p>a partial function that determines when this parser is successful and what its output is</p></dd><dt>returns</dt><dd class="cmt"><p>A parser that succeeds if <code>f' is applicable to the first element of the input,
        applying </code>f' to it to produce the result.</p></dd></dl>
      
      <div class="block">
            definition classes: <a href="Parsers.html">Parsers</a>
          </div>
      
    </div>
    </li><li name="scala.util.parsing.combinator.Parsers#accept">
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">accept</span><span class="tparams">[<span name="ES">ES</span>]</span><span class="params">(<span name="es">es: ES</span>)</span><span class="params">(<span name="arg0">arg0: (ES) ⇒ <a href="../../../collection/immutable/List.html" class="extype" name="scala.collection.immutable.List">List</a>[<span class="extype" name="scala.Char">Char</span>]</span>)</span><span class="result">: <a href="Parsers$Parser.html" class="extype" name="scala.util.parsing.combinator.Parsers.Parser">Parser</a>[<a href="../../../collection/immutable/List.html" class="extype" name="scala.collection.immutable.List">List</a>[<span class="extype" name="scala.Char">Char</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">A parser that matches only the given list of element <code>es'

accept(es) succeeds if the input subsequently provides the elements in the list </code>es'</p><div class="fullcomment">
      <div class="comment cmt"><p>A parser that matches only the given list of element <code>es'

<p>accept(es) succeeds if the input subsequently provides the elements in the list </code>es'.</p>
</p></div>
      <dl class="paramcmts block"><dt class="param">es</dt><dd class="cmt"><p>the list of expected elements</p></dd><dt>returns</dt><dd class="cmt"><p>a Parser that recognizes a specified list of elements</p></dd></dl>
      
      <div class="block">
            definition classes: <a href="Parsers.html">Parsers</a>
          </div>
      
    </div>
    </li><li name="scala.util.parsing.combinator.Parsers#accept">
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">accept</span><span class="params">(<span name="e">e: <span class="extype" name="scala.Char">Char</span></span>)</span><span class="result">: <a href="Parsers$Parser.html" class="extype" name="scala.util.parsing.combinator.Parsers.Parser">Parser</a>[<span class="extype" name="scala.Char">Char</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">A parser that matches only the given element <code>e'

The method is implicit so that elements can automatically be lifted to their parsers</code></p><div class="fullcomment">
      <div class="comment cmt"><p>A parser that matches only the given element <code>e'
<p>
The method is implicit so that elements can automatically be lifted to their parsers.
For example, when parsing </code>Token's, Identifier("new") (which is a <code>Token') can be used directly,
instead of first creating a </code>Parser' using accept(Identifier("new")).</p>
</p></div>
      <dl class="paramcmts block"><dt class="param">e</dt><dd class="cmt"><p>the <code>Elem' that must be the next piece of input for the returned parser to succeed</code></p></dd><dt>returns</dt><dd class="cmt"><p>a <code>tParser' that succeeds if </code>e' is the next available input.</p></dd></dl>
      <div class="block">
            attributes: implicit 
          </div>
      <div class="block">
            definition classes: <a href="Parsers.html">Parsers</a>
          </div>
      
    </div>
    </li><li name="scala.util.parsing.combinator.Parsers#acceptIf">
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">acceptIf</span><span class="params">(<span name="p">p: (<span class="extype" name="scala.Char">Char</span>) ⇒ <span class="extype" name="scala.Boolean">Boolean</span></span>)</span><span class="params">(<span name="err">err: (<span class="extype" name="scala.Char">Char</span>) ⇒ <span class="extype" name="java.lang.String">String</span></span>)</span><span class="result">: <a href="Parsers$Parser.html" class="extype" name="scala.util.parsing.combinator.Parsers.Parser">Parser</a>[<span class="extype" name="scala.Char">Char</span>]</span>
      </span>
      </h4>
      
    </li><li name="scala.util.parsing.combinator.Parsers#acceptMatch">
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">acceptMatch</span><span class="tparams">[<span name="U">U</span>]</span><span class="params">(<span name="expected">expected: <span class="extype" name="java.lang.String">String</span></span>, <span name="f">f: <a href="../../../PartialFunction.html" class="extype" name="scala.PartialFunction">PartialFunction</a>[<span class="extype" name="scala.Char">Char</span>, U]</span>)</span><span class="result">: <a href="Parsers$Parser.html" class="extype" name="scala.util.parsing.combinator.Parsers.Parser">Parser</a>[U]</span>
      </span>
      </h4>
      
    </li><li name="scala.util.parsing.combinator.Parsers#acceptSeq">
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">acceptSeq</span><span class="tparams">[<span name="ES">ES</span>]</span><span class="params">(<span name="es">es: ES</span>)</span><span class="params">(<span name="arg0">arg0: (ES) ⇒ <a href="../../../collection/Iterable.html" class="extype" name="scala.collection.Iterable">Iterable</a>[<span class="extype" name="scala.Char">Char</span>]</span>)</span><span class="result">: <a href="Parsers$Parser.html" class="extype" name="scala.util.parsing.combinator.Parsers.Parser">Parser</a>[<a href="../../../collection/immutable/List.html" class="extype" name="scala.collection.immutable.List">List</a>[<span class="extype" name="scala.Char">Char</span>]]</span>
      </span>
      </h4>
      
    </li><li name="scala.util.parsing.combinator.Parsers#chainl1">
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">chainl1</span><span class="tparams">[<span name="T">T</span>, <span name="U">U</span>]</span><span class="params">(<span name="first">first: ⇒ <a href="Parsers$Parser.html" class="extype" name="scala.util.parsing.combinator.Parsers.Parser">Parser</a>[T]</span>, <span name="p">p: ⇒ <a href="Parsers$Parser.html" class="extype" name="scala.util.parsing.combinator.Parsers.Parser">Parser</a>[U]</span>, <span name="q">q: ⇒ <a href="Parsers$Parser.html" class="extype" name="scala.util.parsing.combinator.Parsers.Parser">Parser</a>[(T, U) ⇒ T]</span>)</span><span class="result">: <a href="Parsers$Parser.html" class="extype" name="scala.util.parsing.combinator.Parsers.Parser">Parser</a>[T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">A parser generator that, roughly, generalises the rep1sep generator so that <code>q', which parses the separator,
produces a left-associative function that combines the elements it separates</code></p><div class="fullcomment">
      <div class="comment cmt"><p>A parser generator that, roughly, generalises the rep1sep generator so that <code>q', which parses the separator,
produces a left-associative function that combines the elements it separates.
</code></p></div>
      <dl class="paramcmts block"><dt class="param">first</dt><dd class="cmt"><p>a parser that parses the first element</p></dd><dt class="param">p</dt><dd class="cmt"><p>a parser that parses the subsequent elements</p></dd><dt class="param">q</dt><dd class="cmt"><p>a parser that parses the token(s) separating the elements, yielding a left-associative function that
         combines two elements into one</p></dd></dl>
      
      <div class="block">
            definition classes: <a href="Parsers.html">Parsers</a>
          </div>
      
    </div>
    </li><li name="scala.util.parsing.combinator.Parsers#chainl1">
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">chainl1</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: ⇒ <a href="Parsers$Parser.html" class="extype" name="scala.util.parsing.combinator.Parsers.Parser">Parser</a>[T]</span>, <span name="q">q: ⇒ <a href="Parsers$Parser.html" class="extype" name="scala.util.parsing.combinator.Parsers.Parser">Parser</a>[(T, T) ⇒ T]</span>)</span><span class="result">: <a href="Parsers$Parser.html" class="extype" name="scala.util.parsing.combinator.Parsers.Parser">Parser</a>[T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">A parser generator that, roughly, generalises the rep1sep generator so that <code>q', which parses the separator,
produces a left-associative function that combines the elements it separates</code></p><div class="fullcomment">
      <div class="comment cmt"><p>A parser generator that, roughly, generalises the rep1sep generator so that <code>q', which parses the separator,
produces a left-associative function that combines the elements it separates.

<p> From: J. Fokker. Functional parsers. In J. Jeuring and E. Meijer, editors, Advanced Functional Programming, volume 925 of Lecture Notes in Computer Science, pages 1--23. Springer, 1995.</p>
</code></p></div>
      <dl class="paramcmts block"><dt class="param">p</dt><dd class="cmt"><p>a parser that parses the elements</p></dd><dt class="param">q</dt><dd class="cmt"><p>a parser that parses the token(s) separating the elements, yielding a left-associative function that
         combines two elements into one</p></dd></dl>
      
      <div class="block">
            definition classes: <a href="Parsers.html">Parsers</a>
          </div>
      
    </div>
    </li><li name="scala.util.parsing.combinator.Parsers#chainr1">
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">chainr1</span><span class="tparams">[<span name="T">T</span>, <span name="U">U</span>]</span><span class="params">(<span name="p">p: ⇒ <a href="Parsers$Parser.html" class="extype" name="scala.util.parsing.combinator.Parsers.Parser">Parser</a>[T]</span>, <span name="q">q: ⇒ <a href="Parsers$Parser.html" class="extype" name="scala.util.parsing.combinator.Parsers.Parser">Parser</a>[(T, U) ⇒ U]</span>, <span name="combine">combine: (T, U) ⇒ U</span>, <span name="first">first: U</span>)</span><span class="result">: <a href="Parsers$Parser.html" class="extype" name="scala.util.parsing.combinator.Parsers.Parser">Parser</a>[U]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">A parser generator that generalises the rep1sep generator so that <code>q', which parses the separator,
produces a right-associative function that combines the elements it separates</code></p><div class="fullcomment">
      <div class="comment cmt"><p>A parser generator that generalises the rep1sep generator so that <code>q', which parses the separator,
produces a right-associative function that combines the elements it separates. Additionally,
The right-most (last) element and the left-most combinating function have to be supplied.

rep1sep(p: Parser[T], q) corresponds to chainr1(p, q ^^ cons, cons, Nil) (where val cons = (x: T, y: List[T]) => x :: y)
</code></p></div>
      <dl class="paramcmts block"><dt class="param">p</dt><dd class="cmt"><p>a parser that parses the elements</p></dd><dt class="param">q</dt><dd class="cmt"><p>a parser that parses the token(s) separating the elements, yielding a right-associative function that
         combines two elements into one</p></dd><dt class="param">combine</dt><dd class="cmt"><p>the "last" (left-most) combination function to be applied</p></dd><dt class="param">first</dt><dd class="cmt"><p>the "first" (right-most) element to be combined</p></dd></dl>
      
      <div class="block">
            definition classes: <a href="Parsers.html">Parsers</a>
          </div>
      
    </div>
    </li><li name="scala.util.parsing.combinator.Parsers#commit">
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">commit</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: ⇒ <a href="Parsers$Parser.html" class="extype" name="scala.util.parsing.combinator.Parsers.Parser">Parser</a>[T]</span>)</span><span class="result">: <a href="Parsers$Parser.html" class="extype" name="scala.util.parsing.combinator.Parsers.Parser">Parser</a>[T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Wrap a parser so that its failures become errors (the | combinator will give up as soon as
 it encounters an error, on failure it simply tries the next alternative)</p><div class="fullcomment">
      <div class="comment cmt"><p>Wrap a parser so that its failures become errors (the | combinator will give up as soon as
 it encounters an error, on failure it simply tries the next alternative)</p></div>
      
      
      <div class="block">
            definition classes: <a href="Parsers.html">Parsers</a>
          </div>
      
    </div>
    </li><li name="scala.util.parsing.combinator.Parsers#elem">
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">elem</span><span class="params">(<span name="e">e: <span class="extype" name="scala.Char">Char</span></span>)</span><span class="result">: <a href="Parsers$Parser.html" class="extype" name="scala.util.parsing.combinator.Parsers.Parser">Parser</a>[<span class="extype" name="scala.Char">Char</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">A parser that matches only the given element <code>e'

elem(e) succeeds if the input starts with an element </code>e'</p><div class="fullcomment">
      <div class="comment cmt"><p>A parser that matches only the given element <code>e'

<p>elem(e) succeeds if the input starts with an element </code>e'</p>
</p></div>
      <dl class="paramcmts block"><dt class="param">e</dt><dd class="cmt"><p>the <code>Elem' that must be the next piece of input for the returned parser to succeed</code></p></dd><dt>returns</dt><dd class="cmt"><p>a <code>Parser' that succeeds if </code>e' is the next available input (and returns it).</p></dd></dl>
      
      <div class="block">
            definition classes: <a href="Parsers.html">Parsers</a>
          </div>
      
    </div>
    </li><li name="scala.util.parsing.combinator.Parsers#elem">
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">elem</span><span class="params">(<span name="kind">kind: <span class="extype" name="java.lang.String">String</span></span>, <span name="p">p: (<span class="extype" name="scala.Char">Char</span>) ⇒ <span class="extype" name="scala.Boolean">Boolean</span></span>)</span><span class="result">: <a href="Parsers$Parser.html" class="extype" name="scala.util.parsing.combinator.Parsers.Parser">Parser</a>[<span class="extype" name="scala.Char">Char</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">A parser matching input elements that satisfy a given predicate</p><div class="fullcomment">
      <div class="comment cmt"><p>A parser matching input elements that satisfy a given predicate</p><p><p>elem(kind, p) succeeds if the input starts with an element <code>e' for which p(e) is true.</p>
</code></p></div>
      <dl class="paramcmts block"><dt class="param">kind</dt><dd class="cmt"><p>The element kind, used for error messages</p></dd><dt class="param">p</dt><dd class="cmt"><p>A predicate that determines which elements match.
@return</p></dd></dl>
      
      <div class="block">
            definition classes: <a href="Parsers.html">Parsers</a>
          </div>
      
    </div>
    </li><li name="scala.AnyRef#equals">
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">equals</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">This method is used to compare the receiver object (<code>this</code>)
with the argument object (<code>arg0</code>) for equivalence</p><div class="fullcomment">
      <div class="comment cmt"><p>This method is used to compare the receiver object (<code>this</code>)
with the argument object (<code>arg0</code>) for equivalence.</p><p><p>
The default implementations of this method is an <a
href="http://en.wikipedia.org/wiki/Equivalence_relation">equivalence
relation</a>:
  <ul>
 <li>It is reflexive: for any instance <code>x</code> of type <code>Any</code>,
 <code>x.equals(x)</code> should return <code>true</code>.</li>
 <li>It is symmetric: for any instances <code>x</code> and <code>y</code> of type
 <code>Any</code>, <code>x.equals(y)</code> should return <code>true</code> if and only
 if <code>y.equals(x)</code> returns <code>true</code>.</li>
 <li>It is transitive: for any instances
 <code>x</code>, <code>y</code>, and <code>z</code> of type <code>AnyRef</code>
 if <code>x.equals(y)</code> returns <code>true</code> and
 <code>y.equals(z)</code> returns
 <code>true</code>, then <code>x.equals(z)</code> should return <code>true</code>.</li>
</ul>
</p></p><p><p>
If you override this method, you should verify that
your implementation remains an equivalence relation.
Additionally, when overriding this method it is often necessary to
override <code>hashCode</code> to ensure that objects that are
"equal" (<code>o1.equals(o2)</code> returns <code>true</code>)
hash to the same <a href="Int.html"><code>Int</code></a>
(<code>o1.hashCode.equals(o2.hashCode)</code>).
</p></div>
      <dl class="paramcmts block"><dt class="param">arg0</dt><dd class="cmt"><p>the object to compare against this object for equality.</p></dd><dt>returns</dt><dd class="cmt"><p><code>true</code> if the receiver object is equivalent to the argument; <code>false</code> otherwise.
</p></p></dd></dl>
      
      <div class="block">
            definition classes: AnyRef ⇐ Any
          </div>
      
    </div>
    </li><li name="scala.util.parsing.combinator.Parsers#err">
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">err</span><span class="params">(<span name="msg">msg: <span class="extype" name="java.lang.String">String</span></span>)</span><span class="result">: <a href="Parsers$Parser.html" class="extype" name="scala.util.parsing.combinator.Parsers.Parser">Parser</a>[<span class="extype" name="scala.Nothing">Nothing</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">A parser that results in an error
</p><div class="fullcomment">
      <div class="comment cmt"><p>A parser that results in an error
</p></div>
      <dl class="paramcmts block"><dt class="param">msg</dt><dd class="cmt"><p>The error message describing the failure.</p></dd><dt>returns</dt><dd class="cmt"><p>A parser that always fails with the specified error message.</p></dd></dl>
      
      <div class="block">
            definition classes: <a href="Parsers.html">Parsers</a>
          </div>
      
    </div>
    </li><li name="scala.util.parsing.combinator.Parsers#failure">
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">failure</span><span class="params">(<span name="msg">msg: <span class="extype" name="java.lang.String">String</span></span>)</span><span class="result">: <a href="Parsers$Parser.html" class="extype" name="scala.util.parsing.combinator.Parsers.Parser">Parser</a>[<span class="extype" name="scala.Nothing">Nothing</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">A parser that always fails
</p><div class="fullcomment">
      <div class="comment cmt"><p>A parser that always fails
</p></div>
      <dl class="paramcmts block"><dt class="param">msg</dt><dd class="cmt"><p>The error message describing the failure.</p></dd><dt>returns</dt><dd class="cmt"><p>A parser that always fails with the specified error message.</p></dd></dl>
      
      <div class="block">
            definition classes: <a href="Parsers.html">Parsers</a>
          </div>
      
    </div>
    </li><li name="scala.util.parsing.combinator.Parsers#guard">
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">guard</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: ⇒ <a href="Parsers$Parser.html" class="extype" name="scala.util.parsing.combinator.Parsers.Parser">Parser</a>[T]</span>)</span><span class="result">: <a href="Parsers$Parser.html" class="extype" name="scala.util.parsing.combinator.Parsers.Parser">Parser</a>[T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">A parser generator for guard expressions</p><div class="fullcomment">
      <div class="comment cmt"><p>A parser generator for guard expressions. The resulting parser will fail or succeed
just like the one given as parameter but it will not consume any input.
</p></div>
      <dl class="paramcmts block"><dt class="param">p</dt><dd class="cmt"><p>a <code>Parser' that is to be applied to the input</code></p></dd><dt>returns</dt><dd class="cmt"><p>A parser that returns success if and only if 'p' succeeds but never consumes any input</p></dd></dl>
      
      <div class="block">
            definition classes: <a href="Parsers.html">Parsers</a>
          </div>
      
    </div>
    </li><li name="scala.AnyRef#hashCode">
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">hashCode</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns a hash code value for the object</p><div class="fullcomment">
      <div class="comment cmt"><p>Returns a hash code value for the object.</p><p><p>
The default hashing algorithm is platform dependent.</p><p>Note that it is allowed for two objects to have identical hash
codes (<code>o1.hashCode.equals(o2.hashCode)</code>) yet not be
equal (<code>o1.equals(o2)</code> returns <code>false</code>).  A
degenerate implementation could always return <code>0</code>.
However, it is required that if two objects are equal
(<code>o1.equals(o2)</code> returns <code>true</code>) that they
have identical hash codes
(<code>o1.hashCode.equals(o2.hashCode)</code>).  Therefore, when
overriding this method, be sure to verify that the behavior is
consistent with the <code>equals</code> method.
</p></p><p><p></p></div>
      
      
      <div class="block">
            definition classes: AnyRef ⇐ Any
          </div>
      
    </div>
    </li><li name="scala.util.parsing.combinator.Parsers#lastNoSuccess">
      <h4 class="signature">
      <span class="kind">var</span>
      <span class="symbol">
        <span class="name">lastNoSuccess</span><span class="result">: <a href="Parsers$NoSuccess.html" class="extype" name="scala.util.parsing.combinator.Parsers.NoSuccess">NoSuccess</a></span>
      </span>
      </h4>
      
    </li><li name="scala.util.parsing.combinator.RegexParsers#literal">
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">literal</span><span class="params">(<span name="s">s: <span class="extype" name="java.lang.String">String</span></span>)</span><span class="result">: <a href="Parsers$Parser.html" class="extype" name="scala.util.parsing.combinator.Parsers.Parser">Parser</a>[<span class="extype" name="java.lang.String">String</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">A parser that matches a literal string</p><div class="fullcomment">
      <div class="comment cmt"><p>A parser that matches a literal string</p></div>
      
      <div class="block">
            attributes: implicit 
          </div>
      
      
    </div>
    </li><li name="scala.util.parsing.combinator.Parsers#log">
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">log</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: ⇒ <a href="Parsers$Parser.html" class="extype" name="scala.util.parsing.combinator.Parsers.Parser">Parser</a>[T]</span>)</span><span class="params">(<span name="name">name: <span class="extype" name="java.lang.String">String</span></span>)</span><span class="result">: <a href="Parsers$Parser.html" class="extype" name="scala.util.parsing.combinator.Parsers.Parser">Parser</a>[T]</span>
      </span>
      </h4>
      
    </li><li name="scala.util.parsing.combinator.Parsers#mkList">
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">mkList</span><span class="tparams">[<span name="T">T</span>]</span><span class="result">: (<a href="Parsers$$tilde.html" class="extype" name="scala.util.parsing.combinator.Parsers.~">~</a>[T, <a href="../../../collection/immutable/List.html" class="extype" name="scala.collection.immutable.List">List</a>[T]]) ⇒ <a href="../../../collection/immutable/List.html" class="extype" name="scala.collection.immutable.List">List</a>[T]</span>
      </span>
      </h4>
      
    </li><li name="scala.util.parsing.combinator.Parsers#not">
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">not</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: ⇒ <a href="Parsers$Parser.html" class="extype" name="scala.util.parsing.combinator.Parsers.Parser">Parser</a>[T]</span>)</span><span class="result">: <a href="Parsers$Parser.html" class="extype" name="scala.util.parsing.combinator.Parsers.Parser">Parser</a>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Wrap a parser so that its failures&errors become success and vice versa -- it never consumes any input</p><div class="fullcomment">
      <div class="comment cmt"><p>Wrap a parser so that its failures&errors become success and vice versa -- it never consumes any input</p></div>
      
      
      <div class="block">
            definition classes: <a href="Parsers.html">Parsers</a>
          </div>
      
    </div>
    </li><li name="scala.util.parsing.combinator.Parsers#opt">
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">opt</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: ⇒ <a href="Parsers$Parser.html" class="extype" name="scala.util.parsing.combinator.Parsers.Parser">Parser</a>[T]</span>)</span><span class="result">: <a href="Parsers$Parser.html" class="extype" name="scala.util.parsing.combinator.Parsers.Parser">Parser</a>[<a href="../../../Option.html" class="extype" name="scala.Option">Option</a>[T]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">A parser generator for optional sub-phrases</p><div class="fullcomment">
      <div class="comment cmt"><p>A parser generator for optional sub-phrases.</p><p> <p>opt(p) is a parser that returns <code>Some(x)' if </code>p' returns <code>x' and </code>None' if <code>p' fails</p>
</code></p></div>
      <dl class="paramcmts block"><dt class="param">p</dt><dd class="cmt"><p>A <code>Parser' that is tried on the input</code></p></dd><dt>returns</dt><dd class="cmt"><p>a <code>Parser' that always succeeds: either with the result provided by </code>p' or
        with the empty result</p></dd></dl>
      
      <div class="block">
            definition classes: <a href="Parsers.html">Parsers</a>
          </div>
      
    </div>
    </li><li name="scala.util.parsing.combinator.RegexParsers#parse">
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">parse</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: <a href="Parsers$Parser.html" class="extype" name="scala.util.parsing.combinator.Parsers.Parser">Parser</a>[T]</span>, <span name="in">in: <span class="extype" name="java.io.Reader">Reader</span></span>)</span><span class="result">: <a href="Parsers$ParseResult.html" class="extype" name="scala.util.parsing.combinator.Parsers.ParseResult">ParseResult</a>[T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parse some prefix of reader <code>in' with parser </code>p'</p><div class="fullcomment">
      <div class="comment cmt"><p>Parse some prefix of reader <code>in' with parser </code>p'</p></div>
      
      
      
      
    </div>
    </li><li name="scala.util.parsing.combinator.RegexParsers#parse">
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">parse</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: <a href="Parsers$Parser.html" class="extype" name="scala.util.parsing.combinator.Parsers.Parser">Parser</a>[T]</span>, <span name="in">in: <span class="extype" name="java.lang.CharSequence">CharSequence</span></span>)</span><span class="result">: <a href="Parsers$ParseResult.html" class="extype" name="scala.util.parsing.combinator.Parsers.ParseResult">ParseResult</a>[T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parse some prefix of character sequence <code>in' with parser </code>p'</p><div class="fullcomment">
      <div class="comment cmt"><p>Parse some prefix of character sequence <code>in' with parser </code>p'</p></div>
      
      
      
      
    </div>
    </li><li name="scala.util.parsing.combinator.RegexParsers#parse">
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">parse</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: <a href="Parsers$Parser.html" class="extype" name="scala.util.parsing.combinator.Parsers.Parser">Parser</a>[T]</span>, <span name="in">in: <a href="../input/Reader.html" class="extype" name="scala.util.parsing.input.Reader">Reader</a>[<span class="extype" name="scala.Char">Char</span>]</span>)</span><span class="result">: <a href="Parsers$ParseResult.html" class="extype" name="scala.util.parsing.combinator.Parsers.ParseResult">ParseResult</a>[T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parse some prefix of reader <code>in' with parser </code>p'</p><div class="fullcomment">
      <div class="comment cmt"><p>Parse some prefix of reader <code>in' with parser </code>p'</p></div>
      
      
      
      
    </div>
    </li><li name="scala.util.parsing.combinator.RegexParsers#parseAll">
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">parseAll</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: <a href="Parsers$Parser.html" class="extype" name="scala.util.parsing.combinator.Parsers.Parser">Parser</a>[T]</span>, <span name="in">in: <span class="extype" name="java.lang.CharSequence">CharSequence</span></span>)</span><span class="result">: <a href="Parsers$ParseResult.html" class="extype" name="scala.util.parsing.combinator.Parsers.ParseResult">ParseResult</a>[T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parse all of character sequence <code>in' with parser </code>p'</p><div class="fullcomment">
      <div class="comment cmt"><p>Parse all of character sequence <code>in' with parser </code>p'</p></div>
      
      
      
      
    </div>
    </li><li name="scala.util.parsing.combinator.RegexParsers#parseAll">
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">parseAll</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: <a href="Parsers$Parser.html" class="extype" name="scala.util.parsing.combinator.Parsers.Parser">Parser</a>[T]</span>, <span name="in">in: <span class="extype" name="java.io.Reader">Reader</span></span>)</span><span class="result">: <a href="Parsers$ParseResult.html" class="extype" name="scala.util.parsing.combinator.Parsers.ParseResult">ParseResult</a>[T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parse all of reader <code>in' with parser </code>p'</p><div class="fullcomment">
      <div class="comment cmt"><p>Parse all of reader <code>in' with parser </code>p'</p></div>
      
      
      
      
    </div>
    </li><li name="scala.util.parsing.combinator.RegexParsers#parseAll">
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">parseAll</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: <a href="Parsers$Parser.html" class="extype" name="scala.util.parsing.combinator.Parsers.Parser">Parser</a>[T]</span>, <span name="in">in: <a href="../input/Reader.html" class="extype" name="scala.util.parsing.input.Reader">Reader</a>[<span class="extype" name="scala.Char">Char</span>]</span>)</span><span class="result">: <a href="Parsers$ParseResult.html" class="extype" name="scala.util.parsing.combinator.Parsers.ParseResult">ParseResult</a>[T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parse all of reader <code>in' with parser </code>p'</p><div class="fullcomment">
      <div class="comment cmt"><p>Parse all of reader <code>in' with parser </code>p'</p></div>
      
      
      
      
    </div>
    </li><li name="scala.util.parsing.combinator.RegexParsers#phrase">
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">phrase</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: <a href="Parsers$Parser.html" class="extype" name="scala.util.parsing.combinator.Parsers.Parser">Parser</a>[T]</span>)</span><span class="result">: <a href="Parsers$Parser.html" class="extype" name="scala.util.parsing.combinator.Parsers.Parser">Parser</a>[T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">
   A parser generator delimiting whole phrases (i</p><div class="fullcomment">
      <div class="comment cmt"><p><p>
   A parser generator delimiting whole phrases (i.e. programs).
 </p>
 <p>
   <code>phrase(p)</code> succeeds if <code>p</code> succeeds and
   no input is left over after <code>p</code>.
 </p>
</p></div>
      <dl class="paramcmts block"><dt class="param">p</dt><dd class="cmt"><p>the parser that must consume all input for the resulting parser
          to succeed.</p></dd><dt>returns</dt><dd class="cmt"><p>a parser that has the same result as <code>p', but that only succeeds
          if <code>p</code> consumed all the input.</code></p></dd></dl>
      
      
      
    </div>
    </li><li name="scala.util.parsing.combinator.Parsers#positioned">
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">positioned</span><span class="tparams">[<span name="T">T &lt;: <a href="../input/Positional.html" class="extype" name="scala.util.parsing.input.Positional">Positional</a></span>]</span><span class="params">(<span name="p">p: ⇒ <a href="Parsers$Parser.html" class="extype" name="scala.util.parsing.combinator.Parsers.Parser">Parser</a>[T]</span>)</span><span class="result">: <a href="Parsers$Parser.html" class="extype" name="scala.util.parsing.combinator.Parsers.Parser">Parser</a>[T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt"><code>positioned' decorates a parser's result with the start position of the input it consumed</code></p><div class="fullcomment">
      <div class="comment cmt"><p><code>positioned' decorates a parser's result with the start position of the input it consumed.
</code></p></div>
      <dl class="paramcmts block"><dt class="param">p</dt><dd class="cmt"><p>a <code>Parser' whose result conforms to </code>Positional'.</p></dd><dt>returns</dt><dd class="cmt"><p>A parser that has the same behaviour as <code>p', but which marks its result with the
        start position of the input it consumed, if it didn't already have a position.</code></p></dd></dl>
      
      <div class="block">
            definition classes: <a href="Parsers.html">Parsers</a>
          </div>
      
    </div>
    </li><li name="scala.util.parsing.combinator.RegexParsers#regex">
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">regex</span><span class="params">(<span name="r">r: <a href="../../matching/Regex.html" class="extype" name="scala.util.matching.Regex">Regex</a></span>)</span><span class="result">: <a href="Parsers$Parser.html" class="extype" name="scala.util.parsing.combinator.Parsers.Parser">Parser</a>[<span class="extype" name="java.lang.String">String</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">A parser that matches a regex string</p><div class="fullcomment">
      <div class="comment cmt"><p>A parser that matches a regex string</p></div>
      
      <div class="block">
            attributes: implicit 
          </div>
      
      
    </div>
    </li><li name="scala.util.parsing.combinator.Parsers#rep">
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">rep</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: ⇒ <a href="Parsers$Parser.html" class="extype" name="scala.util.parsing.combinator.Parsers.Parser">Parser</a>[T]</span>)</span><span class="result">: <a href="Parsers$Parser.html" class="extype" name="scala.util.parsing.combinator.Parsers.Parser">Parser</a>[<a href="../../../collection/immutable/List.html" class="extype" name="scala.collection.immutable.List">List</a>[T]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">A parser generator for repetitions</p><div class="fullcomment">
      <div class="comment cmt"><p>A parser generator for repetitions.</p><p><p> rep(p)   repeatedly uses <code>p' to parse the input until </code>p' fails (the result is a List
 of the consecutive results of <code>p') </p>
</code></p></div>
      <dl class="paramcmts block"><dt class="param">p</dt><dd class="cmt"><p>a <code>Parser' that is to be applied successively to the input</code></p></dd><dt>returns</dt><dd class="cmt"><p>A parser that returns a list of results produced by repeatedly applying <code>p' to the input.</code></p></dd></dl>
      
      <div class="block">
            definition classes: <a href="Parsers.html">Parsers</a>
          </div>
      
    </div>
    </li><li name="scala.util.parsing.combinator.Parsers#rep1">
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">rep1</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="first">first: ⇒ <a href="Parsers$Parser.html" class="extype" name="scala.util.parsing.combinator.Parsers.Parser">Parser</a>[T]</span>, <span name="p">p: ⇒ <a href="Parsers$Parser.html" class="extype" name="scala.util.parsing.combinator.Parsers.Parser">Parser</a>[T]</span>)</span><span class="result">: <a href="Parsers$Parser.html" class="extype" name="scala.util.parsing.combinator.Parsers.Parser">Parser</a>[<a href="../../../collection/immutable/List.html" class="extype" name="scala.collection.immutable.List">List</a>[T]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">A parser generator for non-empty repetitions</p><div class="fullcomment">
      <div class="comment cmt"><p>A parser generator for non-empty repetitions.</p><p><p> rep1(f, p) first uses <code>f' (which must succeed) and then repeatedly uses </code>p' to
    parse the input until <code>p' fails
    (the result is a </code>List' of the consecutive results of <code>f' and </code>p')</p>
</p></div>
      <dl class="paramcmts block"><dt class="param">first</dt><dd class="cmt"><p>a <code>Parser' that parses the first piece of input</code></p></dd><dt class="param">p</dt><dd class="cmt"><p>a <code>Parser' that is to be applied successively to the rest of the input (if any)</code></p></dd><dt>returns</dt><dd class="cmt"><p>A parser that returns a list of results produced by first applying <code>f' and then
        repeatedly </code>p' to the input (it only succeeds if <code>f' matches).</code></p></dd></dl>
      
      <div class="block">
            definition classes: <a href="Parsers.html">Parsers</a>
          </div>
      
    </div>
    </li><li name="scala.util.parsing.combinator.Parsers#rep1">
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">rep1</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: ⇒ <a href="Parsers$Parser.html" class="extype" name="scala.util.parsing.combinator.Parsers.Parser">Parser</a>[T]</span>)</span><span class="result">: <a href="Parsers$Parser.html" class="extype" name="scala.util.parsing.combinator.Parsers.Parser">Parser</a>[<a href="../../../collection/immutable/List.html" class="extype" name="scala.collection.immutable.List">List</a>[T]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">A parser generator for non-empty repetitions</p><div class="fullcomment">
      <div class="comment cmt"><p>A parser generator for non-empty repetitions.</p><p><p> rep1(p) repeatedly uses <code>p' to parse the input until </code>p' fails -- <code>p' must succeed at least
            once (the result is a </code>List' of the consecutive results of <code>p')</p>
</code></p></div>
      <dl class="paramcmts block"><dt class="param">p</dt><dd class="cmt"><p>a <code>Parser' that is to be applied successively to the input</code></p></dd><dt>returns</dt><dd class="cmt"><p>A parser that returns a list of results produced by repeatedly applying <code>p' to the input
       (and that only succeeds if </code>p' matches at least once).</p></dd></dl>
      
      <div class="block">
            definition classes: <a href="Parsers.html">Parsers</a>
          </div>
      
    </div>
    </li><li name="scala.util.parsing.combinator.Parsers#rep1sep">
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">rep1sep</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: ⇒ <a href="Parsers$Parser.html" class="extype" name="scala.util.parsing.combinator.Parsers.Parser">Parser</a>[T]</span>, <span name="q">q: ⇒ <a href="Parsers$Parser.html" class="extype" name="scala.util.parsing.combinator.Parsers.Parser">Parser</a>[<span class="extype" name="scala.Any">Any</span>]</span>)</span><span class="result">: <a href="Parsers$Parser.html" class="extype" name="scala.util.parsing.combinator.Parsers.Parser">Parser</a>[<a href="../../../collection/immutable/List.html" class="extype" name="scala.collection.immutable.List">List</a>[T]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">A parser generator for non-empty repetitions</p><div class="fullcomment">
      <div class="comment cmt"><p>A parser generator for non-empty repetitions.</p><p> <p>rep1sep(p, q) repeatedly applies <code>p' interleaved with </code>q' to parse the input, until <code>p' fails.
               The parser </code>p' must succeed at least once.</p>
</p></div>
      <dl class="paramcmts block"><dt class="param">p</dt><dd class="cmt"><p>a <code>Parser' that is to be applied successively to the input</code></p></dd><dt class="param">q</dt><dd class="cmt"><p>a <code>Parser' that parses the elements that separate the elements parsed by </code>p'
         (interleaved with <code>q')</code></p></dd><dt>returns</dt><dd class="cmt"><p>A parser that returns a list of results produced by repeatedly applying <code>p' to the input
        (and that only succeeds if </code>p' matches at least once).
        The results of <code>p' are collected in a list. The results of </code>q' are discarded.</p></dd></dl>
      
      <div class="block">
            definition classes: <a href="Parsers.html">Parsers</a>
          </div>
      
    </div>
    </li><li name="scala.util.parsing.combinator.Parsers#repN">
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">repN</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="n">n: <span class="extype" name="scala.Int">Int</span></span>, <span name="p">p: ⇒ <a href="Parsers$Parser.html" class="extype" name="scala.util.parsing.combinator.Parsers.Parser">Parser</a>[T]</span>)</span><span class="result">: <a href="Parsers$Parser.html" class="extype" name="scala.util.parsing.combinator.Parsers.Parser">Parser</a>[<a href="../../../collection/immutable/List.html" class="extype" name="scala.collection.immutable.List">List</a>[T]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">A parser generator for a specified number of repetitions</p><div class="fullcomment">
      <div class="comment cmt"><p>A parser generator for a specified number of repetitions.</p><p><p> repN(n, p)  uses <code>p' exactly </code>n' time to parse the input
      (the result is a <code>List' of the </code>n' consecutive results of <code>p')</p>
</code></p></div>
      <dl class="paramcmts block"><dt class="param">n</dt><dd class="cmt"><p>the exact number of times <code>p' must succeed</code></p></dd><dt class="param">p</dt><dd class="cmt"><p>a <code>Parser' that is to be applied successively to the input</code></p></dd><dt>returns</dt><dd class="cmt"><p>A parser that returns a list of results produced by repeatedly applying <code>p' to the input
       (and that only succeeds if </code>p' matches exactly <code>n' times).</code></p></dd></dl>
      
      <div class="block">
            definition classes: <a href="Parsers.html">Parsers</a>
          </div>
      
    </div>
    </li><li name="scala.util.parsing.combinator.Parsers#repsep">
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">repsep</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: ⇒ <a href="Parsers$Parser.html" class="extype" name="scala.util.parsing.combinator.Parsers.Parser">Parser</a>[T]</span>, <span name="q">q: ⇒ <a href="Parsers$Parser.html" class="extype" name="scala.util.parsing.combinator.Parsers.Parser">Parser</a>[<span class="extype" name="scala.Any">Any</span>]</span>)</span><span class="result">: <a href="Parsers$Parser.html" class="extype" name="scala.util.parsing.combinator.Parsers.Parser">Parser</a>[<a href="../../../collection/immutable/List.html" class="extype" name="scala.collection.immutable.List">List</a>[T]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">A parser generator for interleaved repetitions</p><div class="fullcomment">
      <div class="comment cmt"><p>A parser generator for interleaved repetitions.</p><p><p> repsep(p, q)   repeatedly uses <code>p' interleaved with </code>q' to parse the input, until <code>p' fails.
 (The result is a </code>List' of the results of <code>p'.) </p>

<p>Example: <code>repsep(term, ",")</code> parses a comma-separated list of term's,
         yielding a list of these terms</p>
</code></p></div>
      <dl class="paramcmts block"><dt class="param">p</dt><dd class="cmt"><p>a <code>Parser' that is to be applied successively to the input</code></p></dd><dt class="param">q</dt><dd class="cmt"><p>a <code>Parser' that parses the elements that separate the elements parsed by </code>p'</p></dd><dt>returns</dt><dd class="cmt"><p>A parser that returns a list of results produced by repeatedly applying <code>p' (interleaved
        with </code>q') to the input.
        The results of <code>p' are collected in a list. The results of </code>q' are discarded.</p></dd></dl>
      
      <div class="block">
            definition classes: <a href="Parsers.html">Parsers</a>
          </div>
      
    </div>
    </li><li name="scala.util.parsing.combinator.RegexParsers#skipWhitespace">
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">skipWhitespace</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      
    </li><li name="scala.util.parsing.combinator.Parsers#success">
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">success</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="v">v: T</span>)</span><span class="result">: <a href="Parsers$Parser.html" class="extype" name="scala.util.parsing.combinator.Parsers.Parser">Parser</a>[T]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">A parser that always succeeds
</p><div class="fullcomment">
      <div class="comment cmt"><p>A parser that always succeeds
</p></div>
      <dl class="paramcmts block"><dt class="param">v</dt><dd class="cmt"><p>The result for the parser</p></dd><dt>returns</dt><dd class="cmt"><p>A parser that always succeeds, with the given result <code>v'</code></p></dd></dl>
      
      <div class="block">
            definition classes: <a href="Parsers.html">Parsers</a>
          </div>
      
    </div>
    </li><li name="scala.AnyRef#toString">
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">toString</span><span class="params">()</span><span class="result">: <span class="extype" name="java.lang.String">String</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns a string representation of the object</p><div class="fullcomment">
      <div class="comment cmt"><p>Returns a string representation of the object.
<p>
The default representation is platform dependent.
</p></div>
      
      
      <div class="block">
            definition classes: AnyRef ⇐ Any
          </div>
      
    </div>
    </li></ol>
            </div>
        
        
        
      </div>
      
    </body>
      </html>