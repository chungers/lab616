<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html>
        <head>
          <title>Scaladoc for scala.util.parsing.ast.Binders</title>
          <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
		      <script type="text/javascript" src="../../../../lib/jquery.js"></script>
          
		  <style type="text/css">
		    @import url(../../../../lib/template.css) screen;
		  </style>
		  <script type="text/javascript" src="../../../../lib/template.js"></script>
    
        </head>
        <body class="type">
      
      <p id="owner"><a href="../../../package.html">scala</a>.<a href="../../package.html">util</a>.<a href="../package.html">parsing</a>.<a href="package.html">ast</a></p>

      <div id="definition">
        <img src="../../../../lib/trait_big.png" />
        <h1>Binders</h1>
      </div>

      <h4 class="signature">
      <span class="kind">trait</span>
      <span class="symbol">
        <span class="name">Binders</span><span class="result"> extends <a href="AbstractSyntax.html" class="extype" name="scala.util.parsing.ast.AbstractSyntax">AbstractSyntax</a> with <a href="Mappable.html" class="extype" name="scala.util.parsing.ast.Mappable">Mappable</a></span>
      </span>
      </h4>
      <div class="fullcomment" id="comment">
      <div class="comment cmt"><p><p>
   This component provides functionality for enforcing variable binding
   during parse-time.
 </p>
 <p>
  When parsing simple languages, like Featherweight Scala, these parser
  combinators will fully enforce the binding discipline. When names are
  allowed to be left unqualified, these mechanisms would have to be
  complemented by an extra phase that resolves names that couldn't be
  resolved using the naive binding rules. (Maybe some machinery to
  model <code>implicit' binders (e.g., </code>this' and imported qualifiers)
  and selection on a binder will suffice?)
</p>
</p></div>
      
      
      
      
    </div>
      
      <div id="template">
      
        <div id="mbrsel">
              <div id="ancestors">
                <h3>Inherits</h3>
                <ol><li class="in" name="scala.util.parsing.ast.Mappable">Mappable</li><li class="in" name="scala.util.parsing.ast.AbstractSyntax">AbstractSyntax</li><li class="in" name="scala.AnyRef">AnyRef</li><li class="in" name="scala.Any">Any</li></ol>
              </div>
            </div>
        
        <div class="members" id="types">
              <h3>Type Members</h3>
              <ol><li name="scala.util.parsing.ast.Binders.BinderEnv">
      <h4 class="signature"><a href="Binders$BinderEnv.html">
      <span class="kind">class</span>
      <span class="symbol">
        <span class="name">BinderEnv</span><span class="result"> extends AnyRef</span>
      </span>
      </a></h4>
      <p class="comment cmt">An environment that maps a <code>NameElement' to the scope in which it is bound</code></p>
    </li><li name="scala.util.parsing.ast.Binders.BindingSensitive">
      <h4 class="signature"><a href="Binders$BindingSensitive.html">
      <span class="kind">trait</span>
      <span class="symbol">
        <span class="name">BindingSensitive</span><span class="result"> extends AnyRef</span>
      </span>
      </a></h4>
      
    </li><li name="scala.util.parsing.ast.Binders.BoundElement">
      <h4 class="signature"><a href="Binders$BoundElement.html">
      <span class="kind">class</span>
      <span class="symbol">
        <span class="name">BoundElement</span><span class="tparams">[<span name="boundElement">boundElement &lt;: NameElement</span>]</span><span class="params">(<span name="el">el: boundElement</span>, <span name="scope">scope: Scope[boundElement]</span>)</span><span class="result"> extends NameElement with Proxy with BindingSensitive with Product</span>
      </span>
      </a></h4>
      <p class="comment cmt">A <code>BoundElement' is bound in a certain scope </code>scope', which keeps track of the actual element that<code>el' stands for</code></p>
    </li><li name="scala.util.parsing.ast.AbstractSyntax.Element">
      <h4 class="signature"><a href="Binders$Element.html">
      <span class="kind">trait</span>
      <span class="symbol">
        <span class="name">Element</span><span class="result"> extends Positional</span>
      </span>
      </a></h4>
      <p class="comment cmt">The base class for elements of the abstract syntax tree</p>
    </li><li name="scala.util.parsing.ast.Mappable.Mappable">
      <h4 class="signature"><a href="Binders$Mappable.html">
      <span class="kind">trait</span>
      <span class="symbol">
        <span class="name">Mappable</span><span class="tparams">[<span name="T">T</span>]</span><span class="result"> extends AnyRef</span>
      </span>
      </a></h4>
      
    </li><li name="scala.util.parsing.ast.Mappable.Mapper">
      <h4 class="signature"><a href="Binders$Mapper.html">
      <span class="kind">trait</span>
      <span class="symbol">
        <span class="name">Mapper</span><span class="result"> extends AnyRef</span>
      </span>
      </a></h4>
      
    </li><li name="scala.util.parsing.ast.AbstractSyntax.NameElement">
      <h4 class="signature"><a href="Binders$NameElement.html">
      <span class="kind">trait</span>
      <span class="symbol">
        <span class="name">NameElement</span><span class="result"> extends Element</span>
      </span>
      </a></h4>
      <p class="comment cmt">The base class for elements in the AST that represent names {@see Binders}</p>
    </li><li name="scala.util.parsing.ast.Binders.ReturnAndDo">
      <h4 class="signature"><a href="Binders$ReturnAndDo.html">
      <span class="kind">trait</span>
      <span class="symbol">
        <span class="name">ReturnAndDo</span><span class="tparams">[<span name="T">T</span>]</span><span class="result"> extends AnyRef</span>
      </span>
      </a></h4>
      <p class="comment cmt">Returns a given result, but executes the supplied closure before returning</p>
    </li><li name="scala.util.parsing.ast.Binders.Scope">
      <h4 class="signature"><a href="Binders$Scope.html">
      <span class="kind">class</span>
      <span class="symbol">
        <span class="name">Scope</span><span class="tparams">[<span name="binderType">binderType &lt;: NameElement</span>]</span><span class="result"> extends Iterable[binderType]</span>
      </span>
      </a></h4>
      <p class="comment cmt">A <code>Scope' keeps track of one or more syntactic elements that represent bound names</code></p>
    </li><li name="scala.util.parsing.ast.Binders.UnboundElement">
      <h4 class="signature"><a href="Binders$UnboundElement.html">
      <span class="kind">class</span>
      <span class="symbol">
        <span class="name">UnboundElement</span><span class="tparams">[<span name="N">N &lt;: NameElement</span>]</span><span class="result"> extends NameElement</span>
      </span>
      </a></h4>
      <p class="comment cmt">A variable that escaped its scope (i</p>
    </li><li name="scala.util.parsing.ast.Binders.UnderBinder">
      <h4 class="signature"><a href="Binders$UnderBinder.html">
      <span class="kind">class</span>
      <span class="symbol">
        <span class="name">UnderBinder</span><span class="tparams">[<span name="binderType">binderType &lt;: NameElement</span>, <span name="elementT">elementT</span>]</span><span class="result"> extends Element with BindingSensitive</span>
      </span>
      </a></h4>
      <p class="comment cmt">Represents an element with variables that are bound in a certain scope</p>
    </li></ol>
            </div>
        
        <div class="members" id="values">
              <h3>Value Members</h3>
              <ol><li name="scala.util.parsing.ast.Binders.EmptyBinderEnv">
      <h4 class="signature"><a href="Binders$EmptyBinderEnv$.html">
      <span class="kind">object</span>
      <span class="symbol">
        <span class="name">EmptyBinderEnv</span><span class="result"> extends BinderEnv</span>
      </span>
      </a></h4>
      
    </li><li name="scala.util.parsing.ast.Mappable#ListIsMappable">
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">ListIsMappable</span><span class="tparams">[<span name="t">t</span>]</span><span class="params">(<span name="xs">xs: <a href="../../../collection/immutable/List.html" class="extype" name="scala.collection.immutable.List">List</a>[t]</span>)</span><span class="params">(<span name="arg0">arg0: (t) ⇒ <a href="Mappable$Mappable.html" class="extype" name="scala.util.parsing.ast.Mappable.Mappable">Mappable</a>[t]</span>)</span><span class="result">: <a href="Mappable$Mappable.html" class="extype" name="scala.util.parsing.ast.Mappable.Mappable">Mappable</a>[<a href="../../../collection/immutable/List.html" class="extype" name="scala.collection.immutable.List">List</a>[t]]</span>
      </span>
      </h4>
      
    </li><li name="scala.util.parsing.ast.Binders#NameElementIsMappable">
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">NameElementIsMappable</span><span class="params">(<span name="self">self: <a href="AbstractSyntax$NameElement.html" class="extype" name="scala.util.parsing.ast.AbstractSyntax.NameElement">NameElement</a></span>)</span><span class="result">: <a href="Mappable$Mappable.html" class="extype" name="scala.util.parsing.ast.Mappable.Mappable">Mappable</a>[<a href="AbstractSyntax$NameElement.html" class="extype" name="scala.util.parsing.ast.AbstractSyntax.NameElement">NameElement</a>]</span>
      </span>
      </h4>
      
    </li><li name="scala.util.parsing.ast.Mappable#OptionIsMappable">
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">OptionIsMappable</span><span class="tparams">[<span name="t">t</span>]</span><span class="params">(<span name="xs">xs: <a href="../../../Option.html" class="extype" name="scala.Option">Option</a>[t]</span>)</span><span class="params">(<span name="arg0">arg0: (t) ⇒ <a href="Mappable$Mappable.html" class="extype" name="scala.util.parsing.ast.Mappable.Mappable">Mappable</a>[t]</span>)</span><span class="result">: <a href="Mappable$Mappable.html" class="extype" name="scala.util.parsing.ast.Mappable.Mappable">Mappable</a>[<a href="../../../Option.html" class="extype" name="scala.Option">Option</a>[t]]</span>
      </span>
      </h4>
      
    </li><li name="scala.util.parsing.ast.Binders#ScopeIsMappable">
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">ScopeIsMappable</span><span class="tparams">[<span name="bt">bt &lt;: <a href="AbstractSyntax$NameElement.html" class="extype" name="scala.util.parsing.ast.AbstractSyntax.NameElement">NameElement</a></span>]</span><span class="params">(<span name="scope">scope: <a href="Binders$Scope.html" class="extype" name="scala.util.parsing.ast.Binders.Scope">Scope</a>[bt]</span>)</span><span class="params">(<span name="arg0">arg0: (bt) ⇒ <a href="Mappable$Mappable.html" class="extype" name="scala.util.parsing.ast.Mappable.Mappable">Mappable</a>[bt]</span>)</span><span class="result">: <a href="Mappable$Mappable.html" class="extype" name="scala.util.parsing.ast.Mappable.Mappable">Mappable</a>[<a href="Binders$Scope.html" class="extype" name="scala.util.parsing.ast.Binders.Scope">Scope</a>[bt]]</span>
      </span>
      </h4>
      
    </li><li name="scala.util.parsing.ast.Mappable#StringIsMappable">
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">StringIsMappable</span><span class="params">(<span name="s">s: <span class="extype" name="java.lang.String">String</span></span>)</span><span class="result">: <a href="Mappable$Mappable.html" class="extype" name="scala.util.parsing.ast.Mappable.Mappable">Mappable</a>[<span class="extype" name="java.lang.String">String</span>]</span>
      </span>
      </h4>
      
    </li><li name="scala.util.parsing.ast.Binders.UnderBinder">
      <h4 class="signature"><a href="Binders$UnderBinder$.html">
      <span class="kind">object</span>
      <span class="symbol">
        <span class="name">UnderBinder</span><span class="result"> extends AnyRef</span>
      </span>
      </a></h4>
      
    </li><li name="scala.util.parsing.ast.Binders#UnderBinderIsMappable">
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">UnderBinderIsMappable</span><span class="tparams">[<span name="bt">bt &lt;: <a href="AbstractSyntax$NameElement.html" class="extype" name="scala.util.parsing.ast.AbstractSyntax.NameElement">NameElement</a></span>, <span name="st">st</span>]</span><span class="params">(<span name="ub">ub: <a href="Binders$UnderBinder.html" class="extype" name="scala.util.parsing.ast.Binders.UnderBinder">UnderBinder</a>[bt, st]</span>)</span><span class="params">(<span name="arg0">arg0: (bt) ⇒ <a href="Mappable$Mappable.html" class="extype" name="scala.util.parsing.ast.Mappable.Mappable">Mappable</a>[bt]</span>, <span name="arg1">arg1: (st) ⇒ <a href="Mappable$Mappable.html" class="extype" name="scala.util.parsing.ast.Mappable.Mappable">Mappable</a>[st]</span>)</span><span class="result">: <a href="Mappable$Mappable.html" class="extype" name="scala.util.parsing.ast.Mappable.Mappable">Mappable</a>[<a href="Binders$UnderBinder.html" class="extype" name="scala.util.parsing.ast.Binders.UnderBinder">UnderBinder</a>[bt, st]]</span>
      </span>
      </h4>
      
    </li><li name="scala.util.parsing.ast.Binders#UserNameElementIsMappable">
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">UserNameElementIsMappable</span><span class="tparams">[<span name="t">t &lt;: <a href="AbstractSyntax$NameElement.html" class="extype" name="scala.util.parsing.ast.AbstractSyntax.NameElement">NameElement</a></span>]</span><span class="params">(<span name="self">self: t</span>)</span><span class="result">: <a href="Mappable$Mappable.html" class="extype" name="scala.util.parsing.ast.Mappable.Mappable">Mappable</a>[t]</span>
      </span>
      </h4>
      
    </li><li name="scala.AnyRef#equals">
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">equals</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">This method is used to compare the receiver object (<code>this</code>)
with the argument object (<code>arg0</code>) for equivalence</p><div class="fullcomment">
      <div class="comment cmt"><p>This method is used to compare the receiver object (<code>this</code>)
with the argument object (<code>arg0</code>) for equivalence.</p><p><p>
The default implementations of this method is an <a
href="http://en.wikipedia.org/wiki/Equivalence_relation">equivalence
relation</a>:
  <ul>
 <li>It is reflexive: for any instance <code>x</code> of type <code>Any</code>,
 <code>x.equals(x)</code> should return <code>true</code>.</li>
 <li>It is symmetric: for any instances <code>x</code> and <code>y</code> of type
 <code>Any</code>, <code>x.equals(y)</code> should return <code>true</code> if and only
 if <code>y.equals(x)</code> returns <code>true</code>.</li>
 <li>It is transitive: for any instances
 <code>x</code>, <code>y</code>, and <code>z</code> of type <code>AnyRef</code>
 if <code>x.equals(y)</code> returns <code>true</code> and
 <code>y.equals(z)</code> returns
 <code>true</code>, then <code>x.equals(z)</code> should return <code>true</code>.</li>
</ul>
</p></p><p><p>
If you override this method, you should verify that
your implementation remains an equivalence relation.
Additionally, when overriding this method it is often necessary to
override <code>hashCode</code> to ensure that objects that are
"equal" (<code>o1.equals(o2)</code> returns <code>true</code>)
hash to the same <a href="Int.html"><code>Int</code></a>
(<code>o1.hashCode.equals(o2.hashCode)</code>).
</p></div>
      <dl class="paramcmts block"><dt class="param">arg0</dt><dd class="cmt"><p>the object to compare against this object for equality.</p></dd><dt>returns</dt><dd class="cmt"><p><code>true</code> if the receiver object is equivalent to the argument; <code>false</code> otherwise.
</p></p></dd></dl>
      
      <div class="block">
            definition classes: AnyRef ⇐ Any
          </div>
      
    </div>
    </li><li name="scala.AnyRef#hashCode">
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">hashCode</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns a hash code value for the object</p><div class="fullcomment">
      <div class="comment cmt"><p>Returns a hash code value for the object.</p><p><p>
The default hashing algorithm is platform dependent.</p><p>Note that it is allowed for two objects to have identical hash
codes (<code>o1.hashCode.equals(o2.hashCode)</code>) yet not be
equal (<code>o1.equals(o2)</code> returns <code>false</code>).  A
degenerate implementation could always return <code>0</code>.
However, it is required that if two objects are equal
(<code>o1.equals(o2)</code> returns <code>true</code>) that they
have identical hash codes
(<code>o1.hashCode.equals(o2.hashCode)</code>).  Therefore, when
overriding this method, be sure to verify that the behavior is
consistent with the <code>equals</code> method.
</p></p><p><p></p></div>
      
      
      <div class="block">
            definition classes: AnyRef ⇐ Any
          </div>
      
    </div>
    </li><li name="scala.util.parsing.ast.Binders#return_">
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">return_</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="result">result: T</span>)</span><span class="result">: <a href="Binders$ReturnAndDo.html" class="extype" name="scala.util.parsing.ast.Binders.ReturnAndDo">ReturnAndDo</a>[T]</span>
      </span>
      </h4>
      
    </li><li name="scala.util.parsing.ast.Binders#sequence">
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">sequence</span><span class="tparams">[<span name="bt">bt &lt;: <a href="AbstractSyntax$NameElement.html" class="extype" name="scala.util.parsing.ast.AbstractSyntax.NameElement">NameElement</a></span>, <span name="st">st</span>]</span><span class="params">(<span name="orig">orig: <a href="../../../collection/immutable/List.html" class="extype" name="scala.collection.immutable.List">List</a>[<a href="Binders$UnderBinder.html" class="extype" name="scala.util.parsing.ast.Binders.UnderBinder">UnderBinder</a>[bt, st]]</span>)</span><span class="params">(<span name="arg0">arg0: (st) ⇒ <a href="Mappable$Mappable.html" class="extype" name="scala.util.parsing.ast.Mappable.Mappable">Mappable</a>[st]</span>)</span><span class="result">: <a href="Binders$UnderBinder.html" class="extype" name="scala.util.parsing.ast.Binders.UnderBinder">UnderBinder</a>[bt, <a href="../../../collection/immutable/List.html" class="extype" name="scala.collection.immutable.List">List</a>[st]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">If a list of <code>UnderBinder's all have the same scope, they can be turned in to an UnderBinder
containing a list of the elements in the original </code>UnderBinder'</p><div class="fullcomment">
      <div class="comment cmt"><p>If a list of <code>UnderBinder's all have the same scope, they can be turned in to an UnderBinder
containing a list of the elements in the original </code>UnderBinder'.</p><p>The name <code>sequence' comes from the fact that this method's type is equal to the type of monadic sequence.
</code></p></div>
      
      
      
      
    </div>
    </li><li name="scala.AnyRef#toString">
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">toString</span><span class="params">()</span><span class="result">: <span class="extype" name="java.lang.String">String</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns a string representation of the object</p><div class="fullcomment">
      <div class="comment cmt"><p>Returns a string representation of the object.
<p>
The default representation is platform dependent.
</p></div>
      
      
      <div class="block">
            definition classes: AnyRef ⇐ Any
          </div>
      
    </div>
    </li><li name="scala.util.parsing.ast.Binders#unsequence">
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">unsequence</span><span class="tparams">[<span name="bt">bt &lt;: <a href="AbstractSyntax$NameElement.html" class="extype" name="scala.util.parsing.ast.AbstractSyntax.NameElement">NameElement</a></span>, <span name="st">st</span>]</span><span class="params">(<span name="orig">orig: <a href="Binders$UnderBinder.html" class="extype" name="scala.util.parsing.ast.Binders.UnderBinder">UnderBinder</a>[bt, <a href="../../../collection/immutable/List.html" class="extype" name="scala.collection.immutable.List">List</a>[st]]</span>)</span><span class="params">(<span name="arg0">arg0: (st) ⇒ <a href="Mappable$Mappable.html" class="extype" name="scala.util.parsing.ast.Mappable.Mappable">Mappable</a>[st]</span>)</span><span class="result">: <a href="../../../collection/immutable/List.html" class="extype" name="scala.collection.immutable.List">List</a>[<a href="Binders$UnderBinder.html" class="extype" name="scala.util.parsing.ast.Binders.UnderBinder">UnderBinder</a>[bt, st]]</span>
      </span>
      </h4>
      
    </li></ol>
            </div>
        
        
        
      </div>
      
    </body>
      </html>