<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;6.&nbsp;EPL Reference: Operators</title><link rel="stylesheet" href="../shared/css/html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.65.1"><link rel="home" href="index.html" title="Esper - Event Stream and Complex Event Processing for Java"><link rel="up" href="index.html" title="Esper - Event Stream and Complex Event Processing for Java"><link rel="previous" href="event_patterns.html" title="Chapter&nbsp;5.&nbsp;EPL Reference: Patterns"><link rel="next" href="functionreference.html" title="Chapter&nbsp;7.&nbsp;EPL Reference: Functions"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter&nbsp;6.&nbsp;EPL Reference: Operators</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="event_patterns.html">Prev</a>&nbsp;</td><th width="60%" align="center">&nbsp;</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="functionreference.html">Next</a></td></tr></table><hr></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="epl-operator"></a>Chapter&nbsp;6.&nbsp;EPL Reference: Operators</h2></div></div><div></div></div><p>
			Esper arithmetic and logical operator precedence follows Java standard arithmetic and logical operator precedence.
		</p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="epl-operator-ref-arithmetic"></a>6.1.&nbsp;Arithmetic Operators</h2></div></div><div></div></div><a class="indexterm" name="d0e10974"></a><a class="indexterm" name="d0e10977"></a><p>
				The below table outlines the arithmetic operators available.
			</p><div class="table"><a name="epl-arith-operators"></a><p class="title"><b>Table&nbsp;6.1.&nbsp;Syntax and results of arithmetic operators</b></p><table summary="Syntax and results of arithmetic operators" border="1"><colgroup><col><col></colgroup><thead><tr><th>Operator</th><th>Description</th></tr></thead><tbody><tr><td>+, -</td><td><p>As unary operators they denote a positive or negative expression. As binary operators they add or subtract.</p></td></tr><tr><td>*, /</td><td><p>Multiplication and division are binary operators.</p></td></tr><tr><td>%</td><td><p>Modulo binary operator.</p></td></tr></tbody></table></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="epl-operator-ref-logical"></a>6.2.&nbsp;Logical And Comparsion Operators</h2></div></div><div></div></div><a class="indexterm" name="d0e11018"></a><a class="indexterm" name="d0e11021"></a><p>
				The below table outlines the logical and comparison operators available.
			</p><div class="table"><a name="epl-log-operators"></a><p class="title"><b>Table&nbsp;6.2.&nbsp;Syntax and results of logical and comparison operators</b></p><table summary="Syntax and results of logical and comparison operators" border="1"><colgroup><col><col></colgroup><thead><tr><th>Operator</th><th>Description</th></tr></thead><tbody><tr><td>NOT</td><td><p>Returns true if the following condition is false, returns false if it is true.</p></td></tr><tr><td>OR</td><td><p>Returns true if either component condition is true, returns false if both are false.</p></td></tr><tr><td>AND</td><td><p>Returns true if both component conditions are true, returns false if either is false.</p></td></tr><tr><td>=, !=, &lt;, &gt; &lt;=, &gt;=,</td><td><p>Comparison.</p></td></tr></tbody></table></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="epl-operator-ref-string"></a>6.3.&nbsp;Concatenation Operators</h2></div></div><div></div></div><a class="indexterm" name="d0e11068"></a><a class="indexterm" name="d0e11071"></a><p>
				The below table outlines the concatenation operators available.
			</p><div class="table"><a name="epl-concat-operators"></a><p class="title"><b>Table&nbsp;6.3.&nbsp;Syntax and results of concatenation operators</b></p><table summary="Syntax and results of concatenation operators" border="1"><colgroup><col><col></colgroup><thead><tr><th>Operator</th><th>Description</th></tr></thead><tbody><tr><td>||</td><td><p>Concatenates character strings</p></td></tr></tbody></table></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="epl-operator-ref-binary"></a>6.4.&nbsp;Binary Operators</h2></div></div><div></div></div><a class="indexterm" name="d0e11100"></a><a class="indexterm" name="d0e11103"></a><p>
				The below table outlines the binary operators available.
			</p><div class="table"><a name="epl-binary-operators"></a><p class="title"><b>Table&nbsp;6.4.&nbsp;Syntax and results of binary operators</b></p><table summary="Syntax and results of binary operators" border="1"><colgroup><col><col></colgroup><thead><tr><th>Operator</th><th>Description</th></tr></thead><tbody><tr><td>&amp;</td><td><p>Bitwise AND if both operands are numbers; conditional AND if both operands are boolean</p></td></tr><tr><td>|</td><td><p>Bitwise OR if both operands are numbers; conditional OR if both operands are boolean</p></td></tr><tr><td>^</td><td><p>Bitwise exclusive OR (XOR)</p></td></tr></tbody></table></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="epl-operator-ref-array"></a>6.5.&nbsp;Array Definition Operator</h2></div></div><div></div></div><a class="indexterm" name="d0e11144"></a><a class="indexterm" name="d0e11147"></a><p>
				The <tt class="literal">{</tt> and <tt class="literal">}</tt> curly braces are array definition operators following the Java array initialization syntax. Arrays can be useful to pass to user-defined functions or to select array data in a select clause.
			</p><p>
				Array definitions consist of zero or more expressions within curly braces. Any type of expression is allowed within array definitions including constants, arithmetic expressions or event properties. This is the syntax of an array definition:
			</p><pre class="synopsis"><span class="emphasis"><em>{</em></span> [<span class="emphasis"><em>expression</em></span> [,<span class="emphasis"><em>expression</em></span>...]] }</pre><p>
				Consider the next statement that returns an event property named <tt class="literal">actions</tt>. The engine populates the <tt class="literal">actions</tt> property as an array of <tt class="literal">java.lang.String</tt> values with a length of 2 elements. The first element of the array contains the <tt class="literal">observation</tt> property value and the second element the <tt class="literal">command</tt> property value of <tt class="literal">RFIDEvent</tt> events.
			</p><pre class="programlisting">select {observation, command} as actions from RFIDEvent</pre><p>
				The engine determines the array type based on the types returned by the expressions in the array definiton. For example, if all expressions in the array definition return integer values then the type of the array is <tt class="literal">java.lang.Integer[]</tt>. If the types returned by all expressions are compatible number types, such as integer and double values, the engine coerces the array element values and returns a suitable type, <tt class="literal">java.lang.Double[]</tt> in this example.
				The type of the array returned is <tt class="literal">Object[]</tt> if the types of expressions cannot be coerced or return object values. Null values can also be used in an array definition.
			</p><p>
				Arrays can come in handy for use as parameters to user-defined functions:
			</p><pre class="programlisting">select * from RFIDEvent where Filter.myFilter(zone, {1,2,3})</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="epl-operator-ref-keyword-in"></a>6.6.&nbsp;The '<tt class="literal">in</tt>' Keyword</h2></div></div><div></div></div><a class="indexterm" name="d0e11215"></a><a class="indexterm" name="d0e11220"></a><p>
				The <tt class="literal">in</tt> keyword determines if a given value matches any value in a list. The syntax of the keyword is:	
			</p><pre class="synopsis"><span class="emphasis"><em>test_expression</em></span> [not] in (<span class="emphasis"><em>expression</em></span> [,<span class="emphasis"><em>expression</em></span>...] )</pre><p>
				The <span class="emphasis"><em>test_expression</em></span> is any valid expression. The keyword is followed by a list of expressions to test for a match. The optional <tt class="literal">not</tt> keyword specifies that the result of the predicate be negated.
			</p><p>
				The result of an <tt class="literal">in</tt> expression is of type <tt class="literal">Boolean</tt>. If the value of <span class="emphasis"><em>test_expression</em></span> is equal to any expression from the comma-separated list, the result value is <tt class="literal">true</tt>. Otherwise, the result value is <tt class="literal">false</tt>. 
			</p><p>
				The next example shows how the <tt class="literal">in</tt> keyword can be applied to select certain command types of RFID events:
			</p><pre class="programlisting">select * from RFIDEvent where command in ('OBSERVATION', 'SIGNAL')</pre><p>
				The statement is equivalent to:
			</p><pre class="programlisting">select * from RFIDEvent where command = 'OBSERVATION' or command = 'SIGNAL'</pre><p>
				<span class="emphasis"><em>Expression</em></span> may also return an array, a <tt class="literal">java.util.Collection</tt> or a <tt class="literal">java.util.Map</tt>. Thus event properties that are lists, sets or maps may provide values to compare against <span class="emphasis"><em>test_expression</em></span>.
			</p><p>
				All expressions must be of the same type or a compatible type to <span class="emphasis"><em>test_expression</em></span>. The <tt class="literal">in</tt> keyword may coerce number values to compatible types. If <span class="emphasis"><em>expression</em></span> returns an array, then the component type of the array must be compatible, unless the component type of the array is <tt class="literal">Object</tt>.
			</p><p>
				If <span class="emphasis"><em>expression</em></span> returns an array of component type <tt class="literal">Object</tt>, the operation compares each element of the array, applying <tt class="literal">equals</tt> semantics.
			</p><p>
				If <span class="emphasis"><em>expression</em></span> returns a <tt class="literal">Collection</tt>, the operation determines if the collection contains the value returned by <span class="emphasis"><em>test_expression</em></span>,  applying <tt class="literal">contains</tt> semantics. 
			</p><p>
				If <span class="emphasis"><em>expression</em></span> returns a <tt class="literal">Map</tt>, the operation determines if the map contains the key value returned by <span class="emphasis"><em>test_expression</em></span>, applying <tt class="literal">containsKey</tt> semantics.
			</p><p>
				 Constants, arrays, <tt class="literal">Collection</tt> and <tt class="literal">Map</tt> expressions or event properties can be used combined.
			</p><p>
				 For example, and assuming a property named 'mySpecialCmdList'  exists that contains a list of command strings:
			</p><pre class="programlisting">select * from RFIDEvent where command in ( 'OBSERVATION', 'SIGNAL', mySpecialCmdList)</pre><p>
				 When using prepared statements and substitution parameters with the <tt class="literal">in</tt> keyword, make sure to retain the parenthesis. Substitution values may also be arrays, <tt class="literal">Collection</tt> and <tt class="literal">Map</tt> values:
			</p><pre class="synopsis"><span class="emphasis"><em>test_expression</em></span> [not] in (? [,?...] )</pre><p>
				Note that if there are no successes and at least one right-hand row yields null for the operator's result, the result of the any construct will be null, not false. This is in accordance with SQL's normal rules for Boolean combinations of null values.
			</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="epl-operator-ref-keyword-between"></a>6.7.&nbsp;The '<tt class="literal">between</tt>' Keyword</h2></div></div><div></div></div><a class="indexterm" name="d0e11379"></a><a class="indexterm" name="d0e11384"></a><p>
				The <tt class="literal">between</tt> keyword specifies a range to test. The syntax of the keyword is:	
			</p><pre class="synopsis"><span class="emphasis"><em>test_expression</em></span> [not] between <span class="emphasis"><em>begin_expression</em></span> and <span class="emphasis"><em>end_expression</em></span></pre><p>
				The <span class="emphasis"><em>test_expression</em></span> is any valid expression and is the expression to test for in the range defined by <span class="emphasis"><em>begin_expression</em></span> and <span class="emphasis"><em>end_expression</em></span>. The <tt class="literal">not</tt> keyword specifies that the result of the predicate be negated. 
			</p><p>
				The result of a <tt class="literal">between</tt> expression is of type <tt class="literal">Boolean</tt>. If the value of <span class="emphasis"><em>test_expression</em></span> is greater then or equal to the value of <span class="emphasis"><em>begin_expression</em></span> and less than or equal to the value of <span class="emphasis"><em>end_expression</em></span>, the result is <tt class="literal">true</tt>. 
			</p><p>
				The next example shows how the <tt class="literal">between</tt> keyword can be used to select events with a price between 55 and 60 (inclusive).
			</p><pre class="programlisting">select * from StockTickEvent where price between 55 and 60</pre><p>
				The equivalent expression without <tt class="literal">between</tt> is:
			</p><pre class="programlisting">select * from StockTickEvent where price &gt;= 55 and price &lt;= 60</pre><p>
				And also equivalent to:
			</p><pre class="programlisting">select * from StockTickEvent where price between 60 and 55</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="epl-operator-ref-keyword-like"></a>6.8.&nbsp;The '<tt class="literal">like</tt>' Keyword</h2></div></div><div></div></div><a class="indexterm" name="d0e11462"></a><a class="indexterm" name="d0e11467"></a><p>
				The <tt class="literal">like</tt> keyword provides standard SQL pattern matching. SQL pattern matching allows you to use <tt class="literal">'_'</tt> to match any single character and <tt class="literal">'%'</tt> to match an arbitrary number of characters (including zero characters). In Esper, SQL patterns are case-sensitive by default. The syntax of <tt class="literal">like</tt> is:	
			</p><pre class="synopsis"><span class="emphasis"><em>test_expression</em></span> [not] like <span class="emphasis"><em>pattern_expression</em></span> [escape <span class="emphasis"><em>string_literal</em></span>]</pre><p>
				The <span class="emphasis"><em>test_expression</em></span> is any valid expression yielding a String-type or a numeric result. The optional <tt class="literal">not</tt> keyword specifies that the result of the predicate be negated. The <tt class="literal">like</tt> keyword is followed by any valid standard SQL <span class="emphasis"><em>pattern_expression</em></span> yielding a String-typed result. The optional <tt class="literal">escape</tt> keyword signals the escape character to escape <tt class="literal">'_'</tt> and <tt class="literal">'%'</tt> values in the pattern.
			</p><p>
				The result of a <tt class="literal">like</tt> expression is of type <tt class="literal">Boolean</tt>. If the value of <span class="emphasis"><em>test_expression</em></span> matches the <span class="emphasis"><em>pattern_expression</em></span>, the result value is <tt class="literal">true</tt>. Otherwise, the result value is <tt class="literal">false</tt>.
			</p><p>
				An example for the <tt class="literal">like</tt> keyword is below.
			</p><pre class="programlisting">select * from PersonLocationEvent where name like '%Jack%'</pre><p>
				The escape character can be defined as follows. In this example the where-clause matches events where the suffix property is a single <tt class="literal">'_'</tt> character.
			</p><pre class="programlisting">select * from PersonLocationEvent where suffix like '!_' escape '!'</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="epl-operator-ref-keyword-regexp"></a>6.9.&nbsp;The '<tt class="literal">regexp</tt>' Keyword</h2></div></div><div></div></div><a class="indexterm" name="d0e11560"></a><a class="indexterm" name="d0e11565"></a><p>
				The <tt class="literal">regexp</tt> keyword is a form of pattern matching based on regular expressions implemented through the Java <tt class="literal">java.util.regex</tt> package. The syntax of <tt class="literal">regexp</tt> is:	
			</p><pre class="synopsis"><span class="emphasis"><em>test_expression</em></span> [not] regexp <span class="emphasis"><em>pattern_expression</em></span></pre><p>
				The <span class="emphasis"><em>test_expression</em></span> is any valid expression yielding a String-type or a numeric result. The optional <tt class="literal">not</tt> keyword specifies that the result of the predicate be negated. The <tt class="literal">regexp</tt> keyword is followed by any valid regular expression <span class="emphasis"><em>pattern_expression</em></span> yielding a String-typed result.
			</p><p>
				The result of a <tt class="literal">regexp</tt> expression is of type <tt class="literal">Boolean</tt>. If the value of <span class="emphasis"><em>test_expression</em></span> matches the regular expression <span class="emphasis"><em>pattern_expression</em></span>, the result value is <tt class="literal">true</tt>. Otherwise, the result value is <tt class="literal">false</tt>.
			</p><p>
				An example for the <tt class="literal">regexp</tt> keyword is below.
			</p><pre class="programlisting">select * from PersonLocationEvent where name regexp '*Jack*'</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="epl-operator-anysome"></a>6.10.&nbsp;The '<tt class="literal">any</tt>' and '<tt class="literal">some</tt>' Keywords</h2></div></div><div></div></div><p>
				The <tt class="literal">any</tt> operator is true if the expression returns true for one or more of the values returned by a list of expressions including array, <tt class="literal">Collection</tt> and <tt class="literal">Map</tt> values.
			</p><p>
				The synopsis for the <tt class="literal">any</tt> keyword is as follows:
			</p><pre class="synopsis"><span class="emphasis"><em>expression</em></span> <span class="emphasis"><em>operator</em></span> any (<span class="emphasis"><em>expression</em></span> [,<span class="emphasis"><em>expression</em></span>...] )</pre><p>
				The left-hand expression is evaluated and compared to each expression result using the given operator, which must yield a Boolean result. The result of <tt class="literal">any</tt> is "true" if any true result is obtained. The result is "false" if no true result is found (including the special case where the expressions are collections that return no rows). 
			</p><p>
				The <span class="emphasis"><em>operator</em></span> can be any of the following values: <tt class="literal">=, !=, &lt;&gt;, &lt;, &lt;=, &gt;, &gt;=</tt>.
			</p><p>
				The <tt class="literal">some</tt> keyword is a synonym for <tt class="literal">any</tt>. The <tt class="literal">in</tt> construct is equivalent to <tt class="literal">= any</tt>.
			</p><p>
				<span class="emphasis"><em>Expression</em></span> may also return an array, a <tt class="literal">java.util.Collection</tt> or a <tt class="literal">java.util.Map</tt>. Thus event properties that are lists, sets or maps may provide values to compare against.
			</p><p>
				All expressions must be of the same type or a compatible type. The <tt class="literal">any</tt> keyword coerces number values to compatible types. If <span class="emphasis"><em>expression</em></span> returns an array, then the component type of the array must be compatible, unless the component type of the array is <tt class="literal">Object</tt>.
			</p><p>
				If <span class="emphasis"><em>expression</em></span> returns an array, the operation compares each element of the array.
			</p><p>
				If <span class="emphasis"><em>expression</em></span> returns a <tt class="literal">Collection</tt>, the operation determines if the collection contains the value returned by the left-hand expression,  applying <tt class="literal">contains</tt> semantics. 
				When using relationship operators <tt class="literal">&lt;, &lt;=, &gt;, &gt;=</tt> the operator applies to each element in the collection, and non-numeric elements are ignored.
			</p><p>
				If <span class="emphasis"><em>expression</em></span> returns a <tt class="literal">Map</tt>, the operation determines if the map contains the key value returned by the left-hand expression, applying <tt class="literal">containsKey</tt> semantics.
				When using relationship operators <tt class="literal">&lt;, &lt;=, &gt;, &gt;=</tt> the operator applies to each key in the map, and non-numeric map keys are ignored.
			</p><p>
				 Constants, arrays, <tt class="literal">Collection</tt> and <tt class="literal">Map</tt> expressions or event properties can be used combined.
			</p><p>
				The next statement demonstrates the use of the <tt class="literal">any</tt> operator: 
			</p><pre class="programlisting">select * from ProductOrder where category != any (categoryArray)</pre><p>
				The above query selects ProductOrder event that have a category field and a category array, and returns only those events in which the category value is not in the array.
			</p><p>
				Note that if there are no successes and at least one right-hand row yields null for the operator's result, the result of the <tt class="literal">any</tt> construct will be null, not false. This is in accordance with SQL's normal rules for Boolean combinations of null values. 
			</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="epl-operator-all"></a>6.11.&nbsp;The '<tt class="literal">all</tt>' Keyword</h2></div></div><div></div></div><p>
				The <tt class="literal">all</tt> operator is true if the expression returns true for all of the values returned by a list of expressions including array, <tt class="literal">Collection</tt> and <tt class="literal">Map</tt> values.
			</p><p>
				The synopsis for the <tt class="literal">all</tt> keyword is as follows:
			</p><pre class="synopsis"><span class="emphasis"><em>expression</em></span> <span class="emphasis"><em>operator</em></span> all (<span class="emphasis"><em>expression</em></span> [,<span class="emphasis"><em>expression</em></span>...] )</pre><p>
				The left-hand expression is evaluated and compared to each expression result using the given operator, which must yield a Boolean result. The result of <tt class="literal">all</tt> is "true" if all rows yield true (including the special case where the expressions are collections that returns no rows). The result is "false" if any false result is found. The result is <tt class="literal">null</tt> if the comparison does not return false for any row, and it returns <tt class="literal">null</tt> for at least one row.
			</p><p>
				The <span class="emphasis"><em>operator</em></span> can be any of the following values: <tt class="literal">=, !=, &lt;&gt;, &lt;, &lt;=, &gt;, &gt;=</tt>.
			</p><p>
				The <tt class="literal">not in</tt> construct is equivalent to <tt class="literal">!= all</tt>.
			</p><p>
				<span class="emphasis"><em>Expression</em></span> may also return an array, a <tt class="literal">java.util.Collection</tt> or a <tt class="literal">java.util.Map</tt>. Thus event properties that are lists, sets or maps may provide values to compare against.
			</p><p>
				All expressions must be of the same type or a compatible type. The <tt class="literal">all</tt> keyword coerces number values to compatible types. If <span class="emphasis"><em>expression</em></span> returns an array, then the component type of the array must be compatible, unless the component type of the array is <tt class="literal">Object</tt>.
			</p><p>
				If <span class="emphasis"><em>expression</em></span> returns an array, the operation compares each element of the array.
			</p><p>
				If <span class="emphasis"><em>expression</em></span> returns a <tt class="literal">Collection</tt>, the operation determines if the collection contains the value returned by the left-hand expression,  applying <tt class="literal">contains</tt> semantics. 
				When using relationship operators <tt class="literal">&lt;, &lt;=, &gt;, &gt;=</tt> the operator applies to each element in the collection, and non-numeric elements are ignored.
			</p><p>
				If <span class="emphasis"><em>expression</em></span> returns a <tt class="literal">Map</tt>, the operation determines if the map contains the key value returned by the left-hand expression, applying <tt class="literal">containsKey</tt> semantics.
				When using relationship operators <tt class="literal">&lt;, &lt;=, &gt;, &gt;=</tt> the operator applies to each key in the map, and non-numeric map keys are ignored.
			</p><p>
				 Constants, arrays, <tt class="literal">Collection</tt> and <tt class="literal">Map</tt> expressions or event properties can be used combined.
			</p><p>
				The next statement demonstrates the use of the <tt class="literal">all</tt> operator: 
			</p><pre class="programlisting">select * from ProductOrder where category = all (categoryArray)</pre><p>
				The above query selects ProductOrder event that have a category field and a category array, and returns only those events in which the category value matches all values in the array.
			</p></div></div><hr xmlns="http://www.w3.org/TR/xhtml1/transitional"><center xmlns="http://www.w3.org/TR/xhtml1/transitional">&copy; 2009 EsperTech Inc. All Rights Reserved</center><script xmlns="http://www.w3.org/TR/xhtml1/transitional" type="text/javascript">
	var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
	document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
	</script><script xmlns="http://www.w3.org/TR/xhtml1/transitional" type="text/javascript">
	var pageTracker = _gat._getTracker("UA-1261295-1");
	pageTracker._trackPageview();
	</script><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="event_patterns.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="index.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="functionreference.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter&nbsp;5.&nbsp;EPL Reference: Patterns&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;7.&nbsp;EPL Reference: Functions</td></tr></table></div></body></html>