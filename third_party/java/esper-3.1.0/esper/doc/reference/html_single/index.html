<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Esper - Event Stream and Complex Event Processing for Java</title><link rel="stylesheet" href="../shared/css/html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.65.1"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="book" lang="en"><div class="titlepage"><div><div><h1 class="title"><a name="d0e2"></a>Esper - Event Stream and Complex Event Processing for Java</h1></div><div><h2 class="subtitle">Reference Documentation</h2></div><div><p class="releaseinfo">3.1.0</p></div><div><p class="copyright">Copyright &copy; 2009 EsperTech Inc.</p></div></div><div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="preface"><a href="#preface">Preface</a></span></dt><dt><span class="chapter"><a href="#technology_overview">1. Technology Overview</a></span></dt><dd><dl><dt><span class="sect1"><a href="#technology_overview_intro_cep">1.1. Introduction to CEP and event stream analysis</a></span></dt><dt><span class="sect1"><a href="#cep_and_relational">1.2. CEP and relational databases</a></span></dt><dt><span class="sect1"><a href="#cep_with_esper">1.3. The Esper engine for CEP</a></span></dt><dt><span class="sect1"><a href="#required_3rd_party">1.4. Required 3rd Party Libraries</a></span></dt></dl></dd><dt><span class="chapter"><a href="#event_representation">2. Event Representations</a></span></dt><dd><dl><dt><span class="sect1"><a href="#eventrep_intro">2.1. Event Underlying Java Objects</a></span></dt><dt><span class="sect1"><a href="#eventrep-properties">2.2. Event Properties</a></span></dt><dd><dl><dt><span class="sect2"><a href="#eventrep-properties-escaping">2.2.1. Escape Characters</a></span></dt></dl></dd><dt><span class="sect1"><a href="#eventrep-dyncproperties">2.3. Dynamic Event Properties</a></span></dt><dt><span class="sect1"><a href="#eventrep-fragment">2.4. Fragment and Fragment Type</a></span></dt><dt><span class="sect1"><a href="#eventrep-javabean">2.5. Plain-Old Java Object Events</a></span></dt><dd><dl><dt><span class="sect2"><a href="#event-properties">2.5.1. Java Object Event Properties</a></span></dt><dt><span class="sect2"><a href="#event-properties-names">2.5.2. Property Names</a></span></dt><dt><span class="sect2"><a href="#event-properties-const">2.5.3. Constants and Enumeration</a></span></dt><dt><span class="sect2"><a href="#event-properties-parameterized">2.5.4. Parameterized Types</a></span></dt></dl></dd><dt><span class="sect1"><a href="#eventrep-java-util-map">2.6. java.util.Map Events</a></span></dt><dd><dl><dt><span class="sect2"><a href="#eventrep-map-overview">2.6.1. Overview</a></span></dt><dt><span class="sect2"><a href="#eventrep-map-properties">2.6.2. Map Properties</a></span></dt><dt><span class="sect2"><a href="#eventrep-map-supertype">2.6.3. Map Supertypes</a></span></dt><dt><span class="sect2"><a href="#eventrep-map-advanced">2.6.4. Advanced Map Property Types</a></span></dt><dd><dl><dt><span class="sect3"><a href="#eventrep-map-nested">2.6.4.1. Nested Properties</a></span></dt><dt><span class="sect3"><a href="#eventrep-map-typereuse">2.6.4.2. Map Event Type Properties</a></span></dt><dt><span class="sect3"><a href="#eventrep-map-array">2.6.4.3. One-to-Many Relationships</a></span></dt></dl></dd></dl></dd><dt><span class="sect1"><a href="#eventrep-xml-dom">2.7. org.w3c.dom.Node XML Events</a></span></dt><dd><dl><dt><span class="sect2"><a href="#eventrep-xml-dom-schema">2.7.1. Schema-Provided XML Events</a></span></dt><dd><dl><dt><span class="sect3"><a href="#eventrep-xml-dom-schema-start">2.7.1.1. Getting Started</a></span></dt><dt><span class="sect3"><a href="#eventrep-xml-dom-schema-propertyexpr">2.7.1.2. Property Expressions and Namespaces</a></span></dt><dt><span class="sect3"><a href="#eventrep-xml-dom-schema-propertyexpr-xpath">2.7.1.3. Property Expression to XPath Rewrite</a></span></dt><dt><span class="sect3"><a href="#eventrep-xml-dom-schema-propertyarray">2.7.1.4. Array Properties</a></span></dt><dt><span class="sect3"><a href="#eventrep-xml-dom-schema-propertydynamic">2.7.1.5. Dynamic Properties</a></span></dt><dt><span class="sect3"><a href="#eventrep-xml-dom-schema-propertytranspose">2.7.1.6. Transposing Properties</a></span></dt><dt><span class="sect3"><a href="#eventrep-xml-dom-eventsender">2.7.1.7. Event Sender</a></span></dt></dl></dd><dt><span class="sect2"><a href="#eventrep-xml-dom-noschema">2.7.2. No-Schema-Provided XML Events</a></span></dt><dt><span class="sect2"><a href="#eventrep-xml-dom-explicit">2.7.3. Explicitly-Configured Properties</a></span></dt><dd><dl><dt><span class="sect3"><a href="#eventrep-xml-dom-explicit-simple">2.7.3.1. Simple Explicit Property</a></span></dt><dt><span class="sect3"><a href="#eventrep-xml-dom-explicit-casted">2.7.3.2. Explicit Property Casting and Parsing</a></span></dt><dt><span class="sect3"><a href="#eventrep-xml-dom-explicit-node">2.7.3.3. Node and Nodeset Explicit Property</a></span></dt></dl></dd></dl></dd><dt><span class="sect1"><a href="#eventrep-plug-in">2.8. Additional Event Representations</a></span></dt><dt><span class="sect1"><a href="#eventrep-update">2.9. Updating and Versioning Events</a></span></dt><dt><span class="sect1"><a href="#eventrep-coarse">2.10. Coarse-Grained Events</a></span></dt><dt><span class="sect1"><a href="#eventrep-insertinto">2.11. Event Objects Populated by Insert Into</a></span></dt></dl></dd><dt><span class="chapter"><a href="#processingmodel">3. Processing Model</a></span></dt><dd><dl><dt><span class="sect1"><a href="#processingmodel_intro">3.1. Introduction</a></span></dt><dt><span class="sect1"><a href="#processingmodel_nowindow">3.2. Insert Stream</a></span></dt><dt><span class="sect1"><a href="#processingmodel_lengthwindow">3.3. Insert and Remove Stream</a></span></dt><dt><span class="sect1"><a href="#processingmodel_filter">3.4. Filters and Where-clauses</a></span></dt><dt><span class="sect1"><a href="#processingmodel_time_window">3.5. Time Windows</a></span></dt><dd><dl><dt><span class="sect2"><a href="#processingmodel_time_window_1">3.5.1. Time Window</a></span></dt><dt><span class="sect2"><a href="#processingmodel_time_batch_1">3.5.2. Time Batch</a></span></dt></dl></dd><dt><span class="sect1"><a href="#processingmodel_batch">3.6. Batch Windows</a></span></dt><dt><span class="sect1"><a href="#processingmodel_aggregation">3.7. Aggregation and Grouping</a></span></dt><dd><dl><dt><span class="sect2"><a href="#processingmodel_aggregation_irstream">3.7.1. Insert and Remove Stream</a></span></dt><dt><span class="sect2"><a href="#processingmodel_aggregation_output">3.7.2. Output for Aggregation and Group-By</a></span></dt><dd><dl><dt><span class="sect3"><a href="#processingmodel_aggregation_batch_unagg">3.7.2.1. Un-aggregated and Un-grouped</a></span></dt><dt><span class="sect3"><a href="#processingmodel_aggregation_batch_full_agg">3.7.2.2. Fully Aggregated and Un-grouped</a></span></dt><dt><span class="sect3"><a href="#processingmodel_aggregation_batch_event_agg">3.7.2.3. Aggregated and Un-Grouped</a></span></dt><dt><span class="sect3"><a href="#processingmodel_aggregation_batch_group_agg">3.7.2.4. Fully Aggregated and Grouped</a></span></dt><dt><span class="sect3"><a href="#processingmodel_aggregation_batch_event_agg_group">3.7.2.5. Aggregated and Grouped</a></span></dt></dl></dd></dl></dd></dl></dd><dt><span class="chapter"><a href="#epl_clauses">4. EPL Reference: Clauses</a></span></dt><dd><dl><dt><span class="sect1"><a href="#epl-intro">4.1. EPL Introduction</a></span></dt><dt><span class="sect1"><a href="#epl-select-syntax">4.2. EPL Syntax</a></span></dt><dd><dl><dt><span class="sect2"><a href="#epl-syntax-time-periods">4.2.1. Specifying Time Periods</a></span></dt><dt><span class="sect2"><a href="#epl-syntax-comments">4.2.2. Using Comments</a></span></dt><dt><span class="sect2"><a href="#epl-syntax-keywords">4.2.3. Reserved Keywords</a></span></dt><dt><span class="sect2"><a href="#epl-syntax-datatype">4.2.4. Data Types</a></span></dt><dd><dl><dt><span class="sect3"><a href="#epl-syntax-datatype-constants">4.2.4.1. Data Type of Constants</a></span></dt><dt><span class="sect3"><a href="#epl-syntax-datatype-bignumber">4.2.4.2. BigInteger and BigDecimal</a></span></dt></dl></dd><dt><span class="sect2"><a href="#epl-syntax-annotation">4.2.5. Annotation</a></span></dt><dd><dl><dt><span class="sect3"><a href="#epl-syntax-annotation-application">4.2.5.1. Application-Provided Annotations</a></span></dt><dt><span class="sect3"><a href="#epl-syntax-annotation-builtin">4.2.5.2. Built-In Annotations</a></span></dt><dt><span class="sect3"><a href="#epl-syntax-annotation-name">4.2.5.3. @Name</a></span></dt><dt><span class="sect3"><a href="#epl-syntax-annotation-description">4.2.5.4. @Description</a></span></dt><dt><span class="sect3"><a href="#epl-syntax-annotation-tag">4.2.5.5. @Tag</a></span></dt><dt><span class="sect3"><a href="#epl-syntax-annotation-priority">4.2.5.6. @Priority</a></span></dt><dt><span class="sect3"><a href="#epl-syntax-annotation-drop">4.2.5.7. @Drop</a></span></dt></dl></dd></dl></dd><dt><span class="sect1"><a href="#epl-select-list">4.3. Choosing Event Properties And Events: the Select Clause</a></span></dt><dd><dl><dt><span class="sect2"><a href="#epl-select-all-props">4.3.1. Choosing all event properties: select *</a></span></dt><dt><span class="sect2"><a href="#epl-select-event-props">4.3.2. Choosing specific event properties</a></span></dt><dt><span class="sect2"><a href="#epl-select-expressions">4.3.3. Expressions</a></span></dt><dt><span class="sect2"><a href="#epl-select-renaming">4.3.4. Renaming event properties</a></span></dt><dt><span class="sect2"><a href="#epl-select-all-join">4.3.5. Choosing event properties and events in a join</a></span></dt><dt><span class="sect2"><a href="#epl-select-pattern">4.3.6. Choosing event properties and events from a pattern</a></span></dt><dt><span class="sect2"><a href="#epl-select-using-istream-rstream">4.3.7. Selecting insert and remove stream events</a></span></dt><dt><span class="sect2"><a href="#epl-syntax-prefix-propsandstream">4.3.8. Qualifying property names and stream names</a></span></dt></dl></dd><dt><span class="sect1"><a href="#epl-from-clause">4.4. Specifying Event Streams: the From Clause</a></span></dt><dd><dl><dt><span class="sect2"><a href="#epl-from-clause-filter">4.4.1. Filter-based Event Streams</a></span></dt><dd><dl><dt><span class="sect3"><a href="#epl-filter-event-type">4.4.1.1. Specifying an Event Type</a></span></dt><dt><span class="sect3"><a href="#epl-filter-criteria">4.4.1.2. Specifying Filter Criteria</a></span></dt><dt><span class="sect3"><a href="#epl-filter-ranges">4.4.1.3. Filtering Ranges</a></span></dt><dt><span class="sect3"><a href="#epl-filter-in">4.4.1.4. Filtering Sets of Values</a></span></dt><dt><span class="sect3"><a href="#epl-filter-limitations">4.4.1.5. Filter Limitations</a></span></dt></dl></dd><dt><span class="sect2"><a href="#epl-from-clause-patterns">4.4.2. Pattern-based Event Streams</a></span></dt><dt><span class="sect2"><a href="#epl-from-clause-view-spec">4.4.3. Specifying Views</a></span></dt><dt><span class="sect2"><a href="#epl-from-clause-view-multidatawindow">4.4.4. Multiple Data Window Views</a></span></dt><dt><span class="sect2"><a href="#epl-from-clause-stream-name">4.4.5. Using the Stream Name</a></span></dt></dl></dd><dt><span class="sect1"><a href="#epl-where-clause">4.5. Specifying Search Conditions: the Where Clause</a></span></dt><dt><span class="sect1"><a href="#epl-grouping-aggregating">4.6. Aggregates and grouping: the Group-by Clause and the Having Clause</a></span></dt><dd><dl><dt><span class="sect2"><a href="#epl-grouping-aggregate-functions">4.6.1. Using aggregate functions</a></span></dt><dt><span class="sect2"><a href="#epl-grouping-group-by">4.6.2. Organizing statement results into groups: the Group-by clause</a></span></dt><dt><span class="sect2"><a href="#epl-grouping-having">4.6.3. Selecting groups of events: the Having clause</a></span></dt><dt><span class="sect2"><a href="#epl-filter-where-grouping-having-interactions">4.6.4. How the stream filter, Where, Group By and Having clauses interact</a></span></dt><dt><span class="sect2"><a href="#epl-group-by-versus-view">4.6.5. Comparing the Group By clause and the std:groupby view</a></span></dt></dl></dd><dt><span class="sect1"><a href="#epl-output-rate">4.7. Stabilizing and Controlling Output: the Output Clause</a></span></dt><dd><dl><dt><span class="sect2"><a href="#epl-output-options">4.7.1. Output Clause Options</a></span></dt><dd><dl><dt><span class="sect3"><a href="#epl-output-expression">4.7.1.1. Controlling Output Using an Expression</a></span></dt></dl></dd><dt><span class="sect2"><a href="#epl-output-groupby">4.7.2. Aggregation, Group By, Having and Output clause interaction</a></span></dt><dt><span class="sect2"><a href="#epl-output-runtime">4.7.3. Runtime Considerations</a></span></dt></dl></dd><dt><span class="sect1"><a href="#epl-order-by">4.8. Sorting Output: the Order By Clause</a></span></dt><dt><span class="sect1"><a href="#epl-limit">4.9. Limiting Row Count: the Limit Clause</a></span></dt><dt><span class="sect1"><a href="#epl-insert-into">4.10. Merging Streams and Continuous Insertion: the Insert Into Clause</a></span></dt><dd><dl><dt><span class="sect2"><a href="#insert-into-property-transpose">4.10.1. Transposing a Property To a Stream</a></span></dt><dt><span class="sect2"><a href="#insert-into-merging-columns">4.10.2. Merging Streams By Event Type</a></span></dt><dt><span class="sect2"><a href="#insert-into-merging-types">4.10.3. Merging Disparate Types of Events: Variant Streams</a></span></dt><dt><span class="sect2"><a href="#insert-into-decorated">4.10.4. Decorated Events</a></span></dt><dt><span class="sect2"><a href="#insert-into-eventasproperty">4.10.5. Event as a Property</a></span></dt><dt><span class="sect2"><a href="#insert-into-populate">4.10.6. Populating an Underlying Event Object</a></span></dt></dl></dd><dt><span class="sect1"><a href="#epl-join">4.11. Joining Event Streams</a></span></dt><dt><span class="sect1"><a href="#epl-outerjoin">4.12. Outer and Inner Joins</a></span></dt><dt><span class="sect1"><a href="#epl-unidirectional">4.13. Unidirectional Joins</a></span></dt><dt><span class="sect1"><a href="#epl-subqueries">4.14. Subqueries</a></span></dt><dd><dl><dt><span class="sect2"><a href="#epl-subqueries-exists">4.14.1. The 'exists' Keyword</a></span></dt><dt><span class="sect2"><a href="#epl-subqueries-in">4.14.2. The 'in' and 'not in' Keywords</a></span></dt><dt><span class="sect2"><a href="#epl-subqueries-anysome">4.14.3. The 'any' and 'some' Keywords</a></span></dt><dt><span class="sect2"><a href="#epl-subqueries-all">4.14.4. The 'all' Keyword</a></span></dt></dl></dd><dt><span class="sect1"><a href="#histdata_overview">4.15. Accessing Relational Data via SQL</a></span></dt><dd><dl><dt><span class="sect2"><a href="#histdata_join">4.15.1. Joining SQL Query Results</a></span></dt><dt><span class="sect2"><a href="#histdata_join_where">4.15.2. SQL Query and the EPL Where Clause</a></span></dt><dt><span class="sect2"><a href="#histdata_outerjoin">4.15.3. Outer Joins With SQL Queries</a></span></dt><dt><span class="sect2"><a href="#histdata_polling_pattern">4.15.4. Using Patterns to Request (Poll) Data</a></span></dt><dt><span class="sect2"><a href="#histdata_polling">4.15.5. Polling SQL Queries via Iterator</a></span></dt><dt><span class="sect2"><a href="#histdata_implementation">4.15.6. JDBC Implementation Overview</a></span></dt><dt><span class="sect2"><a href="#histdata_nometadata">4.15.7. Oracle Drivers and No-Metadata Workaround</a></span></dt></dl></dd><dt><span class="sect1"><a href="#joining_method">4.16. Accessing Non-Relational Data via Method Invocation</a></span></dt><dd><dl><dt><span class="sect2"><a href="#joining_method_syntax">4.16.1. Joining Method Invocation Results</a></span></dt><dt><span class="sect2"><a href="#joining_method_polling">4.16.2. Polling Method Invocation Results via Iterator</a></span></dt><dt><span class="sect2"><a href="#joining_method_exposing">4.16.3. Providing the Method</a></span></dt><dt><span class="sect2"><a href="#joining_method_map">4.16.4. Using a Map Return Type</a></span></dt></dl></dd><dt><span class="sect1"><a href="#named_overview">4.17. Creating and Using Named Windows</a></span></dt><dd><dl><dt><span class="sect2"><a href="#named_create">4.17.1. Creating Named Windows: the Create Window clause</a></span></dt><dd><dl><dt><span class="sect3"><a href="#named_create_modelafter">4.17.1.1. Creation by Modelling after an Existing Type</a></span></dt><dt><span class="sect3"><a href="#named_create_explicit">4.17.1.2. Creation By Defining Columns Names and Types</a></span></dt><dt><span class="sect3"><a href="#named_create_drop">4.17.1.3. Dropping or Removing Named Windows</a></span></dt></dl></dd><dt><span class="sect2"><a href="#named_delete">4.17.2. Deleting From Named Windows: the On Delete clause</a></span></dt><dd><dl><dt><span class="sect3"><a href="#named_delete_pattern">4.17.2.1. Using Patterns in the On Delete Clause</a></span></dt></dl></dd><dt><span class="sect2"><a href="#named_inserting">4.17.3. Inserting Into Named Windows</a></span></dt><dd><dl><dt><span class="sect3"><a href="#named-insertinto-decorated">4.17.3.1. Named Windows Holding Decorated Events</a></span></dt><dt><span class="sect3"><a href="#named-insertinto-eventasproperty">4.17.3.2. Named Windows Holding Events As Property</a></span></dt></dl></dd><dt><span class="sect2"><a href="#named_selecting">4.17.4. Selecting From Named Windows</a></span></dt><dt><span class="sect2"><a href="#named_querying">4.17.5. Triggered Select on Named Windows: the On Select clause</a></span></dt><dt><span class="sect2"><a href="#named_playback">4.17.6. Triggered Playback from Named Windows: the On Insert clause</a></span></dt><dt><span class="sect2"><a href="#named_populate_named">4.17.7. Populating a Named Window from an Existing Named Window</a></span></dt><dt><span class="sect2"><a href="#named_update">4.17.8. Updating and Versioning Events in Named Windows</a></span></dt></dl></dd><dt><span class="sect1"><a href="#split_overview">4.18. Splitting and Duplicating Streams</a></span></dt><dt><span class="sect1"><a href="#variables_overview">4.19. Variables</a></span></dt><dd><dl><dt><span class="sect2"><a href="#variable_create">4.19.1. Creating Variables: the Create Variable clause</a></span></dt><dt><span class="sect2"><a href="#variable_set">4.19.2. Setting Variable Values: the On Set clause</a></span></dt><dt><span class="sect2"><a href="#variable_using">4.19.3. Using Variables</a></span></dt></dl></dd><dt><span class="sect1"><a href="#epl-containedeventselect">4.20. Contained-Event Selection</a></span></dt><dd><dl><dt><span class="sect2"><a href="#epl-containedeventselect-select">4.20.1. Select Clause in a Contained-Event Selection</a></span></dt><dt><span class="sect2"><a href="#epl-containedeventselect-where">4.20.2. Where Clause in a Contained-Event Selection</a></span></dt><dt><span class="sect2"><a href="#epl-containedeventselect-join">4.20.3. Contained-Event Selection and Joins</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#event_patterns">5. EPL Reference: Patterns</a></span></dt><dd><dl><dt><span class="sect1"><a href="#event-pattern-intro">5.1. Event Pattern Overview</a></span></dt><dt><span class="sect1"><a href="#pattern-how-to-use">5.2. How to use Patterns</a></span></dt><dd><dl><dt><span class="sect2"><a href="#pattern-howto-syntax">5.2.1. Pattern Syntax</a></span></dt><dt><span class="sect2"><a href="#pattern-in-eql">5.2.2. Patterns in EPL</a></span></dt><dt><span class="sect2"><a href="#patterns-howto-subscribe">5.2.3. Subscribing to Pattern Events</a></span></dt><dt><span class="sect2"><a href="#pattern-howto-pull-data">5.2.4. Pulling Data from Patterns</a></span></dt></dl></dd><dt><span class="sect1"><a href="#pattern-op-precedence">5.3. Operator Precedence</a></span></dt><dt><span class="sect1"><a href="#pattern-filter">5.4. Filter Expressions In Patterns</a></span></dt><dt><span class="sect1"><a href="#pattern-operators">5.5. Pattern Operators</a></span></dt><dd><dl><dt><span class="sect2"><a href="#pattern-logical-every">5.5.1. Every</a></span></dt><dd><dl><dt><span class="sect3"><a href="#pattern-every-ending-subexp">5.5.1.1. Limiting Subexpression Lifetime</a></span></dt><dt><span class="sect3"><a href="#pattern-every-sample1">5.5.1.2. Every Operator Example</a></span></dt><dt><span class="sect3"><a href="#pattern-every-sample2">5.5.1.3. Sensor Example</a></span></dt></dl></dd><dt><span class="sect2"><a href="#pattern-logical-everydistinct">5.5.2. Every-Distinct</a></span></dt><dt><span class="sect2"><a href="#pattern-repeat">5.5.3. Repeat</a></span></dt><dt><span class="sect2"><a href="#pattern-repeatuntil">5.5.4. Repeat-Until</a></span></dt><dd><dl><dt><span class="sect3"><a href="#pattern-repeatuntil-norange">5.5.4.1. Unbound Repeat</a></span></dt><dt><span class="sect3"><a href="#pattern-repeatuntil-range">5.5.4.2. Bound Repeat Overview</a></span></dt><dt><span class="sect3"><a href="#pattern-repeatuntil-range-openended">5.5.4.3. Bound Repeat - Open Ended Range</a></span></dt><dt><span class="sect3"><a href="#pattern-repeatuntil-range-nolow">5.5.4.4. Bound Repeat - High Endpoint Range</a></span></dt><dt><span class="sect3"><a href="#pattern-repeatuntil-range-bounded">5.5.4.5. Bound Repeat - Bounded Range</a></span></dt><dt><span class="sect3"><a href="#pattern-repeat-tags">5.5.4.6. Tags and the Repeat Operator</a></span></dt></dl></dd><dt><span class="sect2"><a href="#pattern-logical-and">5.5.5. And</a></span></dt><dt><span class="sect2"><a href="#pattern-logical-or">5.5.6. Or</a></span></dt><dt><span class="sect2"><a href="#pattern-logical-not">5.5.7. Not</a></span></dt><dt><span class="sect2"><a href="#pattern-temporal-followed-by">5.5.8. Followed-by</a></span></dt><dt><span class="sect2"><a href="#pattern-guards">5.5.9. Pattern Guards</a></span></dt><dd><dl><dt><span class="sect3"><a href="#pattern-timer-within">5.5.9.1. timer:within</a></span></dt></dl></dd></dl></dd><dt><span class="sect1"><a href="#pattern-atoms">5.6. Pattern Atoms</a></span></dt><dd><dl><dt><span class="sect2"><a href="#pattern-atom-filter">5.6.1. Filter Atoms</a></span></dt><dt><span class="sect2"><a href="#pattern-atom-time">5.6.2. Time-based Observer Atoms</a></span></dt><dd><dl><dt><span class="sect3"><a href="#pattern-timer-interval">5.6.2.1. timer:interval</a></span></dt><dt><span class="sect3"><a href="#pattern-timer-at">5.6.2.2. timer:at</a></span></dt></dl></dd></dl></dd></dl></dd><dt><span class="chapter"><a href="#epl-operator">6. EPL Reference: Operators</a></span></dt><dd><dl><dt><span class="sect1"><a href="#epl-operator-ref-arithmetic">6.1. Arithmetic Operators</a></span></dt><dt><span class="sect1"><a href="#epl-operator-ref-logical">6.2. Logical And Comparsion Operators</a></span></dt><dt><span class="sect1"><a href="#epl-operator-ref-string">6.3. Concatenation Operators</a></span></dt><dt><span class="sect1"><a href="#epl-operator-ref-binary">6.4. Binary Operators</a></span></dt><dt><span class="sect1"><a href="#epl-operator-ref-array">6.5. Array Definition Operator</a></span></dt><dt><span class="sect1"><a href="#epl-operator-ref-keyword-in">6.6. The 'in' Keyword</a></span></dt><dt><span class="sect1"><a href="#epl-operator-ref-keyword-between">6.7. The 'between' Keyword</a></span></dt><dt><span class="sect1"><a href="#epl-operator-ref-keyword-like">6.8. The 'like' Keyword</a></span></dt><dt><span class="sect1"><a href="#epl-operator-ref-keyword-regexp">6.9. The 'regexp' Keyword</a></span></dt><dt><span class="sect1"><a href="#epl-operator-anysome">6.10. The 'any' and 'some' Keywords</a></span></dt><dt><span class="sect1"><a href="#epl-operator-all">6.11. The 'all' Keyword</a></span></dt></dl></dd><dt><span class="chapter"><a href="#functionreference">7. EPL Reference: Functions</a></span></dt><dd><dl><dt><span class="sect1"><a href="#epl-single-row-function-ref">7.1. Single-row Function Reference</a></span></dt><dd><dl><dt><span class="sect2"><a href="#epl-single-row-function-ref-case">7.1.1. The Case Control Flow Function</a></span></dt><dt><span class="sect2"><a href="#epl-single-row-function-cast">7.1.2. The Cast Function</a></span></dt><dt><span class="sect2"><a href="#epl-single-row-function-ref-coalesce">7.1.3. The Coalesce Function</a></span></dt><dt><span class="sect2"><a href="#epl-single-row-function-ref-currenttime">7.1.4. The Current_Timestamp Function</a></span></dt><dt><span class="sect2"><a href="#epl-single-row-function-exists">7.1.5. The Exists Function</a></span></dt><dt><span class="sect2"><a href="#epl-single-row-function-instanceof">7.1.6. The Instance-Of Function</a></span></dt><dt><span class="sect2"><a href="#epl-single-row-function-ref-minmax">7.1.7. The Min and Max Functions</a></span></dt><dt><span class="sect2"><a href="#epl-single-row-function-ref-previous">7.1.8. The Previous Function</a></span></dt><dd><dl><dt><span class="sect3"><a href="#epl-single-row-function-ref-prev-group">7.1.8.1. Previous Event per Group</a></span></dt><dt><span class="sect3"><a href="#epl-single-row-function-ref-prev-restrictions">7.1.8.2. Restrictions</a></span></dt><dt><span class="sect3"><a href="#epl-single-row-function-ref-prev-prior">7.1.8.3. Comparison to the prior Function</a></span></dt></dl></dd><dt><span class="sect2"><a href="#epl-single-row-function-ref-prior">7.1.9. The Prior Function</a></span></dt></dl></dd><dt><span class="sect1"><a href="#epl-function-aggregation">7.2. Aggregate Functions</a></span></dt><dt><span class="sect1"><a href="#epl-function-user-defined">7.3. User-Defined Functions</a></span></dt></dl></dd><dt><span class="chapter"><a href="#epl-views">8. EPL Reference: Views</a></span></dt><dd><dl><dt><span class="sect1"><a href="#win-views">8.1. Window views</a></span></dt><dd><dl><dt><span class="sect2"><a href="#view-win-length">8.1.1. Length window (win:length)</a></span></dt><dt><span class="sect2"><a href="#view-win-length-batch">8.1.2. Length batch window (win:length_batch)</a></span></dt><dt><span class="sect2"><a href="#view-win-time">8.1.3. Time window (win:time)</a></span></dt><dt><span class="sect2"><a href="#view-win-ext_time">8.1.4. Externally-timed window (win:ext_timed)</a></span></dt><dt><span class="sect2"><a href="#view-win-time-batch">8.1.5. Time batch window (win:time_batch)</a></span></dt><dt><span class="sect2"><a href="#view-win-time-length-batch">8.1.6. Time-Length combination batch window (win:time_length_batch)</a></span></dt><dt><span class="sect2"><a href="#view-win-time-accumulating">8.1.7. Time-Accumulating window (win:time_accum)</a></span></dt><dt><span class="sect2"><a href="#view-win-keepall">8.1.8. Keep-All window (win:keepall)</a></span></dt><dt><span class="sect2"><a href="#view-win-firstlength">8.1.9. First Length (win:firstlength)</a></span></dt><dt><span class="sect2"><a href="#view-win-firsttime">8.1.10. First Time (win:firsttime)</a></span></dt></dl></dd><dt><span class="sect1"><a href="#std-views">8.2. Standard view set</a></span></dt><dd><dl><dt><span class="sect2"><a href="#view-std-unique">8.2.1. Unique (std:unique)</a></span></dt><dt><span class="sect2"><a href="#view-std-groupby">8.2.2. Group-By (std:groupby)</a></span></dt><dt><span class="sect2"><a href="#view-std-size">8.2.3. Size (std:size)</a></span></dt><dt><span class="sect2"><a href="#view-std-last">8.2.4. Last Event (std:lastevent)</a></span></dt><dt><span class="sect2"><a href="#view-std-first">8.2.5. First Event (std:firstevent)</a></span></dt><dt><span class="sect2"><a href="#view-std-firstunique">8.2.6. First Unique (std:firstunique)</a></span></dt></dl></dd><dt><span class="sect1"><a href="#stat-views">8.3. Statistics views</a></span></dt><dd><dl><dt><span class="sect2"><a href="#view-stat-uni">8.3.1. Univariate statistics (stat:uni)</a></span></dt><dt><span class="sect2"><a href="#view-stat-linest">8.3.2. Regression (stat:linest)</a></span></dt><dt><span class="sect2"><a href="#view-stat-correl">8.3.3. Correlation (stat:correl)</a></span></dt><dt><span class="sect2"><a href="#view-stat-weightedavg">8.3.4. Weighted average (stat:weighted_avg)</a></span></dt></dl></dd><dt><span class="sect1"><a href="#ext-views">8.4. Extension View Set</a></span></dt><dd><dl><dt><span class="sect2"><a href="#view-ext-sort">8.4.1. Sorted Window View (ext:sort)</a></span></dt><dt><span class="sect2"><a href="#view-time-order">8.4.2. Time-Order View (ext:time_order)</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#api">9. API Reference</a></span></dt><dd><dl><dt><span class="sect1"><a href="#api-reference-intro">9.1. API Overview</a></span></dt><dt><span class="sect1"><a href="#api-engine-instances">9.2. The Service Provider Interface</a></span></dt><dt><span class="sect1"><a href="#api-administrative">9.3. The Administrative Interface</a></span></dt><dd><dl><dt><span class="sect2"><a href="#api-admin-creating">9.3.1. Creating Statements</a></span></dt><dt><span class="sect2"><a href="#api-receive-results">9.3.2. Receiving Statement Results</a></span></dt><dt><span class="sect2"><a href="#api-admin-subscriber">9.3.3. Setting a Subscriber Object</a></span></dt><dd><dl><dt><span class="sect3"><a href="#api-admin-subscriber-rowbyrow">9.3.3.1. Row-By-Row Delivery</a></span></dt><dt><span class="sect3"><a href="#api-admin-subscriber-multirow">9.3.3.2. Multi-Row Delivery</a></span></dt></dl></dd><dt><span class="sect2"><a href="#api-admin-listeners">9.3.4. Adding Listeners</a></span></dt><dd><dl><dt><span class="sect3"><a href="#api-admin-listeners-replay">9.3.4.1. Subscription Snapshot  and Atomic Delivery</a></span></dt></dl></dd><dt><span class="sect2"><a href="#api-admin-iterators">9.3.5. Using Iterators</a></span></dt><dt><span class="sect2"><a href="#api-admin-mgmt-stmt">9.3.6. Managing Statements</a></span></dt><dt><span class="sect2"><a href="#api-admin-runtime-config">9.3.7. Runtime Configuration</a></span></dt></dl></dd><dt><span class="sect1"><a href="#api-runtime">9.4. The Runtime Interface</a></span></dt><dd><dl><dt><span class="sect2"><a href="#api-runtime-eventsender">9.4.1. Event Sender</a></span></dt><dt><span class="sect2"><a href="#api-runtime-unmatched">9.4.2. Receiving Unmatched Events</a></span></dt><dt><span class="sect2"><a href="#api-runtime-ondemand">9.4.3. On-Demand Snapshot Query Execution</a></span></dt><dd><dl><dt><span class="sect3"><a href="#api-runtime-ondemand-use">9.4.3.1. On-Demand Query API</a></span></dt></dl></dd></dl></dd><dt><span class="sect1"><a href="#api-event">9.5. Event and Event Type</a></span></dt><dd><dl><dt><span class="sect2"><a href="#api-eventtype">9.5.1. Event Type Metadata</a></span></dt><dt><span class="sect2"><a href="#api-eventbean">9.5.2. Event Object</a></span></dt><dt><span class="sect2"><a href="#api-eventtype-query">9.5.3. Query Example</a></span></dt><dt><span class="sect2"><a href="#api-eventtype-pattern">9.5.4. Pattern Example</a></span></dt></dl></dd><dt><span class="sect1"><a href="#api-threading">9.6. Engine Threading and Concurrency</a></span></dt><dd><dl><dt><span class="sect2"><a href="#api-threading-advanced">9.6.1. Advanced Threading</a></span></dt><dd><dl><dt><span class="sect3"><a href="#api-threading-advanced-inbound">9.6.1.1. Inbound Threading</a></span></dt><dt><span class="sect3"><a href="#api-threading-advanced-outbound">9.6.1.2. Outbound Threading</a></span></dt><dt><span class="sect3"><a href="#api-threading-advanced-timer-exec">9.6.1.3. Timer Execution Threading</a></span></dt><dt><span class="sect3"><a href="#api-threading-advanced-route-exec">9.6.1.4. Route Execution Threading</a></span></dt><dt><span class="sect3"><a href="#api-threading-management">9.6.1.5. Threading Service Provider Interface</a></span></dt></dl></dd></dl></dd><dt><span class="sect1"><a href="#api-controlling-time">9.7. Controlling Time-Keeping</a></span></dt><dt><span class="sect1"><a href="#api-time-resolution">9.8. Time Resolution</a></span></dt><dt><span class="sect1"><a href="#api-soda">9.9. Statement Object Model</a></span></dt><dd><dl><dt><span class="sect2"><a href="#api-soda-building-step1">9.9.1. Building an Object Model</a></span></dt><dt><span class="sect2"><a href="#api-soda-building-step2">9.9.2. Building Expressions</a></span></dt><dt><span class="sect2"><a href="#api-soda-building-step3">9.9.3. Building a Pattern Statement</a></span></dt><dt><span class="sect2"><a href="#api-soda-building-step4">9.9.4. Building a Select Statement</a></span></dt><dt><span class="sect2"><a href="#api-soda-building-step5">9.9.5. Building a Create-Variable and On-Set Statement</a></span></dt><dt><span class="sect2"><a href="#api-soda-building-step6">9.9.6. Building Create-Window, On-Delete and On-Select Statements</a></span></dt></dl></dd><dt><span class="sect1"><a href="#api-prepared">9.10. Prepared Statement and Substitution Parameters</a></span></dt><dt><span class="sect1"><a href="#api-instrumentation">9.11. Engine and Statement Metrics Reporting</a></span></dt><dd><dl><dt><span class="sect2"><a href="#api-instrumentation-enginemetrics">9.11.1. Engine Metrics</a></span></dt><dt><span class="sect2"><a href="#api-instrumentation-statementmetrics">9.11.2. Statement Metrics</a></span></dt></dl></dd><dt><span class="sect1"><a href="#api-output-rendering">9.12. Event Rendering to XML and JSON</a></span></dt><dd><dl><dt><span class="sect2"><a href="#api-output-rendering-json">9.12.1. JSON Event Rendering Conventions and Options</a></span></dt><dt><span class="sect2"><a href="#api-output-rendering-xml">9.12.2. XML Event Rendering Conventions and Options</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#configuration">10. Configuration</a></span></dt><dd><dl><dt><span class="sect1"><a href="#configuration-programmatic">10.1. Programmatic Configuration</a></span></dt><dt><span class="sect1"><a href="#configuration-via-xml">10.2. Configuration via XML File</a></span></dt><dt><span class="sect1"><a href="#configuration-xml">10.3. XML Configuration File</a></span></dt><dt><span class="sect1"><a href="#configuration-items">10.4. Configuration Items</a></span></dt><dd><dl><dt><span class="sect2"><a href="#config-java">10.4.1. Events represented by Java Classes</a></span></dt><dd><dl><dt><span class="sect3"><a href="#config-java-package-alias">10.4.1.1. Package of Java Event Classes</a></span></dt><dt><span class="sect3"><a href="#config-java-event-name">10.4.1.2. Event type name to Java class mapping</a></span></dt><dt><span class="sect3"><a href="#config-java-legacy">10.4.1.3. Non-JavaBean and Legacy Java Event Classes</a></span></dt><dt><span class="sect3"><a href="#config-java-spec-properties">10.4.1.4. Specifying Event Properties for Java Classes</a></span></dt><dt><span class="sect3"><a href="#config-java-codegen">10.4.1.5. Turning off Code Generation</a></span></dt><dt><span class="sect3"><a href="#config-java-property-case-sensitivity">10.4.1.6. Case Sensitivity and Property Names</a></span></dt></dl></dd><dt><span class="sect2"><a href="#config-java-util-map">10.4.2. Events represented by java.util.Map</a></span></dt><dt><span class="sect2"><a href="#config-xml-dom">10.4.3. Events represented by org.w3c.dom.Node</a></span></dt><dd><dl><dt><span class="sect3"><a href="#config-xml-dom-schema">10.4.3.1. Schema Resource</a></span></dt><dt><span class="sect3"><a href="#config-xml-dom-xpathprop">10.4.3.2. Explicit XPath Property</a></span></dt><dt><span class="sect3"><a href="#config-xml-dom-absolute">10.4.3.3. Absolute or Deep Property Resolution</a></span></dt><dt><span class="sect3"><a href="#config-xml-dom-xpathresolver">10.4.3.4. XPath Variable and Function Resolver</a></span></dt><dt><span class="sect3"><a href="#config-xml-dom-autofragment">10.4.3.5. Auto Fragment</a></span></dt><dt><span class="sect3"><a href="#config-xml-dom-xpathpropertyexpr">10.4.3.6. XPath Property Expression</a></span></dt><dt><span class="sect3"><a href="#config-xml-dom-eventsendervalidatesroot">10.4.3.7. Event Sender Setting</a></span></dt></dl></dd><dt><span class="sect2"><a href="#config-plugineventrep">10.4.4. Events represented by Plug-in Event Representations</a></span></dt><dd><dl><dt><span class="sect3"><a href="#config-plugineventrep-enable">10.4.4.1. Enabling an Custom Event Representation</a></span></dt><dt><span class="sect3"><a href="#config-plugineventrep-types">10.4.4.2. Adding Plug-in Event Types</a></span></dt><dt><span class="sect3"><a href="#config-plugineventrep-resolution">10.4.4.3. Setting Resolution URIs</a></span></dt></dl></dd><dt><span class="sect2"><a href="#config-class--package-imports">10.4.5. Class and package imports</a></span></dt><dt><span class="sect2"><a href="#config-method-invocations">10.4.6. Cache Settings for From-Clause Method Invocations</a></span></dt><dt><span class="sect2"><a href="#config-variables">10.4.7. Variables</a></span></dt><dt><span class="sect2"><a href="#config-database-ref">10.4.8. Relational Database Access</a></span></dt><dd><dl><dt><span class="sect3"><a href="#config-database-datasource">10.4.8.1. Connections obtained via DataSource</a></span></dt><dt><span class="sect3"><a href="#config-database-datasourcefactory">10.4.8.2. Connections obtained via DataSource Factory</a></span></dt><dt><span class="sect3"><a href="#config-database-drivermanager">10.4.8.3. Connections obtained via DriverManager</a></span></dt><dt><span class="sect3"><a href="#config-database-connections">10.4.8.4. Connections-level settings</a></span></dt><dt><span class="sect3"><a href="#config-database-connections-lifecycle">10.4.8.5. Connections lifecycle settings</a></span></dt><dt><span class="sect3"><a href="#config-database-cache">10.4.8.6. Cache settings</a></span></dt><dt><span class="sect3"><a href="#config-database-columnchangecase">10.4.8.7. Column Change Case</a></span></dt><dt><span class="sect3"><a href="#config-database-sqltypes">10.4.8.8. SQL Types Mapping</a></span></dt><dt><span class="sect3"><a href="#config-database-metadata">10.4.8.9. Metadata Origin</a></span></dt></dl></dd><dt><span class="sect2"><a href="#config-engine-threading">10.4.9. Engine Settings related to Concurrency and Threading</a></span></dt><dd><dl><dt><span class="sect3"><a href="#config-engine-threading-dispatch">10.4.9.1. Preserving the order of events delivered to listeners</a></span></dt><dt><span class="sect3"><a href="#config-engine-threading-insert-into">10.4.9.2. Preserving the order of events for insert-into streams</a></span></dt><dt><span class="sect3"><a href="#config-engine-threading-internal-timer">10.4.9.3. Internal Timer Settings</a></span></dt><dt><span class="sect3"><a href="#config-engine-threading-advanced">10.4.9.4. Advanced Threading Options</a></span></dt></dl></dd><dt><span class="sect2"><a href="#config-engine-eventmeta">10.4.10. Engine Settings related to Event Metadata</a></span></dt><dd><dl><dt><span class="sect3"><a href="#config-engine-eventmeta-propertyreso">10.4.10.1. Java Class Property Names and Case Sensitivity</a></span></dt></dl></dd><dt><span class="sect2"><a href="#config-engine-viewresources">10.4.11. Engine Settings related to View Resources</a></span></dt><dd><dl><dt><span class="sect3"><a href="#config-engine-viewresources-sharing">10.4.11.1. Sharing View Resources between Statements</a></span></dt><dt><span class="sect3"><a href="#config-engine-viewresources-multipolicy">10.4.11.2. Configuring Multi-Expiry Policy Defaults</a></span></dt></dl></dd><dt><span class="sect2"><a href="#config-engine-logging">10.4.12. Engine Settings related to Logging</a></span></dt><dd><dl><dt><span class="sect3"><a href="#config-engine-logging-execpath">10.4.12.1. Execution Path Debug Logging</a></span></dt></dl></dd><dt><span class="sect2"><a href="#config-engine-variables">10.4.13. Engine Settings related to Variables</a></span></dt><dd><dl><dt><span class="sect3"><a href="#config-engine-variables-lifetimeold">10.4.13.1. Variable Version Release Interval</a></span></dt></dl></dd><dt><span class="sect2"><a href="#config-engine-stream-selection">10.4.14. Engine Settings related to Stream Selection</a></span></dt><dd><dl><dt><span class="sect3"><a href="#config-engine-streamselect-choices">10.4.14.1. Default Statement Stream Selection</a></span></dt></dl></dd><dt><span class="sect2"><a href="#config-engine-time-source">10.4.15. Engine Settings related to Time Source</a></span></dt><dd><dl><dt><span class="sect3"><a href="#config-engine-timesource-choices">10.4.15.1. Default Time Source</a></span></dt></dl></dd><dt><span class="sect2"><a href="#config-engine-instrumentation">10.4.16. Engine Settings related to Metrics Reporting</a></span></dt><dt><span class="sect2"><a href="#config-engine-language">10.4.17. Engine Settings related to Language and Locale</a></span></dt><dt><span class="sect2"><a href="#config-engine-expression">10.4.18. Engine Settings related to Expression Evaluation</a></span></dt><dd><dl><dt><span class="sect3"><a href="#config-engine-expression-division">10.4.18.1. Integer Division and Division by Zero</a></span></dt><dt><span class="sect3"><a href="#config-engine-expression-subselecteval">10.4.18.2. Subselect Evaluation Order</a></span></dt><dt><span class="sect3"><a href="#config-engine-expression-udfcache">10.4.18.3. User-Defined Function or Static Method Cache</a></span></dt></dl></dd><dt><span class="sect2"><a href="#config-engine-execution">10.4.19. Engine Settings related to Execution of Statements</a></span></dt><dd><dl><dt><span class="sect3"><a href="#config-engine-execution-prioritized">10.4.19.1. Prioritized Execution</a></span></dt></dl></dd><dt><span class="sect2"><a href="#config-revisionevent">10.4.20. Revision Event Type</a></span></dt><dt><span class="sect2"><a href="#config-variantstream">10.4.21. Variant Stream</a></span></dt></dl></dd><dt><span class="sect1"><a href="#configuration-type-names">10.5. Type Names</a></span></dt><dt><span class="sect1"><a href="#configuration-runtime">10.6. Runtime Configuration</a></span></dt></dl></dd><dt><span class="chapter"><a href="#extension">11. Extension and Plug-in</a></span></dt><dd><dl><dt><span class="sect1"><a href="#custom-views">11.1. Custom View Implementation</a></span></dt><dd><dl><dt><span class="sect2"><a href="#custom-views-viewfactory">11.1.1. Implementing a View Factory</a></span></dt><dt><span class="sect2"><a href="#custom-views-view">11.1.2. Implementing a View</a></span></dt><dt><span class="sect2"><a href="#custom-views-contract">11.1.3. View Contract</a></span></dt><dt><span class="sect2"><a href="#custom-views-config">11.1.4. Configuring View Namespace and Name</a></span></dt><dt><span class="sect2"><a href="#custom-views-datawin">11.1.5. Requirement for Data Window Views</a></span></dt><dt><span class="sect2"><a href="#custom-views-grouped">11.1.6. Requirement for Grouped Views</a></span></dt></dl></dd><dt><span class="sect1"><a href="#custom-aggregation-function">11.2. Custom Aggregation Functions</a></span></dt><dd><dl><dt><span class="sect2"><a href="#custom-aggregation-implementing">11.2.1. Implementing an Aggregation Function</a></span></dt><dt><span class="sect2"><a href="#custom-aggregation-config">11.2.2. Configuring Aggregation Function Name</a></span></dt><dt><span class="sect2"><a href="#custom-aggregation-multiparam">11.2.3. Accepting Multiple Parameters</a></span></dt></dl></dd><dt><span class="sect1"><a href="#custom-pattern-guard">11.3. Custom Pattern Guard</a></span></dt><dd><dl><dt><span class="sect2"><a href="#custom-pattern-guard-factory-implementing">11.3.1. Implementing a Guard Factory</a></span></dt><dt><span class="sect2"><a href="#custom-pattern-guard-implementing">11.3.2. Implementing a Guard Class</a></span></dt><dt><span class="sect2"><a href="#custom-pattern-guard-config">11.3.3. Configuring Guard Namespace and Name</a></span></dt></dl></dd><dt><span class="sect1"><a href="#custom-pattern-observer">11.4. Custom Pattern Observer</a></span></dt><dd><dl><dt><span class="sect2"><a href="#custom-pattern-observer-factory-implementing">11.4.1. Implementing an Observer Factory</a></span></dt><dt><span class="sect2"><a href="#custom-pattern-observer-implementing">11.4.2. Implementing an Observer Class</a></span></dt><dt><span class="sect2"><a href="#custom-pattern-observer-config">11.4.3. Configuring Observer Namespace and Name</a></span></dt></dl></dd><dt><span class="sect1"><a href="#custom-event-representation">11.5. Custom Event Representation</a></span></dt><dd><dl><dt><span class="sect2"><a href="#custom-eventrep-overview">11.5.1. How It Works</a></span></dt><dt><span class="sect2"><a href="#custom-eventrep-steps">11.5.2. Steps</a></span></dt><dt><span class="sect2"><a href="#custom-eventrep-uriresolution">11.5.3. URI-based Resolution</a></span></dt><dt><span class="sect2"><a href="#custom-eventrep-example">11.5.4. Example</a></span></dt><dd><dl><dt><span class="sect3"><a href="#custom-eventrep-example-eventtype">11.5.4.1. Sample Event Type</a></span></dt><dt><span class="sect3"><a href="#custom-eventrep-example-eventbean">11.5.4.2. Sample Event Bean</a></span></dt><dt><span class="sect3"><a href="#custom-eventrep-example-eventrep">11.5.4.3. Sample Event Representation</a></span></dt><dt><span class="sect3"><a href="#custom-eventrep-example-eventbeanfac">11.5.4.4. Sample Event Bean Factory</a></span></dt></dl></dd></dl></dd></dl></dd><dt><span class="chapter"><a href="#examples">12. Examples, Tutorials, Case Studies</a></span></dt><dd><dl><dt><span class="sect1"><a href="#examples-overview">12.1. Examples Overview</a></span></dt><dt><span class="sect1"><a href="#examples-running">12.2. Running the Examples</a></span></dt><dt><span class="sect1"><a href="#examples-autoid">12.3. AutoID RFID Reader</a></span></dt><dt><span class="sect1"><a href="#examples-servershell">12.4. JMS Server Shell and Client</a></span></dt><dd><dl><dt><span class="sect2"><a href="#examples-servershell-processes">12.4.1. Overview</a></span></dt><dt><span class="sect2"><a href="#examples-servershell-jmsevents">12.4.2. JMS Messages as Events</a></span></dt><dt><span class="sect2"><a href="#examples-servershell-jmx">12.4.3. JMX for Remote Dynamic Statement Management</a></span></dt></dl></dd><dt><span class="sect1"><a href="#examples-marketdata-monitor">12.5. Market Data Feed Monitor</a></span></dt><dd><dl><dt><span class="sect2"><a href="#examples-marketdata-monitor-input">12.5.1. Input Events</a></span></dt><dt><span class="sect2"><a href="#examples-marketdata-computing">12.5.2. Computing Rates Per Feed</a></span></dt><dt><span class="sect2"><a href="#examples-marketdata-falloff">12.5.3. Detecting a Fall-off</a></span></dt><dt><span class="sect2"><a href="#examples-marketdata-monitor-sim">12.5.4. Event generator</a></span></dt></dl></dd><dt><span class="sect1"><a href="#examples-ohlcpluginview">12.6. OHLC Plug-in View</a></span></dt><dt><span class="sect1"><a href="#examples-transaction-3-event-challenge">12.7. Transaction 3-Event Challenge</a></span></dt><dd><dl><dt><span class="sect2"><a href="#examples-txn3event-1">12.7.1. The Events</a></span></dt><dt><span class="sect2"><a href="#examples-txn3event-2">12.7.2. Combined event</a></span></dt><dt><span class="sect2"><a href="#examples-txn3event-3">12.7.3. Real time summary data</a></span></dt><dt><span class="sect2"><a href="#examples-txn3event-4">12.7.4. Find problems</a></span></dt><dt><span class="sect2"><a href="#examples-txn3event-5">12.7.5. Event generator</a></span></dt></dl></dd><dt><span class="sect1"><a href="#examples-terminalsvc-J2EE">12.8. Self-Service Terminal</a></span></dt><dd><dl><dt><span class="sect2"><a href="#examples-terminalsvc-events">12.8.1. Events</a></span></dt><dt><span class="sect2"><a href="#examples-terminalsvc-pattern1">12.8.2. Detecting Customer Check-in Issues</a></span></dt><dt><span class="sect2"><a href="#examples-terminalsvc-pattern2">12.8.3. Absence of Status Events</a></span></dt><dt><span class="sect2"><a href="#examples-terminalsvc-epl1">12.8.4. Activity Summary Data</a></span></dt><dt><span class="sect2"><a href="#examples-terminalsvc-j2ee">12.8.5. Sample Application for J2EE Application Server</a></span></dt><dd><dl><dt><span class="sect3"><a href="#examples-terminalsvc-j2ee-running">12.8.5.1. Running the Example</a></span></dt><dt><span class="sect3"><a href="#examples-terminalsvc-j2ee-building">12.8.5.2. Building the Example</a></span></dt><dt><span class="sect3"><a href="#examples-terminalsvc-j2ee-running-sim">12.8.5.3. Running the Event Simulator and Receiver</a></span></dt></dl></dd></dl></dd><dt><span class="sect1"><a href="#examples-assets-moving">12.9. Assets Moving Across Zones - An RFID Example</a></span></dt><dt><span class="sect1"><a href="#examples-stockticker">12.10. StockTicker</a></span></dt><dt><span class="sect1"><a href="#examples-matchmaker">12.11. MatchMaker</a></span></dt><dt><span class="sect1"><a href="#examples-namedwindowquery">12.12. Named Window Query</a></span></dt><dt><span class="sect1"><a href="#examples-qossla">12.13. Quality of Service</a></span></dt></dl></dd><dt><span class="chapter"><a href="#performance">13. Performance</a></span></dt><dd><dl><dt><span class="sect1"><a href="#performance-results">13.1. Performance Results</a></span></dt><dt><span class="sect1"><a href="#performance-tips">13.2. Performance Tips</a></span></dt><dd><dl><dt><span class="sect2"><a href="#perf-tips-1">13.2.1. Understand how to tune your Java virtual machine</a></span></dt><dt><span class="sect2"><a href="#perf-tips-2">13.2.2. Compare Esper to other solutions</a></span></dt><dt><span class="sect2"><a href="#perf-tips-3">13.2.3. Input and Output Bottlenecks</a></span></dt><dt><span class="sect2"><a href="#perf-tips-3-a">13.2.4. Advanced Theading</a></span></dt><dt><span class="sect2"><a href="#perf-tips-4">13.2.5. Select the underlying event rather than individual fields</a></span></dt><dt><span class="sect2"><a href="#perf-tips-5">13.2.6. Prefer stream-level filtering over post-data-window filtering</a></span></dt><dt><span class="sect2"><a href="#perf-tips-6">13.2.7. Reduce the use of arithmetic in expressions</a></span></dt><dt><span class="sect2"><a href="#perf-tips-7">13.2.8. Consider using EventPropertyGetter for fast access to event properties</a></span></dt><dt><span class="sect2"><a href="#perf-tips-8">13.2.9. Consider casting the underlying event</a></span></dt><dt><span class="sect2"><a href="#perf-tips-9">13.2.10. Turn off logging</a></span></dt><dt><span class="sect2"><a href="#perf-tips-10">13.2.11. Disable view sharing</a></span></dt><dt><span class="sect2"><a href="#perf-tips-11">13.2.12. Tune or disable delivery order guarantees</a></span></dt><dt><span class="sect2"><a href="#perf-tips-12">13.2.13. Use a Subscriber Object to Receive Events</a></span></dt><dt><span class="sect2"><a href="#perf-tips-13">13.2.14. High-Arrival-Rate Streams and Single Statements</a></span></dt><dt><span class="sect2"><a href="#perf-tips-14">13.2.15. Performance, JVM, OS and hardware</a></span></dt></dl></dd><dt><span class="sect1"><a href="#performance-kit">13.3. Using the performance kit</a></span></dt><dd><dl><dt><span class="sect2"><a href="#how-to-kit">13.3.1. How to use the performance kit</a></span></dt><dt><span class="sect2"><a href="#how-we-kit">13.3.2. How we use the performance kit</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#references">14. References</a></span></dt><dd><dl><dt><span class="sect1"><a href="#references-listing">14.1. Reference List</a></span></dt></dl></dd><dt><span class="appendix"><a href="#appendix_outputspec">A. Output Reference and Samples</a></span></dt><dd><dl><dt><span class="sect1"><a href="#outputspec-intro">A.1. Introduction and Sample Data</a></span></dt><dt><span class="sect1"><a href="#outputspec-simple">A.2. Output for Un-aggregated and Un-grouped Queries</a></span></dt><dd><dl><dt><span class="sect2"><a href="#outputspec-simple-none">A.2.1. No Output Rate Limiting</a></span></dt><dt><span class="sect2"><a href="#outputspec-simple-default">A.2.2. Output Rate Limiting - Default</a></span></dt><dt><span class="sect2"><a href="#outputspec-simple-last">A.2.3. Output Rate Limiting - Last</a></span></dt><dt><span class="sect2"><a href="#outputspec-simple-first">A.2.4. Output Rate Limiting - First</a></span></dt><dt><span class="sect2"><a href="#outputspec-simple-snapshot">A.2.5. Output Rate Limiting - Snapshot</a></span></dt></dl></dd><dt><span class="sect1"><a href="#outputspec-rowforall">A.3. Output for Fully-aggregated and Un-grouped Queries</a></span></dt><dd><dl><dt><span class="sect2"><a href="#outputspec-rowforall-none">A.3.1. No Output Rate Limiting</a></span></dt><dt><span class="sect2"><a href="#outputspec-rowforall-default">A.3.2. Output Rate Limiting - Default</a></span></dt><dt><span class="sect2"><a href="#outputspec-rowforall-last">A.3.3. Output Rate Limiting - Last</a></span></dt><dt><span class="sect2"><a href="#outputspec-rowforall-first">A.3.4. Output Rate Limiting - First</a></span></dt><dt><span class="sect2"><a href="#outputspec-rowforall-snapshot">A.3.5. Output Rate Limiting - Snapshot</a></span></dt></dl></dd><dt><span class="sect1"><a href="#outputspec-aggregateall">A.4. Output for Aggregated and Un-grouped Queries</a></span></dt><dd><dl><dt><span class="sect2"><a href="#outputspec-aggregateall-none">A.4.1. No Output Rate Limiting</a></span></dt><dt><span class="sect2"><a href="#outputspec-aggregateall-default">A.4.2. Output Rate Limiting - Default</a></span></dt><dt><span class="sect2"><a href="#outputspec-aggregateall-last">A.4.3. Output Rate Limiting - Last</a></span></dt><dt><span class="sect2"><a href="#outputspec-aggregateall-first">A.4.4. Output Rate Limiting - First</a></span></dt><dt><span class="sect2"><a href="#outputspec-aggregateall-snapshot">A.4.5. Output Rate Limiting - Snapshot</a></span></dt></dl></dd><dt><span class="sect1"><a href="#outputspec-groupedrowpergroup">A.5. Output for Fully-aggregated and Grouped Queries</a></span></dt><dd><dl><dt><span class="sect2"><a href="#outputspec-groupedrowpergroup-none">A.5.1. No Output Rate Limiting</a></span></dt><dt><span class="sect2"><a href="#outputspec-groupedrowpergroup-default">A.5.2. Output Rate Limiting - Default</a></span></dt><dt><span class="sect2"><a href="#outputspec-groupedrowpergroup-all">A.5.3. Output Rate Limiting - All</a></span></dt><dt><span class="sect2"><a href="#outputspec-groupedrowpergroup-last">A.5.4. Output Rate Limiting - Last</a></span></dt><dt><span class="sect2"><a href="#outputspec-groupedrowpergroup-first">A.5.5. Output Rate Limiting - First</a></span></dt><dt><span class="sect2"><a href="#outputspec-groupedrowpergroup-snapshot">A.5.6. Output Rate Limiting - Snapshot</a></span></dt></dl></dd><dt><span class="sect1"><a href="#outputspec-aggregategrouped">A.6. Output for Aggregated and Grouped Queries</a></span></dt><dd><dl><dt><span class="sect2"><a href="#outputspec-aggregategrouped-none">A.6.1. No Output Rate Limiting</a></span></dt><dt><span class="sect2"><a href="#outputspec-aggregategrouped-default">A.6.2. Output Rate Limiting - Default</a></span></dt><dt><span class="sect2"><a href="#outputspec-aggregategrouped-all">A.6.3. Output Rate Limiting - All</a></span></dt><dt><span class="sect2"><a href="#outputspec-aggregategrouped-last">A.6.4. Output Rate Limiting - Last</a></span></dt><dt><span class="sect2"><a href="#outputspec-aggregategrouped-first">A.6.5. Output Rate Limiting - First</a></span></dt><dt><span class="sect2"><a href="#outputspec-aggregategrouped-snapshot">A.6.6. Output Rate Limiting - Snapshot</a></span></dt></dl></dd></dl></dd><dt><span class="appendix"><a href="#appendix_keywords">B. Reserved Keywords</a></span></dt><dt><span class="index"><a href="#d0e22076">Index</a></span></dt></dl></div><div class="preface" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="preface"></a>Preface</h2></div></div><div></div></div><p>
			Analyzing and reacting to information in real-time oftentimes requires the development of custom applications.
			Typically these applications must obtain the data to analyze, filter data, derive information and then indicate 
			this information through some form of presentation or communication. Data may arrive with high frequency
			requiring high throughput processing. And applications may need to be flexible and react to changes in requirements 
			while the data is processed. Esper is an event stream processor that aims to enable a short development cycle from inception to production 
			for these types of applications.
        </p><p>
			This document is a resource for software developers who develop event driven applications. It also contains information that is useful for business analysts and system architects who are evaluating Esper.
        </p><p>
			It is assumed that the reader is familiar with the Java programming language.
        </p><p>
			This document is relevant in all phases of your software development project: from design to deployment and support.
        </p><p>
			If you are new to Esper, please follow these steps:
		</p><div class="orderedlist"><ol type="1"><li><p>
                    Read the tutorials, case studies and solution patterns available on the Esper public web site at <tt class="literal">http://esper.codehaus.org</tt>
                </p></li><li><p>
                    Read <a href="#technology_overview_intro_cep" title="1.1.&nbsp;Introduction to CEP and event stream analysis">Section&nbsp;1.1, &#8220;Introduction to CEP and event stream analysis&#8221;</a> if you are new to CEP and ESP (complex event processing, event stream processing)
                </p></li><li><p>
                    Read <a href="#event_representation" title="Chapter&nbsp;2.&nbsp;Event Representations">Chapter&nbsp;2, <i>Event Representations</i></a> that explains the different ways of representing events to Esper
                </p></li><li><p>
                    Read <a href="#processingmodel" title="Chapter&nbsp;3.&nbsp;Processing Model">Chapter&nbsp;3, <i>Processing Model</i></a> to gain insight into EPL continuous query results
                </p></li><li><p>
                    Read <a href="#epl-intro" title="4.1.&nbsp;EPL Introduction">Section&nbsp;4.1, &#8220;EPL Introduction&#8221;</a> for an introduction to event stream processing via EPL
                </p></li><li><p>
                    Read <a href="#event-pattern-intro" title="5.1.&nbsp;Event Pattern Overview">Section&nbsp;5.1, &#8220;Event Pattern Overview&#8221;</a> for an overview over event patterns
                </p></li><li><p>
                    Then glance over the examples <a href="#examples-overview" title="12.1.&nbsp;Examples Overview">Section&nbsp;12.1, &#8220;Examples Overview&#8221;</a>
                </p></li><li><p>
                    Finally to test drive Esper performance, read <a href="#performance" title="Chapter&nbsp;13.&nbsp;Performance">Chapter&nbsp;13, <i>Performance</i></a>
                </p></li></ol></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="technology_overview"></a>Chapter&nbsp;1.&nbsp;Technology Overview</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="technology_overview_intro_cep"></a>1.1.&nbsp;Introduction to CEP and event stream analysis</h2></div></div><div></div></div><p>
			The Esper engine has been developed to address the requirements of applications that analyze and react to events. Some typical examples of applications are:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
					Business process management and automation (process monitoring, BAM, reporting exceptions) 
				</p></li><li><p>
					Finance (algorithmic trading, fraud detection, risk management)
				</p></li><li><p>
					Network and application monitoring (intrusion detection, SLA monitoring)
				</p></li><li><p>
					Sensor network applications (RFID reading, scheduling and control of fabrication lines, air traffic) 
				</p></li></ul></div><p>
			What these applications have in common is the requirement to process events (or messages) in real-time or near real-time. This is sometimes referred to as complex event processing (CEP) and event stream analysis. Key considerations for these types of applications are throughput, latency and the complexity of the logic required.
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
					High throughput - applications that process large volumes of messages (between 1,000 to 100k messages per second)
				</p></li><li><p>
					Low latency - applications that react in real-time to conditions that occur (from a few milliseconds to a few seconds)
				</p></li><li><p>
					Complex computations - applications that detect patterns among events (event correlation), filter events, aggregate time or length windows of events, join event streams, trigger based on absence of events etc.
				</p></li></ul></div><p>
			The Esper engine was designed to make it easier to build and extend CEP applications. 
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="cep_and_relational"></a>1.2.&nbsp;CEP and relational databases</h2></div></div><div></div></div><p>
			Relational databases and the standard query language (SQL) are designed for applications in which most data is fairly static and complex queries are less frequent. Also, most databases store all data on disks (except for in-memory databases) and are therefore optimized for disk access.
        </p><p>
			To retrieve data from a database an application must issue a query. If an application need the data 10 times per second it must fire the query 10 times per second. This does not scale well to hundreds or thousands of queries per second. 
        </p><p>
			Database triggers can be used to fire in response to database update events. However database triggers tend to be slow and often cannot easily perform complex condition checking and implement logic to react.  
        </p><p>
			In-memory databases may be better suited to CEP applications then traditional relational database as they generally have good query performance. Yet they are not optimized to provide immediate, real-time query results required for CEP and event stream analysis. 
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="cep_with_esper"></a>1.3.&nbsp;The Esper engine for CEP</h2></div></div><div></div></div><p>
			The Esper engine works a bit like a database turned upside-down. Instead of storing the data and running queries against stored data, the Esper engine allows applications to store queries and run the data through. Response from the Esper engine is real-time when conditions occur that match queries. The execution model is thus continuous rather then only when a query is submitted.
        </p><p>
			Esper provides two principal methods or mechanisms to process events: event patterns and event stream queries. 
        </p><p>
			Esper offers an event pattern language to specify expression-based event pattern matching. Underlying the pattern matching engine is a state machine implementation. This method of event processing matches expected sequences of presence or absence of events or combinations of events. It includes time-based correlation of events.
		</p><p>
			Esper also offers event stream queries that address the event stream analysis requirements of CEP applications. Event stream queries provide the windows, aggregation, joining and analysis functions for use with streams of events. These queries are following the EPL syntax. EPL has been designed for similarity with the SQL query language but differs from SQL in its use of views rather then tables. Views represent the different operations needed to structure data in an event stream and to derive data from an event stream.
		</p><p>
			Esper provides these two methods as alternatives through the same API.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="required_3rd_party"></a>1.4.&nbsp;Required 3rd Party Libraries</h2></div></div><div></div></div><p>
            Esper requires the following 3rd-party libraries at runtime:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
					ANTLR is the parser generator used for parsing and parse tree walking of the pattern and EPL syntax. Credit goes to Terence Parr at http://www.antlr.org. The ANTLR license is in the lib directory. The library is required for compile-time only.
				</p></li><li><p>
					CGLIB is the code generation library for fast method calls. This open source software is under the Apache license. The Apache 2.0 license is in the lib directory.
				</p></li><li><p>
					LOG4J and Apache commons logging are logging components. This open source software is under the Apache license. The Apache 2.0 license is in the lib directory.
				</p></li></ul></div><p>
            Esper requires the following 3rd-party libraries at compile-time and for running the test suite:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
					JUnit is a great unit testing framework. Its license has also been placed in the lib directory. The library is required for build-time only.
				</p></li><li><p>
					MySQL connector library is used for testing SQL integration and is required for running the automated test suite.
				</p></li></ul></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="event_representation"></a>Chapter&nbsp;2.&nbsp;Event Representations</h2></div></div><div></div></div><p>
		This section outlines the different means to model and represent events.
    </p><p>
		Please see the <a href="#api-event" title="9.5.&nbsp;Event and Event Type">Section&nbsp;9.5, &#8220;Event and Event Type&#8221;</a> section for APIs.
    </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="eventrep_intro"></a>2.1.&nbsp;Event Underlying Java Objects</h2></div></div><div></div></div><a class="indexterm" name="d0e166"></a><p>
			An event is an immutable record of a past occurrence of an action or state change. Event properties capture the state information for an event.
        </p><p>
			In Esper, an event can be represented by any of the following underlying Java objects:
        </p><div class="table"><a name="d0e175"></a><p class="title"><b>Table&nbsp;2.1.&nbsp;Event Underlying Java Objects</b></p><table summary="Event Underlying Java Objects" border="1"><colgroup><col><col></colgroup><thead><tr><th>Java Class</th><th>Description</th></tr></thead><tbody><tr><td><tt class="literal">java.lang.Object</tt></td><td>Any Java POJO (plain-old java object) with getter methods following JavaBean conventions;  Legacy Java classes not following JavaBean conventions can also serve as events .</td></tr><tr><td><tt class="literal">java.util.Map</tt></td><td>Map events are key-values pairs and can also contain objects, further Map, and arrays thereof.</td></tr><tr><td><tt class="literal">org.w3c.dom.Node</tt></td><td>XML document object model (DOM).</td></tr><tr><td><tt class="literal">org.apache.axiom.om.OMDocument or OMElement</tt></td><td>XML - Streaming API for XML (StAX) - Apache Axiom (provided by EsperIO package).</td></tr><tr><td>Application classes</td><td>Plug-in event representation via the extension API.</td></tr></tbody></table></div><p>
			Esper provides multiple choices for representing an event. There is no absolute need for you to create new Java classes to represent an event.
		</p><p>
			Event representations have the following in common:
		</p><div class="itemizedlist"><ul type="disc" compact><li><p>
					All event representations support nested, indexed and mapped properties (aka. property expression), as explained in more detail below. There is no limitation to the nesting level.
				</p></li><li><p>
					All event representations provide event type metadata. This includes type metadata for nested properties.
				</p></li><li><p>
					All event representations allow transposing the event itself and parts of all of its property graph into new events. The term transposing refers to selecting the event itself or event properties that are themselves nestable property graphs, and then querying the event's properties or nested property graphs in further statements. The Apache Axiom event representation is an exception and does not currently allow transposing event properties but does allow transposing the event itself.
				</p></li><li><p>
					The Java object and Map representations allow supertypes.
				</p></li></ul></div><p>
			The API behavior for all event representations is the same, with minor exceptions noted in this chapter. 
		</p><p>
			The benefits of multiple event representations are:
		</p><div class="itemizedlist"><ul type="disc" compact><li><p>
					For applications that already have events in one of the supported representations, there is no need to transform events into a Java object before processing.
				</p></li><li><p>
					Event representations are exchangeable, reducing or eliminating the need to change statements when the event representation changes. 
				</p></li><li><p>
					Event representations are interoperable, allowing all event representations to interoperate in same or different statements.
				</p></li><li><p>
					The choice makes its possible to consciously trade-off performance, ease-of-use, the ability to evolve and effort needed to import or externalize events and use existing event type metadata. 
				</p></li></ul></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="eventrep-properties"></a>2.2.&nbsp;Event Properties</h2></div></div><div></div></div><a class="indexterm" name="d0e254"></a><p>
			 Event properties capture the state information for an event. Event properties be simple as well as indexed, mapped and nested event properties. The table below outlines the different types of properties and their syntax in an event expression. This syntax allows statements to query deep JavaBean objects graphs, XML structures and Map events. 
		</p><div class="table"><a name="d0e261"></a><p class="title"><b>Table&nbsp;2.2.&nbsp;Types of Event Properties</b></p><table summary="Types of Event Properties" border="1"><colgroup><col><col><col><col></colgroup><thead><tr><th>Type</th><th>Description</th><th>Syntax</th><th>Example</th></tr></thead><tbody><tr><td>Simple</td><td>A property that has a single value that may be retrieved.</td><td><pre class="synopsis">name</pre></td><td><pre class="synopsis">sensorId</pre></td></tr><tr><td>Indexed</td><td>An indexed property stores an ordered collection of objects (all of the same type) that can be individually accessed by an integer-valued, non-negative index (or subscript).</td><td><pre class="synopsis">name[<span class="emphasis"><em>index</em></span>]</pre></td><td><pre class="synopsis">sensor[0]</pre></td></tr><tr><td>Mapped</td><td>A mapped property stores a keyed collection of objects (all of the same type).</td><td><pre class="synopsis">name('<span class="emphasis"><em>key</em></span>')</pre></td><td><pre class="synopsis">sensor('light')</pre></td></tr><tr><td>Nested</td><td>A nested property is a property that lives within another property of an event.</td><td><pre class="synopsis">name.nestedname</pre></td><td><pre class="synopsis">sensor.value</pre></td></tr></tbody></table></div><p>
			Combinations are also possible. For example, a valid combination could be <tt class="literal">person.address('home').street[0]</tt>.
		</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="eventrep-properties-escaping"></a>2.2.1.&nbsp;Escape Characters</h3></div></div><div></div></div><p>
				If your application uses <tt class="literal">java.util.Map</tt> or XML to represent events, then event property names may themselves contain the dot ('.') character. The backslash ('\') character can be used to escape dot characters in property names, allowing a property name to contain dot characters. 
			</p><p>
				For example, the EPL as shown below expects a property by name <tt class="literal">part1.part2</tt> to exist on event type <tt class="literal">MyEvent</tt>:
			</p><pre class="programlisting">select part1\.part2 from MyEvent</pre><p>
				Sometimes your event properties may overlap with EPL language keywords. In this case you may use the backwards apostrophe <tt class="literal">`</tt> character to escape the property name.
			</p><p>
				The next example assumes a <tt class="literal">Quote</tt> event that has a property by name <tt class="literal">order</tt>, while <tt class="literal">order</tt> is also a reserved keyword:
			</p><pre class="programlisting">select `order` from Quote</pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="eventrep-dyncproperties"></a>2.3.&nbsp;Dynamic Event Properties</h2></div></div><div></div></div><a class="indexterm" name="d0e374"></a><a class="indexterm" name="d0e377"></a><p>
			Dynamic (unchecked) properties are event properties that need not be known at statement compilation time. Such properties are resolved during runtime: they provide duck typing functionality.
		</p><p>
			The idea behind dynamic properties is that for a given underlying event representation we don't always know all properties in advance. An underlying event may have additional properties that are not known at statement compilation time, that we want to query on. The concept is especially useful for events that represent rich, object-oriented domain models.
		</p><p>
			The syntax of dynamic properties consists of the property name and a question mark. Indexed, mapped and nested properties can also be dynamic properties:
		</p><div class="table"><a name="d0e388"></a><p class="title"><b>Table&nbsp;2.3.&nbsp;Types of Event Properties</b></p><table summary="Types of Event Properties" border="1"><colgroup><col><col></colgroup><thead><tr><th>Type</th><th>Syntax</th></tr></thead><tbody><tr><td>Dynamic Simple</td><td><pre class="synopsis">name?</pre></td></tr><tr><td>Dynamic Indexed</td><td><pre class="synopsis">name[<span class="emphasis"><em>index</em></span>]?</pre></td></tr><tr><td>Dynamic Mapped</td><td><pre class="synopsis">name('<span class="emphasis"><em>key</em></span>')?</pre></td></tr><tr><td>Dynamic Nested</td><td><pre class="synopsis">name?.nestedPropertyName</pre></td></tr></tbody></table></div><p>
			 Dynamic properties always return the <tt class="literal">java.lang.Object</tt> type. Also, dynamic properties return a <tt class="literal">null</tt> value if the dynamic property does not exist on events processed at runtime. 
		</p><p>
			As an example, consider an OrderEvent event that provides an "item" property. The "item" property is of type <tt class="literal">Object</tt> and holds a reference to an instance of either a Service or Product. 
		</p><p>
			Assume that both Service and Product classes provide a property named "price". Via a dynamic property we can specify a query that obtains the price property from either object (Service or Product):
		</p><pre class="programlisting">select item.price? from OrderEvent</pre><p>
			 As a second example, assume that the Service class contains a "serviceName" property that the Product class does not possess. The following query returns the value of the "serviceName" property for Service objects. It returns a <tt class="literal">null</tt>-value for Product objects that do not have the "serviceName" property:
		</p><pre class="programlisting">select item.serviceName? from OrderEvent</pre><p>
			Consider the case where OrderEvent has multiple implementation classes, some of which have a "timestamp" property. The next query returns the timestamp property of those implementations of the OrderEvent interface that feature the property:
		</p><pre class="programlisting">select timestamp? from OrderEvent</pre><p>
			The query as above returns a single column named "timestamp?" of type <tt class="literal">Object</tt>. 			
		</p><p>
			When dynamic properties are nested, then all properties under the dynamic property are also considered dynamic properties. In the below example the query asks for the "direction" property of the object returned by the "detail" dynamic property:
		</p><pre class="programlisting">select detail?.direction from OrderEvent
// equivalent to 
select detail?.direction? from OrderEvent</pre><p>
			The functions that are often useful in conjunction with dynamic properties are:
		</p><div class="itemizedlist"><ul type="disc"><li><p>
                    The <tt class="literal">cast</tt> function casts the value of a dynamic property (or the value of an expression) to a given type.
                </p></li><li><p>
                    The <tt class="literal">exists</tt> function checks whether a dynamic property exists. It returns <tt class="literal">true</tt> if the event has a property of that name, or false if the property does not exist on that event.
                </p></li><li><p>
                    The <tt class="literal">instanceof</tt> function checks whether the value of a dynamic property (or the value of an expression) is of any of the given types.
                </p></li></ul></div><p>
			Dynamic event properties work with all event representations outlined next: Java objects, Map-based and XML DOM-based events.
		</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="eventrep-fragment"></a>2.4.&nbsp;Fragment and Fragment Type</h2></div></div><div></div></div><p>
			Sometimes an event can have properties that are itself events. Esper uses the term <span class="emphasis"><em>fragment</em></span> and <span class="emphasis"><em>fragment type</em></span> for such event pieces. The best example is a pattern
			that matches two or more events and the output event contains the matching events as fragments. In other words, output events can be a composite event that consists of further events, the fragments.
		</p><p>
			Fragments have the same metadata available as their enclosing composite events. The metadata for enclosing composite events contains information about which properties are fragments, or have a property value that can be 
			represented as a fragment and therefore as an event itself.
		</p><p>
			Fragments and type metadata can allow your application to navigate composite events without the need for using the Java reflection API and reducing the coupling to the underlying event representation.
			The API is further described in <a href="#api-event" title="9.5.&nbsp;Event and Event Type">Section&nbsp;9.5, &#8220;Event and Event Type&#8221;</a>.
		</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="eventrep-javabean"></a>2.5.&nbsp;Plain-Old Java Object Events</h2></div></div><div></div></div><a class="indexterm" name="d0e514"></a><p>
			Plain-old Java object events are object instances that expose event properties through JavaBeans-style getter methods. Events classes or interfaces do not have to be fully compliant to the JavaBean specification; however for the Esper engine to obtain event properties, the required JavaBean getter methods must be present or an accessor-style and accessor-methods may be defined via configuration.
		</p><p>
			Esper supports JavaBeans-style event classes that extend a superclass or implement one or more interfaces. Also, Esper event pattern and EPL statements can refer to Java interface classes and abstract classes. 
		</p><p>
			Classes that represent events should be made immutable. As events are recordings of a state change or action that occurred in the past, the relevant event properties should not be changeable. However this is not a hard requirement and the Esper engine accepts events that are mutable as well.
		</p><p>
			The <tt class="literal">hashCode</tt> and <tt class="literal">equals</tt> methods do not need to be implemented. The implementation of these methods by a Java event class does not affect the behavior of the engine in any way.
		</p><p>
			Please see <a href="#configuration" title="Chapter&nbsp;10.&nbsp;Configuration">Chapter&nbsp;10, <i>Configuration</i></a> on options for naming event types represented by Java object event classes.
			Java classes that do not follow JavaBean conventions, such as legacy Java classes that expose public fields, or methods not following naming conventions, require additional configuration. Via configuration it is also possible to control case sensitivity in property name resolution. The relevant section in the chapter on configuration is <a href="#config-java-legacy" title="10.4.1.3.&nbsp;Non-JavaBean and Legacy Java Event Classes">Section&nbsp;10.4.1.3, &#8220;Non-JavaBean and Legacy Java Event Classes&#8221;</a>.
		</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="event-properties"></a>2.5.1.&nbsp;Java Object Event Properties</h3></div></div><div></div></div><p>
				As outlined earlier, the different property types are supported by the standard JavaBeans specification, and some of which are uniquely supported by Esper:
			</p><div class="itemizedlist"><ul type="disc" compact><li><p>
						<span class="emphasis"><em>Simple</em></span> properties have a single value that may be retrieved. The underlying property type might be a Java language primitive (such as int, a simple object (such as a java.lang.String), or a more complex object whose class is defined either by the Java language, by the application, or by a class library included with the application.
					</p></li><li><p>
						<span class="emphasis"><em>Indexed</em></span> - An indexed property stores an ordered collection of objects (all of the same type) that can be individually accessed by an integer-valued, non-negative index (or subscript). 
					</p></li><li><p>
						<span class="emphasis"><em>Mapped</em></span> - As an extension to standard JavaBeans APIs, Esper considers any property that accepts a String-valued key a mapped property. 
					</p></li><li><p>
						<span class="emphasis"><em>Nested</em></span> - A nested property is a property that lives within another Java object which itself is a property of an event. 
					</p></li></ul></div><p>
				Assume there is an <tt class="literal">NewEmployeeEvent</tt> event class as shown below. The mapped and indexed properties in this example return Java objects but could also return Java language primitive types (such as int or String). The <tt class="literal">Address</tt> object and <tt class="literal">Employee</tt> can themselves have properties that are nested within them, such as a street name in the <tt class="literal">Address</tt> object or a name of the employee in the <tt class="literal">Employee</tt> object.
			</p><pre class="programlisting">public class NewEmployeeEvent {
	public String getFirstName();
	public Address getAddress(String type);
	public Employee getSubordinate(int index);
	public Employee[] getAllSubordinates();
}
</pre><p>
					<span class="emphasis"><em>Simple</em></span> event properties require a getter-method that returns the property value. In this example, the <tt class="literal">getFirstName</tt> getter method returns the <tt class="literal">firstName</tt> event property of type String.
				</p><p>
					<span class="emphasis"><em>Indexed</em></span> event properties require either one of the following getter-methods. A method that takes an integer-type key value and returns the property value, such as the <tt class="literal">getSubordinate</tt> method, or a method that returns an array-type, or a class that implements <tt class="literal">Iterable</tt>. An example is the <tt class="literal">getSubordinates</tt> getter method, which returns an array of Employee but could also return an <tt class="literal">Iterable</tt>. In an EPL or event pattern statement, indexed properties are accessed via the <tt class="literal">property[index]</tt> syntax.
				</p><p>
					<span class="emphasis"><em>Mapped</em></span> event properties require a getter-method that takes a String-typed key value and returns the property value, such as the <tt class="literal">getAddress</tt> method. In an EPL or event pattern statement, mapped properties are accessed via the <tt class="literal">property('key')</tt> syntax.
				</p><p>
					<span class="emphasis"><em>Nested</em></span> event properties require a getter-method that returns the nesting object. The <tt class="literal">getAddress</tt> and <tt class="literal">getSubordinate</tt> methods are mapped and indexed properties that return a nesting object. In an EPL or event pattern statement, nested properties are accessed via the <tt class="literal">property.nestedProperty</tt> syntax.
				</p><p>
					All event pattern and EPL statements allow the use of indexed, mapped and nested properties (or a combination of these) anywhere where one or more event property names are expected. The below example shows different combinations of indexed, mapped and nested properties in filters of event pattern expressions:
				</p><pre class="programlisting">every NewEmployeeEvent(firstName='myName')
every NewEmployeeEvent(address('home').streetName='Park Avenue')
every NewEmployeeEvent(subordinate[0].name='anotherName')
every NewEmployeeEvent(allSubordinates[1].name='thatName')
every NewEmployeeEvent(subordinate[0].address('home').streetName='Water Street')</pre><p>
					Similarly, the syntax can be used in EPL statements in all places where an event property name is expected, such as in select lists, where-clauses or join criteria.
				</p><pre class="programlisting">select firstName, address('work'), subordinate[0].name, subordinate[1].name
from NewEmployeeEvent
where address('work').streetName = 'Park Ave'</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="event-properties-names"></a>2.5.2.&nbsp;Property Names</h3></div></div><div></div></div><p>
					Property names follows Java standards: the class <tt class="literal">java.beans.Introspector</tt> and method <tt class="literal">getBeanInfo</tt> returns the property names as derived from the name of getter methods. In addition, Esper configuration provides a flag to turn off case-sensitive property names. A sample list of getter methods and property names is: 
				</p><div class="table"><a name="d0e663"></a><p class="title"><b>Table&nbsp;2.4.&nbsp;JavaBeans-style Getter Methods and Property Names</b></p><table summary="JavaBeans-style Getter Methods and Property Names" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>Method</th><th>Property Name</th><th>Example</th></tr></thead><tbody><tr><td><tt class="literal">getPrice()</tt></td><td>price</td><td><pre class="synopsis">select price from MyEvent</pre></td></tr><tr><td><tt class="literal">getNAME()</tt></td><td>NAME</td><td><pre class="synopsis">select NAME from MyEvent</pre></td></tr><tr><td><tt class="literal">getItemDesc()</tt></td><td>itemDesc</td><td><pre class="synopsis">select itemDesc from MyEvent</pre></td></tr><tr><td><tt class="literal">getQ()</tt></td><td>q</td><td><pre class="synopsis">select q from MyEvent</pre></td></tr><tr><td><tt class="literal">getQN()</tt></td><td>QN</td><td><pre class="synopsis">select QN from MyEvent</pre></td></tr><tr><td><tt class="literal">getqn()</tt></td><td>qn</td><td><pre class="synopsis">select qn from MyEvent</pre></td></tr><tr><td><tt class="literal">gets()</tt></td><td>s</td><td><pre class="synopsis">select s from MyEvent</pre></td></tr></tbody></table></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="event-properties-const"></a>2.5.3.&nbsp;Constants and Enumeration</h3></div></div><div></div></div><a class="indexterm" name="d0e745"></a><a class="indexterm" name="d0e748"></a><p>
				Constants are public static final fields in Java that may also participate in expressions of all kinds, as this example shows:
			</p><pre class="programlisting">select * from MyEvent where property=MyConstantClass.FIELD_VALUE</pre><p>
				Event properties that are enumeration values can be compared by their enumeration value:
			</p><pre class="programlisting">select * from MyEvent where enumProp=EnumClass.ENUM_VALUE_1</pre><p>
				Alternatively, a static method may be employed on a class, such as the enumeration class 'EnumClass' as below:
			</p><pre class="programlisting">select * from MyEvent where enumProp=EnumClass.valueOf('ENUM_VALUE_1')</pre><p>
				If your application does not import, through configuration, the package that contains the enumeration class, then it must also specify the package name of the class. Enumeration
				classes that are inner classes must be qualified with <tt class="literal">$</tt> following Java conventions.
			</p><p>
				For example, the Color enumeration as an inner class to <tt class="literal">MyEvent</tt> in package <tt class="literal">org.myorg</tt> can be referenced as shown:
			</p><pre class="programlisting">select * from MyEvent(enumProp=org.myorg.MyEvent$Color.GREEN).std:firstevent()</pre><p>
				Instance methods may also be invoked on event instances by specifying a stream name, as shown below:
			</p><pre class="programlisting">select myevent.computeSomething() as result from MyEvent as myevent</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="event-properties-parameterized"></a>2.5.4.&nbsp;Parameterized Types</h3></div></div><div></div></div><p>
				When your getter methods or accessor fields return a parameterized type, for example <tt class="literal">Iterable&lt;MyEventData&gt;</tt> for an indexed property or <tt class="literal">Map&lt;String, MyEventData&gt;</tt> for a mapped property, then property expressions may refer to the properties available through the class that is the type parameter.
			</p><p>
				An example event that has properties that are parameterized types is:
			</p><pre class="programlisting">public class NewEmployeeEvent {
  public String getName();
  public Iterable&lt;EducationHistory&gt; getEducation();
  public Map&lt;String, Address&gt; getAddresses();
}</pre><p>
				A sample of valid property expressions for this event is shown next:
			</p><pre class="programlisting">select name, education, education[0].date, addresses('home').street
from NewEmployeeEvent</pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="eventrep-java-util-map"></a>2.6.&nbsp;<tt class="literal">java.util.Map</tt> Events</h2></div></div><div></div></div><a class="indexterm" name="d0e806"></a><a class="indexterm" name="d0e809"></a><p>
			A given Map event type can have one or more supertypes that must also be Map event types. All properties available on any of the Map supertypes are available on the type itself. In addition, anywhere within EPL that an event type name of a Map supertype is used, any of its Map subtypes and their subtypes match that expression.
		</p><p>
			Your application can add properties to an existing Map event type during runtime using the configuration operation <tt class="literal">updateMapEventType</tt>. Properties may not be updated or deleted - properties can only be added, and nested properties can be added as well. The method accepts a Map structure that may include previously listed properties or can also contain only the newly added fields.
		</p><p>
			The engine can process <tt class="literal">java.util.Map</tt> events via the <tt class="literal">sendEvent(Map map, String eventTypeName)</tt> method on the <tt class="literal">EPRuntime</tt> interface. Entries in the Map represent event properties. Keys must be of type <tt class="literal">java.util.String</tt> for the engine to be able to look up event property names specified by pattern or EPL statements. 
		</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="eventrep-map-overview"></a>2.6.1.&nbsp;Overview</h3></div></div><div></div></div><p>
				Events can also be represented by objects that implement the <tt class="literal">java.util.Map</tt> interface. 
				Event properties of <tt class="literal">Map</tt> events are the values in the map accessible through the <tt class="literal">get</tt> method exposed by the <tt class="literal">java.util.Map</tt> interface.
			</p><p>
				The Map event type is a comprehensive type system that can eliminate the need to use Java classes as event types, thereby making it easier to change types at runtime or generate type information from another source.
			</p><p>
				A given Map event type can have one or more supertypes that must also be Map event types. All properties available on any of the Map supertypes are available on the type itself. In addition, anywhere within EPL that an event type name of a Map supertype is used, any of its Map subtypes and their subtypes match that expression.
			</p><p>
				Your application can add properties to an existing Map event type during runtime using the configuration operation <tt class="literal">updateMapEventType</tt>. Properties may not be updated or deleted - properties can only be added, and nested properties can be added as well. The runtime configuration also allows removing Map event types and adding them back with new type information.
			</p><p>
				After your application configures a Map event type by providing a type name, the type name can be used when defining further Map event types by specifying the type name as a property type or an array property type.
			</p><p>
				One-to-Many relationships in Map event types are represented via arrays. A property in a Map event type may be an array of primitive, an array of Java object or an array of Map. 
			</p><p>
				The engine can process <tt class="literal">java.util.Map</tt> events via the <tt class="literal">sendEvent(Map map, String eventTypeName)</tt> method on the <tt class="literal">EPRuntime</tt> interface. Entries in the Map represent event properties. Keys must be of type <tt class="literal">java.util.String</tt> for the engine to be able to look up event property names specified by pattern or EPL statements. 
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="eventrep-map-properties"></a>2.6.2.&nbsp;Map Properties</h3></div></div><div></div></div><p>
				Map event properties can be of any type. Map event properties that are Java application objects or that are of type <tt class="literal">java.util.Map</tt> (or arrays thereof) offer additional power:
			</p><div class="itemizedlist"><ul type="disc" compact><li><p>
						Properties that are Java application objects can be queried via the nested, indexed, mapped and dynamic property syntax as outlined earlier. 
					</p></li><li><p>
						Properties that are of type <tt class="literal">Map</tt> allow Maps to be nested arbitrarily deep and thus can be used to represent complex domain information. The nested, indexed, mapped and dynamic property syntax can be used to query Maps within Maps and arrays of Maps within Maps. 					
					</p></li></ul></div><p>
				In order to use <tt class="literal">Map</tt> events, the event type name and property names and types must be made known to the engine via Configuration. Please see the examples in <a href="#config-java-util-map" title="10.4.2.&nbsp;Events represented by java.util.Map">Section&nbsp;10.4.2, &#8220;Events represented by java.util.Map&#8221;</a>.
			</p><p>
				The code snippet below creates and processes a <tt class="literal">Map</tt> event. It defines a <tt class="literal">CarLocationUpdateEvent</tt> event type first:
			</p><pre class="programlisting">Map event = new HashMap();
event.put("carId", carId);
event.put("direction", direction);
epRuntime.sendEvent(event, "CarLocUpdateEvent");</pre><p>
				The <tt class="literal">CarLocUpdateEvent</tt> can now be used in a statement:
			</p><pre class="programlisting">select carId from CarLocUpdateEvent.win:time(1 min) where direction = 1</pre><p>
				The engine can also query Java objects as values in a <tt class="literal">Map</tt> event via the nested property syntax. Thus <tt class="literal">Map</tt> events can be used to 
				aggregate multiple data structures into a single event and query the composite information in a convenient way. The example below demonstrates a <tt class="literal">Map</tt> event with a transaction and an account object.
			</p><pre class="programlisting">Map event = new HashMap();
event.put("txn", txn);
event.put("account", account);
epRuntime.sendEvent(event, "TxnEvent");</pre><p>
				An example statement could look as follows.
			</p><pre class="programlisting">select account.id, account.rate * txn.amount 
from TxnEvent.win:time(60 sec) 
group by account.id</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="eventrep-map-supertype"></a>2.6.3.&nbsp;Map Supertypes</h3></div></div><div></div></div><p>
			   Your <tt class="literal">Map</tt> event type may declare one or more supertypes when configuring the type at engine initialization time or at runtime through the administrative interface. 
		   </p><p>
			   Supertypes of a <tt class="literal">Map</tt> event type must also be Map event types. All property names and types of a supertype are also available on a subtype and override such same-name properties of the subtype. In addition, anywhere within EPL that an event type name of a Map supertype is used, any of its Map subtypes also matches that expression (similar to the concept of interface in Java).
		   </p><p>
			   This example assumes that the <tt class="literal">BaseUpdate</tt> event type has been declared and acts as a supertype to the <tt class="literal">AccountUpdate</tt> event type (both Map event types): 
		   </p><pre class="programlisting">epService.getEPAdministrator().getConfiguration().
    addEventType("AccountUpdate", accountUpdateDef, 
    new String[] {"BaseUpdate"});</pre><p>
			   Your application EPL statements may select <tt class="literal">BaseUpdate</tt> events and receive both <tt class="literal">BaseUpdate</tt> and <tt class="literal">AccountUpdate</tt> events, as well as any other subtypes of <tt class="literal">BaseUpdate</tt> and their subtypes.
		   </p><pre class="programlisting">// Receive BaseUpdate and any subtypes including subtypes of subtypes
select * from BaseUpdate</pre><p>
			   Your application Map event type may have multiple supertypes. The multiple inheritance hierarchy between Maps can be arbitrarily deep, however cyclic dependencies are not allowed. If using runtime configuration, supertypes must exist before a subtype to a supertype can be added.
		   </p><p>
			   See <a href="#config-java-util-map" title="10.4.2.&nbsp;Events represented by java.util.Map">Section&nbsp;10.4.2, &#8220;Events represented by java.util.Map&#8221;</a> for more information on configuring Map event types.
		   </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="eventrep-map-advanced"></a>2.6.4.&nbsp;Advanced Map Property Types</h3></div></div><div></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="eventrep-map-nested"></a>2.6.4.1.&nbsp;Nested Properties</h4></div></div><div></div></div><p>
				   Strongly-typed nested <tt class="literal">Map</tt>-within-<tt class="literal">Map</tt> events can be used to build rich, type-safe event types on the fly. Use the <tt class="literal">addEventType</tt> method on <tt class="literal">Configuration</tt> or <tt class="literal">ConfigurationOperations</tt> for initialization-time and runtime-time type definition.
			   </p><p>
				   Noteworthy points are:
			   </p><div class="itemizedlist"><ul type="disc" compact><li><p>
							JavaBean (POJO) objects can appear as properties in <tt class="literal">Map</tt>-within-<tt class="literal">Map</tt>. 
						</p></li><li><p>
							One may represent Map-within-Map and Map-Array within Map using the name of a previously registered Map event type.
						</p></li><li><p>
							There is no limit to the number of nesting levels.
						</p></li><li><p>
							Dynamic properties can be used to query <tt class="literal">Map</tt>-within-<tt class="literal">Map</tt> keys that may not be known in advance. 
						</p></li><li><p>
							The engine returns a <tt class="literal">null</tt> value for properties for which the access path into the nested structure cannot be followed where map entries do not exist.
						</p></li></ul></div><p>
				   For demonstration, in this example our top-level event type is an <tt class="literal">AccountUpdate</tt> event, which has an <tt class="literal">UpdatedField</tt> structure as a property. Inside the <tt class="literal">UpdatedField</tt> structure the example defines various fields, as well as a property by name 'history' that holds a JavaBean class <tt class="literal">UpdateHistory</tt> to represent the update history for the account. The code snippet to define the event type is thus:
			   </p><pre class="programlisting">Map&lt;String, Object&gt; updatedFieldDef = new HashMap&lt;String, Object&gt;();
updatedFieldDef.put("name", String.class);
updatedFieldDef.put("addressLine1", String.class);
updatedFieldDef.put("history", UpdateHistory.class);

Map&lt;String, Object&gt; accountUpdateDef = new HashMap&lt;String, Object&gt;();
accountUpdateDef.put("accountId", long.class);
accountUpdateDef.put("fields", updatedFieldDef);

epService.getEPAdministrator().getConfiguration().
    addEventType("AccountUpdate", accountUpdateDef);</pre><p>
				   The next code snippet populates a sample event and sends the event into the engine:
			   </p><pre class="programlisting">Map&lt;String, Object&gt; updatedField = new HashMap&lt;String, Object&gt;();
updatedField.put("name", "Joe Doe");
updatedField.put("addressLine1", "40 Popular Street");
updatedField.put("history", new UpdateHistory());

Map&lt;String, Object&gt; accountUpdate = new HashMap&lt;String, Object&gt;();
accountUpdate.put("accountId", 10009901);
accountUpdate.put("fields", updatedField);

epService.getEPRuntime().sendEvent(accountUpdate, "AccountUpdate");</pre><p>
				   Last, a sample query to interrogate <tt class="literal">AccountUpdate</tt> events is as follows:
			   </p><pre class="programlisting">select accountId, fields.name, fields.addressLine1, fields.history.lastUpdate
from AccountUpdate</pre><p>
					Note that type information for nested maps is only available to the immediately selecting stream. For example, the second select-query does not work:
				</p><pre class="programlisting">insert into MyStream select fields from NestedMapEvent
// this does not work ... instead select the individual fields in the insert-into statement
select fields.name from MyStream </pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="eventrep-map-typereuse"></a>2.6.4.2.&nbsp;Map Event Type Properties</h4></div></div><div></div></div><p>
				   Your application may declare a Map event type for reuse within other Map event types or for one-to-many properties represented by an array of Maps.
			   </p><p>
				   This example declares a Map event type by name <tt class="literal">AmountCurrency</tt> with amount and currency properties:
			   </p><pre class="programlisting">Map&lt;String, Object&gt; amountAndCurr = new HashMap&lt;String, Object&gt;();
amountAndCurr.put("amount", double.class);
amountAndCurr.put("currency", String.class);

epService.getEPAdministrator().getConfiguration().
    addEventType("AmountCurrency", amountAndCurr);</pre><p>
				   The <tt class="literal">AmountCurrency</tt> type is now available for use as a property type itself. Below code snippet declares <tt class="literal">OrderItem</tt> to hold an item number and <tt class="literal">AmountCurrency</tt>:
			   </p><pre class="programlisting">Map&lt;String, Object&gt; orderItem = new HashMap&lt;String, Object&gt;();
orderItem.put("itemNum", int.class);
orderItem.put("price", "AmountCurrency");    // The property type is the name itself

epService.getEPAdministrator().getConfiguration().
    addEventType("OrderItem", orderItem);</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="eventrep-map-array"></a>2.6.4.3.&nbsp;One-to-Many Relationships</h4></div></div><div></div></div><p>
				   To model repeated properties within a Map, you may use arrays as properties in a Map. You may use an array of primitive types or an array of JavaBean objects or an array of a previously declared Map event type.
			   </p><p>
				   When using a previously declared Map event type as an array property, the literal <tt class="literal">[]</tt> must be appended after the event type name.
			   </p><p>
				   This following example defines a Map event type by name <tt class="literal">Sale</tt> to hold array properties of the various types. It assumes a <tt class="literal">SalesPerson</tt> Java class exists and a Map event type by name <tt class="literal">OrderItem</tt> was declared:
			   </p><pre class="programlisting">Map&lt;String, Object&gt; sale = new HashMap&lt;String, Object&gt;();
sale.put("userids", int[].class);
sale.put("salesPersons", SalesPerson[].class);
sale.put("items", "OrderItem[]");	 // The property type is the name itself appended by []

epService.getEPAdministrator().getConfiguration().
    addEventType("SaleEvent", sale);</pre><p>
				   The three properties that the above example declares are:
			   </p><div class="itemizedlist"><ul type="disc"><li><p>
						 An integer array of user ids.
					   </p></li><li><p>
						 An array of <tt class="literal">SalesPerson</tt> Java objects.
					   </p></li><li><p>
						 An array of Maps for order items.
					   </p></li></ul></div><p>
				   The next EPL statement is a sample query asking for property values held by arrays:
			   </p><pre class="programlisting">select userids[0], salesPersons[1].name, 
    items[1], items[1].price.amount from SaleEvent</pre></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="eventrep-xml-dom"></a>2.7.&nbsp;<tt class="literal">org.w3c.dom.Node</tt> XML Events</h2></div></div><div></div></div><a class="indexterm" name="d0e1142"></a><a class="indexterm" name="d0e1145"></a><p>
			Events can be represented as <tt class="literal">org.w3c.dom.Node</tt> instances and send into the engine via the <tt class="literal">sendEvent</tt> method on <tt class="literal">EPRuntime</tt> or via <tt class="literal">EventSender</tt>. Please note that configuration is required so the event type name and root element name is known. See <a href="#configuration" title="Chapter&nbsp;10.&nbsp;Configuration">Chapter&nbsp;10, <i>Configuration</i></a>.
		</p><p>
			If a XML schema document (XSD file) can be made available as part of the configuration, then Esper can read the schema and appropriately present event type metadata and validate statements that use the event type and its properties. See <a href="#eventrep-xml-dom-schema" title="2.7.1.&nbsp;Schema-Provided XML Events">Section&nbsp;2.7.1, &#8220;Schema-Provided XML Events&#8221;</a>.
		</p><p>
			When no XML schema document is provided, XML events can still be queried, however the return type and return values of property expressions are string-only and no event type metadata is available other then for explicitly configured properties. See <a href="#eventrep-xml-dom-noschema" title="2.7.2.&nbsp;No-Schema-Provided XML Events">Section&nbsp;2.7.2, &#8220;No-Schema-Provided XML Events&#8221;</a>.
		</p><p>
			In all cases Esper allows you to configure explicit XPath expressions as event properties. You can specify arbitrary XPath functions or expressions and provide a property name and type by which result values will be available for use in EPL statements. See <a href="#eventrep-xml-dom-explicit" title="2.7.3.&nbsp;Explicitly-Configured Properties">Section&nbsp;2.7.3, &#8220;Explicitly-Configured Properties&#8221;</a>.
		</p><p>
			Nested, mapped and indexed event properties are also supported in expressions against <tt class="literal">org.w3c.dom.Node</tt> events. Thus XML trees can conveniently be interrogated via the property expression syntax.
		</p><p>
			This section uses the following XML document as an example:
		</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;Sensor xmlns="SensorSchema"&gt;
  &lt;ID&gt;urn:epc:1:4.16.36&lt;/ID&gt;
  &lt;Observation Command="READ_PALLET_TAGS_ONLY"&gt;
    &lt;ID&gt;00000001&lt;/ID&gt;
    &lt;Tag&gt;
      &lt;ID&gt;urn:epc:1:2.24.400&lt;/ID&gt;
    &lt;/Tag&gt;
    &lt;Tag&gt;
      &lt;ID&gt;urn:epc:1:2.24.401&lt;/ID&gt;
    &lt;/Tag&gt;
  &lt;/Observation&gt;
&lt;/Sensor&gt;</pre><p>
			The schema for the example is:
		</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;

  &lt;xs:element name="Sensor"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:element name="ID" type="xs:string"/&gt;
        &lt;xs:element ref="Observation" /&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="Observation"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:element name="ID" type="xs:string"/&gt;
        &lt;xs:element ref="Tag" maxOccurs="unbounded" /&gt;
      &lt;/xs:sequence&gt;
      &lt;xs:attribute name="Command" type="xs:string" use="required" /&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="Tag"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
        &lt;xs:element name="ID" type="xs:string"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
&lt;/xs:schema&gt;</pre><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="eventrep-xml-dom-schema"></a>2.7.1.&nbsp;Schema-Provided XML Events</h3></div></div><div></div></div><p>
			   If you have a XSD schema document available for your XML events, Esper can interrogate the schema. The benefits are:
		   </p><div class="itemizedlist"><ul type="disc" compact><li><p>
						New EPL statements that refer to event properties are validated against the types provided in the schema.
					</p></li><li><p>
						Event type metadata becomes available for retrieval as part of the <tt class="literal">EventType</tt> interface.
					</p></li></ul></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="eventrep-xml-dom-schema-start"></a>2.7.1.1.&nbsp;Getting Started</h4></div></div><div></div></div><p>
					The engine reads a XSD schema file from an URL you provide. Make sure files imported by the XSD schema file can also be resolved.
				</p><p>
					The configuration accepts a schema URL. This is a sample code snippet to determine a schema URL from a file in classpath:
				</p><pre class="programlisting">URL schemaURL = this.getClass().getClassLoader().getResource("sensor.xsd");</pre><p>
					Here is a sample use of the runtime configuration API, please see <a href="#configuration" title="Chapter&nbsp;10.&nbsp;Configuration">Chapter&nbsp;10, <i>Configuration</i></a> for further examples.
				</p><pre class="programlisting">epService = EPServiceProviderManager.getDefaultProvider();
ConfigurationEventTypeXMLDOM sensorcfg = new ConfigurationEventTypeXMLDOM();
sensorcfg.setRootElementName("Sensor");
sensorcfg.setSchemaResource(schemaURL.toString());
epService.getEPAdministrator().getConfiguration()
    .addEventType("SensorEvent", sensorcfg);</pre><p>
					You must provide a root element name. This name is used to look up the event type for the <tt class="literal">sendEvent(org.w3c.Node node)</tt> method. An <tt class="literal">EventSender</tt> is a useful alternative method
					for sending events if the type lookup based on the root or document element name is not desired.
				</p><p>
					After adding the event type, you may create statements and send events. Next is a sample statement:
				</p><pre class="programlisting">select ID, Observation.Command, Observation.ID, 
  Observation.Tag[0].ID, Observation.Tag[1].ID
from SensorEvent</pre><p>
					As you can see from the example above, property expressions can query property values held in the XML document's elements and attributes.
				</p><p>
					There are multiple ways to obtain a XML DOM document instance from a XML string. The next code snippet shows how to obtain a XML DOM <tt class="literal">org.w3c.Document</tt> instance:
				</p><pre class="programlisting">InputSource source = new InputSource(new StringReader(xml));
DocumentBuilderFactory builderFactory = DocumentBuilderFactory.newInstance();
builderFactory.setNamespaceAware(true);
Document doc = builderFactory.newDocumentBuilder().parse(source);</pre><p>
					Send the <tt class="literal">org.w3c.Node</tt> or <tt class="literal">Document</tt> object into the engine for processing:
				</p><pre class="programlisting">epService.getEPRuntime().sendEvent(doc);</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="eventrep-xml-dom-schema-propertyexpr"></a>2.7.1.2.&nbsp;Property Expressions and Namespaces</h4></div></div><div></div></div><p>
					By default, property expressions such as <tt class="literal">Observation.Tag[0].ID</tt> are evaluated by a fast DOM-walker implementation provided by Esper. This DOM-walker implementation is not namespace-aware.
				</p><p>
					Should you require namespace-aware traversal of the DOM document, you must set the <tt class="literal">xpath-property-expr</tt> configuration option to true (default is false). This flag causes Esper to generate namespace-aware XPath
					expressions from each property expression instead of the DOM-walker, as described next. Setting the <tt class="literal">xpath-property-expr</tt> option to true requires that you also configure namespace prefixes as described below.
				</p><p>
					When matching up the property names with the XSD schema information, the engine determines whether the attribute or element provides values. The algorithm checks attribute names first followed by element names. It takes the first match to the specified property name.
				</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="eventrep-xml-dom-schema-propertyexpr-xpath"></a>2.7.1.3.&nbsp;Property Expression to XPath Rewrite</h4></div></div><div></div></div><p>
					By setting the <tt class="literal">xpath-property-expr</tt> option the engine rewrites each property expression as an XPath expression, effectively handing the evaluation over to the underlying XPath implementation
					available from classpath. Most JVM have a built-in XPath implementation and there are also optimized, fast implementations such as Jaxen that can be used as well.
				</p><p>
					Set the <tt class="literal">xpath-property-expr</tt> option if you need namespace-aware document traversal, such as when your schema mixes several namespaces and element names are overlapping.
				</p><p>
					The below table samples several property expressions and the XPath expression generated for each, without namespace prefixes to keep the example simple:
				</p><div class="table"><a name="d0e1285"></a><p class="title"><b>Table&nbsp;2.5.&nbsp;Property Expression to XPath Expression</b></p><table summary="Property Expression to XPath Expression" border="1"><colgroup><col><col></colgroup><thead><tr><th>Property Expression</th><th>Equivalent XPath</th></tr></thead><tbody><tr><td><tt class="literal">Observeration.ID</tt></td><td><tt class="literal">/Sensor/Observation/ID</tt></td></tr><tr><td><tt class="literal">Observeration.Command</tt></td><td><tt class="literal">/Sensor/Observation/@Command</tt></td></tr><tr><td><tt class="literal">Observeration.Tag[0].ID</tt></td><td><tt class="literal">/Sensor/Observation/Tag[position() = 1]/ID</tt></td></tr></tbody></table></div><p> 
					For mapped properties that are specified via the syntax <tt class="literal">name('key')</tt>, the algorithm looks for an attribute by name <tt class="literal">id</tt> and generates a XPath expression as <tt class="literal">mapped[@id='key']</tt>.
				</p><p> 
					Finally, here is an example that includes all different types of properties and their XPath expression equivalent in one property expression:
				</p><pre class="programlisting">select nested.mapped('key').indexed[1].attribute from MyEvent</pre><p> 
					The equivalent XPath expression follows, this time including <tt class="literal">n0</tt> as a sample namespace prefix:
				</p><pre class="programlisting">/n0:rootelement/n0:nested/n0:mapped[@id='key']/n0:indexed[position() = 2]/@attribute</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="eventrep-xml-dom-schema-propertyarray"></a>2.7.1.4.&nbsp;Array Properties</h4></div></div><div></div></div><p>
					All elements that are unbound or have max occurs greater then 1 in the XSD schema are represented as indexed properties and require an index for resolution.
				</p><p>
					For example, the following is not a valid property expression in the sample Sensor document: <tt class="literal">Observeration.Tag.ID</tt>. As no index is provided for <tt class="literal">Tag</tt>, the property expression is not valid.
				</p><p>
					Repeated elements within a parent element in which the repeated element is a simple type also are represented as an array.
				</p><p>
					Consider the next XML document:
				</p><pre class="programlisting">&lt;item&gt;
  &lt;book sku="8800090"&gt;
    &lt;author&gt;Isaac Asimov&lt;/author&gt;
    &lt;author&gt;Robert A Heinlein&lt;/author&gt;
  &lt;/book&gt;
&lt;/item&gt;</pre><p>
					Here, the result of the expression <tt class="literal">book.author</tt> is an array of type String and the result of <tt class="literal">book.author[0]</tt> is a String value.
				</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="eventrep-xml-dom-schema-propertydynamic"></a>2.7.1.5.&nbsp;Dynamic Properties</h4></div></div><div></div></div><p>
					  Dynamic properties are not validated against the XSD schema information and their result value is always <tt class="literal">org.w3c.Node</tt>. You may use a user-defined function to process dynamic properties returning <tt class="literal">Node</tt>. As an alternative consider using an explicit property.
				</p><p>
					An example dynamic property is <tt class="literal">Origin?.ID</tt> which will look for an element by name <tt class="literal">Origin</tt> that contains an element or attribute node by name <tt class="literal">LocationCode</tt>:
				</p><pre class="programlisting">select Origin?.LocationCode from SensorEvent</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="eventrep-xml-dom-schema-propertytranspose"></a>2.7.1.6.&nbsp;Transposing Properties</h4></div></div><div></div></div><p>
					When providing a XSD document, the default configuration allows to transpose property values that are themselves complex elements, as defined in the XSD schema, into a new stream. This behavior can be controlled via the flag <tt class="literal">auto-fragment</tt>.
				</p><p>
					For example, consider the next query:
				</p><pre class="programlisting">insert into ObservationStream
select ID, Observation from SensorEvent</pre><p>
					The <tt class="literal">Observation</tt> as a property of the <tt class="literal">SensorEvent</tt> gets itself inserted into a new stream by name <tt class="literal">ObservationStream</tt>. The <tt class="literal">ObservationStream</tt>
					thus consists of a string-typed <tt class="literal">ID</tt> property and a complex-typed property named <tt class="literal">Observation</tt>, as described in the schema.
				</p><p>
					A further statement can use this stream to query:
				</p><pre class="programlisting">select Observation.Command, Observation.Tag[0].ID from ObservationStream</pre><p>
					Before continuing the discussion, here is an alternative syntax using the wildcard-select, that is also useful:
				</p><pre class="programlisting">insert into TagListStream
select ID as sensorId, Observation.* from SensorEvent</pre><p>
					The new <tt class="literal">TagListStream</tt> has a string-typed <tt class="literal">ID</tt> and <tt class="literal">Command</tt> property as well as an array of <tt class="literal">Tag</tt> properties that are complex types themselves as defined in the schema.
				</p><p>
					Next is a sample statement to query the new stream:
				</p><pre class="programlisting">select sensorId, Command, Tag[0].ID from TagListStream</pre><p>
					Please note the following limitations:
				</p><div class="itemizedlist"><ul type="disc" compact><li><p>
							The XPath standard prescribes that XPath expressions against <tt class="literal">org.w3c.Node</tt> are evaluated against the owner document of the <tt class="literal">Node</tt>. Therefore XPath is not relative to the current node but absolute against each node's owner document. Since Esper does not create new document instances for transposed nodes, transposing properties is not possible when the <tt class="literal">xpath-property-expr</tt> flag is set.
						</p></li><li><p>
							Complex elements that have both simple element values and complex child elements are not transposed. This is to ensure their property value is not hidden. Use an explicit XPath expression to transpose such properties.
						</p></li></ul></div><p>
					Esper automatically registers a new event type for transposed properties. It generates the type name of the new XML event type from the XML event type name and the property names used in the expression. The synposis is <span class="emphasis"><em>type_name.property_name[.property_name...]</em></span>. The type name can be looked up, for example for use with <tt class="literal">EventSender</tt> or can be created in advance.
				</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="eventrep-xml-dom-eventsender"></a>2.7.1.7.&nbsp;Event Sender</h4></div></div><div></div></div><p>
					An <tt class="literal">EventSender</tt> sends events into the engine for a given type, saving a type lookup based on element name.
				</p><p>
					This brief example sends an event via <tt class="literal">EventSender</tt>:
				</p><pre class="programlisting">EventSender sender = epRuntime.getEventSender("SensorEvent");
sender.sendEvent(node);</pre><p>
					The XML DOM event sender checks the root element name before processing the event. Use the <tt class="literal">event-sender-validates-root</tt> setting to disable validation. This forces the engine to process XML documents according to any predefined type without validation of the root element name.
				</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="eventrep-xml-dom-noschema"></a>2.7.2.&nbsp;No-Schema-Provided XML Events</h3></div></div><div></div></div><p>
			   Without a schema document a XML event may still be queried. However there are important differences in the metadata available without a schema document and therefore the property expression results. These differences are outlined below.
		   </p><p>
				All property expressions against a XML type without schema are assumed valid. There is no validation of the property expression other then syntax validation. At runtime, property expressions return string-type values or <tt class="literal">null</tt> if the expression did not
				yield a matching element or attribute result.
			</p><p>
				When asked for property names or property metadata, a no-schema type returns empty array.
			</p><p>
				In all other aspects the type behaves the same as the schema-provided type described earlier.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="eventrep-xml-dom-explicit"></a>2.7.3.&nbsp;Explicitly-Configured Properties</h3></div></div><div></div></div><p>
		     Regardless of whether or not you provide a XSD schema for the XML event type, you can always fall back to configuring explicit properties that are backed by XPath expressions.
		   </p><p>
		     For further documentation on XPath, please consult the XPath standard or other online material. Consider using Jaxen or Apache Axiom, for example, to provide faster XPath evaluation then your Java VM built-in XPath provider may offer.
		   </p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="eventrep-xml-dom-explicit-simple"></a>2.7.3.1.&nbsp;Simple Explicit Property</h4></div></div><div></div></div><p>
					Shown below is an example configuration that adds an explicit property backed by a XPath expression and that defines namespace prefixes:
				</p><pre class="programlisting">epService = EPServiceProviderManager.getDefaultProvider();
ConfigurationEventTypeXMLDOM sensorcfg = new ConfigurationEventTypeXMLDOM();
sensorcfg.addXPathProperty("countTags", "count(/ss:Sensor/ss:Observation/ss:Tag)", 
    XPathConstants.NUMBER);
sensorcfg.addNamespacePrefix("ss", "SensorSchema");
sensorcfg.setRootElementName("Sensor");
epService.getEPAdministrator().getConfiguration()
    .addEventType("SensorEvent", sensorcfg);</pre><p>
					The <tt class="literal">countTags</tt> property is now available for querying:
				</p><pre class="programlisting">select countTags from SensorEvent</pre><p>
					The XPath expression <tt class="literal">count(...)</tt> is a XPath built-in function that counts the number of nodes, for the example document the result is <tt class="literal">2</tt>.
				</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="eventrep-xml-dom-explicit-casted"></a>2.7.3.2.&nbsp;Explicit Property Casting and Parsing</h4></div></div><div></div></div><p>
					Esper can parse or cast the result of your XPath expression to the desired type. Your property configuration provides the type to cast to, like this:
				</p><pre class="programlisting">sensorcfg.addXPathProperty("countTags", "count(/ss:Sensor/ss:Observation/ss:Tag)", 
    XPathConstants.NUMBER, "int");</pre><p>
					The type supplied to the property configuration must be one of the built-in types. Arrays of built-in type are also possible, requiring the <tt class="literal">XPathConstants.NODESET</tt> type returned by your XPath expression, as follows:
				</p><pre class="programlisting">sensorcfg.addXPathProperty("idarray", "//ss:Tag/ss:ID", 
    XPathConstants.NODESET, "String[]");</pre><p>
					The XPath expression <tt class="literal">//ss:Tag/ss:ID</tt> returns all ID nodes under a Tag node, regardless of where in the node tree the element is located. For the example document the result is <tt class="literal">2</tt> array elements <tt class="literal">urn:epc:1:2.24.400</tt> and <tt class="literal">urn:epc:1:2.24.40</tt>.
				</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="eventrep-xml-dom-explicit-node"></a>2.7.3.3.&nbsp;Node and Nodeset Explicit Property</h4></div></div><div></div></div><p>
					An explicit property may return <tt class="literal">XPathConstants.NODE</tt> or <tt class="literal">XPathConstants.NODESET</tt> and can provide the event type name of a pre-configured event type for the property. The method name to add such properties is <tt class="literal">addXPathPropertyFragment</tt>.
				</p><p>
					This code snippet adds two explicit properties and assigns an event type name for each property:
				</p><pre class="programlisting">sensorcfg.addXPathPropertyFragment("tagOne", "//ss:Tag[position() = 1]", 
    XPathConstants.NODE, "TagEvent");
sensorcfg.addXPathPropertyFragment("tagArray", "//ss:Tag", 
    XPathConstants.NODESET, "TagEvent");</pre><p>
					The configuration above references the <tt class="literal">TagEvent</tt> event type. This type must also be configured. Prefix the root element name with "//" to cause the lookup to search the nested schema elements for the definition of the type:
				</p><pre class="programlisting">ConfigurationEventTypeXMLDOM tagcfg = new ConfigurationEventTypeXMLDOM();
tagcfg.setRootElementName("//Tag");
tagcfg.setSchemaResource(schemaURL);
epAdministrator.getConfiguration()
    .addEventType("TagEvent", tagcfg);</pre><p>
					The <tt class="literal">tagOne</tt> and <tt class="literal">tagArray</tt> properties are now ready for selection and transposing to further streams:
				</p><pre class="programlisting">insert into TagOneStream select tagOne.* from SensorEvent
// ... select from the new stream ...
select ID from TagOneStream</pre><pre class="programlisting">insert into TagArrayStream select tagArray as mytags from SensorEvent
// ... select from the new stream ...
select mytags[0].ID from TagArrayStream</pre></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="eventrep-plug-in"></a>2.8.&nbsp;Additional Event Representations</h2></div></div><div></div></div><a class="indexterm" name="d0e1607"></a><p>
		    Part of the extension and plug-in features of Esper is an event representation API. This set of classes allow an application to create new event types and event instances based on information available elsewhere, statically or dynamically at runtime when EPL statements are created. Please see <a href="#custom-event-representation" title="11.5.&nbsp;Custom Event Representation">Section&nbsp;11.5, &#8220;Custom Event Representation&#8221;</a> for details.
		</p><p>
			Creating a plug-in event representation can be useful when your application has existing Java classes that carry event metadata and event property values and your application does not want to (or cannot) extract or transform
such event metadata and event data into one of the built-in event representations (POJO Java objects, Map or XML DOM).
		</p><p>
			Further use of a plug-in event representation is to provide a faster or short-cut access path to event data. For example, access to event data stored in a XML format through the Streaming API for XML (StAX) is known to be very efficient. A plug-in event representation can also provide network lookup and dynamic resolution of event type and dynamic sourcing of event instances.
		</p><p>
			Currently, EsperIO provides the following additional event representations:
		</p><div class="itemizedlist"><ul type="disc" compact><li><p>
					Apache Axiom: Streaming API for XML (StAX) implementation
				</p></li></ul></div><p>
			Please see the EsperIO documentation for details on the above.
		</p><p>
			The chapter on <a href="#custom-event-representation" title="11.5.&nbsp;Custom Event Representation">Section&nbsp;11.5, &#8220;Custom Event Representation&#8221;</a> explains how to create your own custom event representation.
		</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="eventrep-update"></a>2.9.&nbsp;Updating and Versioning Events</h2></div></div><div></div></div><a class="indexterm" name="d0e1635"></a><a class="indexterm" name="d0e1640"></a><p>
			To summarize, an event is an immutable record of a past occurrence of an action or state change, and event properties contain useful information about an event.
        </p><p>
			The length of time an event is of interest to the event processing engine (retention time) depends on your EPL statements, and especially the data window, pattern and output rate 
			limiting clauses of your statements.
        </p><p>
			During the retention time of an event more information about the event may become available, such as additional properties or changes to existing properties. 
			Esper provides the concept of revision event type to handle such situations. A revision event type instructs the engine that new versions of an existing event are to be processed that update, amend or add to an existing event.
        </p><p>
			Revision event types work together with the named window feature of the engine: A named window provides an explicit expiration policy for event instances that can be updated,
			thereby allowing the engine to retain only those versions that are relevant to any retained event and discarding updates to events not retained.
        </p><p>
			Please see <a href="#named_update" title="4.17.8.&nbsp;Updating and Versioning Events in Named Windows">Section&nbsp;4.17.8, &#8220;Updating and Versioning Events in Named Windows&#8221;</a> for further instructions and examples.
		</p><p>
			Note that patterns do not reflect changes to past events. For the temporal nature of patterns, any changes to events that were observed in the past do not reflect upon current pattern state.
		</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="eventrep-coarse"></a>2.10.&nbsp;Coarse-Grained Events</h2></div></div><div></div></div><a class="indexterm" name="d0e1662"></a><a class="indexterm" name="d0e1667"></a><p>
			Your application events may consist of fairly comprehensive, coarse-grained structures or documents. For example in business-to-business integration scenarios, XML documents or other event objects can be rich deeply-nested graphs of event properties.
        </p><p>
			To extract information from a coarse-grained event or to perform bulk operations on the rows of the property graph in an event, Esper provides a convenient syntax: 
			When specifying a filter expression in a pattern or in a <tt class="literal">select</tt> clause, it may contain a contained-event selection syntax, as further described in <a href="#epl-containedeventselect" title="4.20.&nbsp;Contained-Event Selection">Section&nbsp;4.20, &#8220;Contained-Event Selection&#8221;</a>.
		</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="eventrep-insertinto"></a>2.11.&nbsp;Event Objects Populated by <tt class="literal">Insert Into</tt></h2></div></div><div></div></div><a class="indexterm" name="d0e1686"></a><p>
			The <tt class="literal">insert into</tt> clause can populate plain-old Java object events and <tt class="literal">java.util.Map</tt> events directly from the results of <tt class="literal">select</tt> clause expressions. Simply use the event type name as the stream name in the <tt class="literal">insert into</tt> clause as described in <a href="#epl-insert-into" title="4.10.&nbsp;Merging Streams and Continuous Insertion: the Insert Into Clause">Section&nbsp;4.10, &#8220;Merging Streams and Continuous Insertion: the Insert Into Clause&#8221;</a>.
        </p><p>
			The column names specified in the <tt class="literal">select</tt> and <tt class="literal">insert into</tt> clause must match available writable properties in the event object to be populated (the target event type). The expression result types of any expressions in the <tt class="literal">select</tt> clause must also be compatible with the property types of the target event type.
		</p><p>
			Consider the following example statement:
		</p><pre class="programlisting">insert into com.mycompany.NewEmployeeEvent 
select fname as firstName, lname as lastName from HRSystemEvent</pre><p>
			The above example specifies the fully-qualified class name of <tt class="literal">NewEmployeeEvent</tt>. The engine instantianes <tt class="literal">NewEmployeeEvent</tt> for each result row and populates the <tt class="literal">firstName</tt> and <tt class="literal">lastName</tt> properties of each instance from the result of <tt class="literal">select</tt> clause expressions. The <tt class="literal">HRSystemEvent</tt> in the example is assumed to have <tt class="literal">lname</tt> and <tt class="literal">fname</tt> properties.
		</p><p>
			Note how the example uses the <tt class="literal">as</tt>-keyword to assign column names that match the property names of the <tt class="literal">NewEmployeeEvent</tt> target event. If the property names of the source and target events are the same, the <tt class="literal">as</tt>-keyword is not required.
		</p><p>
			The next example is an alternate form and specifies property names within the <tt class="literal">insert into</tt> clause instead. The example also assumes that <tt class="literal">NewEmployeeEvent</tt> has been defined or imported via configuration since it does not specify the event class package name:
		</p><pre class="programlisting">insert into NewEmployeeEvent(firstName, lastName) 
select fname, lname from HRSystemEvent</pre><p>
			Finally, this example populates <tt class="literal">HRSystemEvent</tt> events. The example populates the value of a <tt class="literal">type</tt> property where the event has the value 'NEW' and populates a new event object with the value 'HIRED', copying the <tt class="literal">fname</tt> and <tt class="literal">lname</tt> property values to the new event object:
		</p><pre class="programlisting">insert into HRSystemEvent 
select fname, lname, 'HIRED' as type from HRSystemEvent(type='NEW')</pre><p>
          The matching of the <tt class="literal">select</tt> or <tt class="literal">insert into</tt>-clause column names to target event type's property names is case-sensitive. It is allowed to only populate a subset of all available columns in the target event type. Wildcard (<tt class="literal">*</tt>) is also allowed and copies all fields of the events or multiple events in a join.
		</p><p>
			For Java object events, your event class must provide setter-methods according to JavaBean conventions. The event class should also provide a default constructor taking no parameters. If your event class does not have 
			a default constructor, your application may configure a factory method via <tt class="literal">ConfigurationEventTypeLegacy</tt>. 
		</p><p>
			The engine follows Java standards in terms of widening, performing widening automatically in cases where widening type conversion is allowed without loss of precision, for both boxed and primitive types and including
BigInteger and BigDecimal.
		</p><p>
		    Please note the following limitations: 
		</p><div class="itemizedlist"><ul type="disc" compact><li><p>
					Event types that utilize XML <tt class="literal">org.w3c.dom.Node</tt> underlying event objects cannot be target of an <tt class="literal">insert into</tt> clause.
				</p></li></ul></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="processingmodel"></a>Chapter&nbsp;3.&nbsp;Processing Model</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="processingmodel_intro"></a>3.1.&nbsp;Introduction</h2></div></div><div></div></div><p>
			The Esper processing model is continuous:  Update listeners and/or subscribers to statements receive updated data as soon as the engine processes events for that statement, according to the statement's choice of event streams, views, filters and output rates.
        </p><p>
			As outlined in <a href="#api" title="Chapter&nbsp;9.&nbsp;API Reference">Chapter&nbsp;9, <i>API Reference</i></a> the interface for listeners is <tt class="literal">com.espertech.esper.client.UpdateListener</tt>. Implementations must provide a single <tt class="literal">update</tt> method that the engine invokes when results become available:
        </p><div class="mediaobject" align="center"><img src="../shared/images/refdoc_outputmodel_updatelistener.gif" align="middle"></div><p>
		  A second, strongly-typed and native, highly-performant method of result delivery is provided: A subscriber object is a direct binding of query results to a Java object. The object, a POJO, receives statement
results via method invocation. The subscriber class need not implement an interface or extend a superclass. Please see <a href="#api-admin-subscriber" title="9.3.3.&nbsp;Setting a Subscriber Object">Section&nbsp;9.3.3, &#8220;Setting a Subscriber Object&#8221;</a>. 
		</p><a class="indexterm" name="d0e1842"></a><p>
			The engine provides statement results to update listeners by placing results in <tt class="literal">com.espertech.esper.client.EventBean</tt> instances. A typical listener implementation queries the <tt class="literal">EventBean</tt> instances via getter methods to obtain the statement-generated results. 
        </p><div class="mediaobject" align="center"><img src="../shared/images/refdoc_outputmodel_eventbean.gif" align="middle"></div><p>
			The <tt class="literal">get</tt> method on the <tt class="literal">EventBean</tt> interface can be used to retrieve result columns by name. The property name supplied to the <tt class="literal">get</tt> method can also be used to query nested, indexed or array properties of object graphs as discussed in more detail in <a href="#event_representation" title="Chapter&nbsp;2.&nbsp;Event Representations">Chapter&nbsp;2, <i>Event Representations</i></a> and <a href="#api-event" title="9.5.&nbsp;Event and Event Type">Section&nbsp;9.5, &#8220;Event and Event Type&#8221;</a>
        </p><p>
			The <tt class="literal">getUnderlying</tt> method on the <tt class="literal">EventBean</tt> interface allows update listeners to obtain the underlying event object. For wildcard selects, the underlying event is the event object that was sent into the engine via the <tt class="literal">sendEvent</tt> method. 
			For joins and select clauses with expressions, the underlying object implements <tt class="literal">java.util.Map</tt>.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="processingmodel_nowindow"></a>3.2.&nbsp;Insert Stream</h2></div></div><div></div></div><a class="indexterm" name="d0e1890"></a><p>
			In this section we look at the output of a very simple EPL statement. The statement selects an event stream without using a data window and without applying any filtering, as follows:
        </p><pre class="programlisting">select * from Withdrawal</pre><p>
			This statement selects all <tt class="literal">Withdrawal</tt> events. Every time the engine processes an event of type <tt class="literal">Withdrawal</tt> or any sub-type of <tt class="literal">Withdrawal</tt>, it invokes all update listeners, handing the new event to each of the statement's listeners.
        </p><p>
			The term <span class="emphasis"><em>insert stream</em></span> denotes the new events arriving, and entering a data window or aggregation. The insert stream in this example is the stream of arriving Withdrawal events, and is posted to listeners as new events.
        </p><p>
			The diagram below shows a series of Withdrawal events 1 to 6 arriving over time. The number in parenthesis is the withdrawal amount, an event property that is used in the examples that discuss filtering. 
        </p><div class="figure"><a name="processingmodel_nowindow_flow"></a><div class="mediaobject" align="center"><img src="../shared/images/refdoc_outputmodel_nowindow.gif" align="middle" alt="Output example for a simple statement"></div><p class="title"><b>Figure&nbsp;3.1.&nbsp;Output  example for a simple statement</b></p></div><p>
			The example statement above results in only new events and no old events posted by the engine to the statement's listeners.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="processingmodel_lengthwindow"></a>3.3.&nbsp;Insert and Remove Stream</h2></div></div><div></div></div><a class="indexterm" name="d0e1928"></a><p>
			A length window instructs the engine to only keep the last N events for a stream. The next statement applies a length window onto the Withdrawal event stream. The statement serves to illustrate the concept of data window and events entering and leaving a data window:
        </p><pre class="programlisting">select * from Withdrawal.win:length(5)</pre><p>
			The size of this statement's length window is five events. The engine enters all arriving Withdrawal events into the length window. When the length window is full, the oldest Withdrawal event is pushed out the window. The engine indicates to listeners all events entering the window as new events, and all events leaving the window as old events. 
        </p><p>
			While the term <span class="emphasis"><em>insert stream</em></span> denotes new events arriving, the term <span class="emphasis"><em>remove stream</em></span> denotes events leaving a data window, or changing aggregation values. In this example, the remove stream is the stream of Withdrawal events that leave the length window, and such events are posted to listeners as old events. 
        </p><p>
			The next diagram illustrates how the length window contents change as events arrive and shows the events posted to an update listener.
        </p><div class="figure"><a name="processingmodel_lengthwindow_flow"></a><div class="mediaobject" align="center"><img src="../shared/images/refdoc_outputmodel_lengthwindow.gif" align="middle" alt="Output example for a length window"></div><p class="title"><b>Figure&nbsp;3.2.&nbsp;Output  example for a length window</b></p></div><p>
			As before, all arriving events are posted as new events to listeners. In addition, when event W<sub>1</sub> leaves the length window on arrival of event W<sub>6</sub>, it is posted as an old event to listeners.
        </p><p>
			Similar to a length window, a time window also keeps the most recent events up to a given time period. A time window of 5 seconds, for example, keeps the last 5 seconds of events. As seconds pass, the time window actively pushes the oldest events out of the window resulting in one or more old events posted to update listeners.
        </p><p>
			Note: By default the engine only delivers the insert stream to listeners and observers. EPL supports optional <tt class="literal">istream</tt>, <tt class="literal">irstream</tt> and <tt class="literal">rstream</tt> keywords on select-clauses and on insert-into clauses to control which stream to deliver, see <a href="#epl-select-using-istream-rstream" title="4.3.7.&nbsp;Selecting insert and remove stream events">Section&nbsp;4.3.7, &#8220;Selecting insert and remove stream events&#8221;</a>. There is also a related, engine-wide configuration setting described in <a href="#config-engine-stream-selection" title="10.4.14.&nbsp;Engine Settings related to Stream Selection">Section&nbsp;10.4.14, &#8220;Engine Settings related to Stream Selection&#8221;</a>.		
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="processingmodel_filter"></a>3.4.&nbsp;Filters and Where-clauses</h2></div></div><div></div></div><p>
			Filters to event streams allow filtering events out of a given stream before events enter a data window. The statement below shows a filter that selects Withdrawal events with an amount value of 200 or more.
        </p><pre class="programlisting">select * from Withdrawal(amount&gt;=200).win:length(5)</pre><p>
			With the filter, any Withdrawal events that have an amount of less then 200 do not enter the length window and are therefore not passed to update listeners. Filters are discussed in more detail in <a href="#epl-from-clause-filter" title="4.4.1.&nbsp;Filter-based Event Streams">Section&nbsp;4.4.1, &#8220;Filter-based Event Streams&#8221;</a> and <a href="#pattern-filter" title="5.4.&nbsp;Filter Expressions In Patterns">Section&nbsp;5.4, &#8220;Filter Expressions In Patterns&#8221;</a>.
        </p><div class="figure"><a name="processingmodel_filter_flow"></a><div class="mediaobject" align="center"><img src="../shared/images/refdoc_outputmodel_filter.gif" align="middle" alt="Output example for a statement with an event stream filter"></div><p class="title"><b>Figure&nbsp;3.3.&nbsp;Output example for a statement with an event stream filter</b></p></div><p>
			The where-clause and having-clause in statements eliminate potential result rows at a later stage in processing, after events have been processed into a statement's data window or other views.
        </p><p>
			The next statement applies a where-clause to Withdrawal events. Where-clauses are discussed in more detail in <a href="#epl-where-clause" title="4.5.&nbsp;Specifying Search Conditions: the Where Clause">Section&nbsp;4.5, &#8220;Specifying Search Conditions: the Where Clause&#8221;</a>.
        </p><pre class="programlisting">select * from Withdrawal.win:length(5) where amount &gt;= 200</pre><p>
			The where-clause applies to both new events and old events. As the diagram below shows, arriving events enter the window however only events that pass the where-clause are handed to update listeners. Also,
			as events leave the data window, only those events that pass the conditions in the where-clause are posted to listeners as old events.
        </p><div class="figure"><a name="processingmodel_where"></a><div class="mediaobject" align="center"><img src="../shared/images/refdoc_outputmodel_where.gif" align="middle" alt="Output example for a statement with where-clause"></div><p class="title"><b>Figure&nbsp;3.4.&nbsp;Output example for a statement with where-clause</b></p></div><p>
			The where-clause can contain complex conditions while event stream filters are more restrictive in the type of filters that can be specified. The next statement's where-clause applies the <tt class="literal">ceil</tt> function of the <tt class="literal">java.lang.Math</tt> Java library class in the where clause. The insert-into clause makes the results of the first statement available to the second statement:
        </p><pre class="programlisting">insert into WithdrawalFiltered select * from Withdrawal where Math.ceil(amount) &gt;= 200

select * from WithdrawalFiltered</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="processingmodel_time_window"></a>3.5.&nbsp;Time Windows</h2></div></div><div></div></div><p>
			In this section we explain the output model of statements employing a time window view and a time batch view.
        </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="processingmodel_time_window_1"></a>3.5.1.&nbsp;Time Window</h3></div></div><div></div></div><a class="indexterm" name="d0e2037"></a><p>
				A time window is a moving window extending to the specified time interval into the past based on the system time. Time windows enable us to limit the number of events considered by a query, as do length windows. 
			</p><p>
				As a practical example, consider the need to determine all accounts where the average withdrawal amount per account for the last 4 seconds of withdrawals is greater then 1000. The statement to solve this problem is shown below.
			</p><pre class="programlisting">select account, avg(amount) 
from Withdrawal.win:time(4 sec) 
group by account
having amount &gt; 1000</pre><p>
				The next diagram serves to illustrate the functioning of a time window. For the diagram, we assume a query that simply selects the event itself and does not group or filter events.
			</p><pre class="programlisting">select * from Withdrawal.win:time(4 sec)</pre><p>
				The diagram starts at a given time <tt class="literal">t</tt> and displays the contents of the time window at <tt class="literal">t + 4</tt> and <tt class="literal">t + 5 seconds</tt> and so on.
			</p><div class="figure"><a name="processingmodel_timewindow_flow"></a><div class="mediaobject" align="center"><img src="../shared/images/refdoc_outputmodel_timewindow.gif" align="middle" alt="Output example for a statement with a time window"></div><p class="title"><b>Figure&nbsp;3.5.&nbsp;Output example for a statement with a time window</b></p></div><p>
				The activity as illustrated by the diagram:
			</p><div class="orderedlist"><ol type="1"><li><p>
						At time <tt class="literal">t + 4 seconds</tt> an event <tt class="literal">W<sub>1</sub></tt> arrives and enters the time window. The engine reports the new event to update listeners.
					</p></li><li><p>
						At time <tt class="literal">t + 5 seconds</tt> an event <tt class="literal">W<sub>2</sub></tt> arrives and enters the time window. The engine reports the new event to update listeners.
					</p></li><li><p>
						At time <tt class="literal">t + 6.5 seconds</tt> an event <tt class="literal">W<sub>3</sub></tt> arrives and enters the time window. The engine reports the new event to update listeners.
					</p></li><li><p>
						At time <tt class="literal">t + 8 seconds</tt> event <tt class="literal">W<sub>1</sub></tt> leaves the time window. The engine reports the event as an old event to update listeners.
					</p></li></ol></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="processingmodel_time_batch_1"></a>3.5.2.&nbsp;Time Batch</h3></div></div><div></div></div><a class="indexterm" name="d0e2119"></a><p>
				The time batch view buffers events and releases them every specified time interval in one update. Time windows control the evaluation of events, as does the length batch window. 
			</p><p>
				The next diagram serves to illustrate the functioning of a time batch view. For the diagram, we assume a simple query as below:
			</p><pre class="programlisting">select * from Withdrawal.win:time_batch(4 sec)</pre><p>
				The diagram starts at a given time <tt class="literal">t</tt> and displays the contents of the time window at <tt class="literal">t + 4</tt> and <tt class="literal">t + 5 seconds</tt> and so on.
			</p><div class="figure"><a name="processingmodel_timebatch_flow"></a><div class="mediaobject" align="center"><img src="../shared/images/refdoc_outputmodel_timebatch.gif" align="middle" alt="Output example for a statement with a time batch view"></div><p class="title"><b>Figure&nbsp;3.6.&nbsp;Output example for a statement with a time batch view</b></p></div><p>
				The activity as illustrated by the diagram:
			</p><div class="orderedlist"><ol type="1"><li><p>
						At time <tt class="literal">t + 1 seconds</tt> an event <tt class="literal">W<sub>1</sub></tt> arrives and enters the batch. No call to inform update listeners occurs.
					</p></li><li><p>
						At time <tt class="literal">t + 3 seconds</tt> an event <tt class="literal">W<sub>2</sub></tt> arrives and enters the batch. No call to inform update listeners occurs.
					</p></li><li><p>
						At time <tt class="literal">t + 4 seconds</tt> the engine processes the batched events and a starts a new batch. The engine reports events <tt class="literal">W<sub>1</sub></tt> and <tt class="literal">W<sub>2</sub></tt> to update listeners.
					</p></li><li><p>
						At time <tt class="literal">t + 6.5 seconds</tt> an event <tt class="literal">W<sub>3</sub></tt> arrives and enters the batch. No call to inform update listeners occurs.
					</p></li><li><p>
						At time <tt class="literal">t + 8 seconds</tt> the engine processes the batched events and a starts a new batch. The engine reports the event <tt class="literal">W<sub>3</sub></tt> as new data to update listeners. The engine reports the events <tt class="literal">W<sub>1</sub></tt> and <tt class="literal">W<sub>2</sub></tt> as old data (prior batch) to update listeners.
					</p></li></ol></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="processingmodel_batch"></a>3.6.&nbsp;Batch Windows</h2></div></div><div></div></div><a class="indexterm" name="d0e2223"></a><p>
			The built-in data windows that act on batches of events are the <tt class="literal">win:time_batch</tt> and the <tt class="literal">win:length_batch</tt> views. The <tt class="literal">win:time_batch</tt> data window collects events arriving during a given time interval and posts collected events as a batch to listeners at the end of the time interval. The <tt class="literal">win:length_batch</tt> data window collects a given number of events and posts collected events as a batch to listeners when the given number of events has collected.
		</p><p>
			Let's look at how a time batch window may be used:
		</p><pre class="programlisting">select account, amount from Withdrawal.win:time_batch(1 sec)</pre><p>
			The above statement collects events arriving during a one-second interval, at the end of which the engine posts the collected events as new events (insert stream) to each listener. The engine posts the events collected during the prior batch as old events (remove stream). The engine starts posting events to listeners one second after it receives the first event and thereon.
		</p><p>
			For statements containing aggregation functions and/or a <tt class="literal">group by</tt> clause, the engine posts consolidated aggregation results for an event batch. For example, consider the following statement:
		</p><pre class="programlisting">select sum(amount) as mysum from Withdrawal.win:time_batch(1 sec)</pre><p>
			Note that output rate limiting also generates batches of events following the output model as discussed here.
		</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="processingmodel_aggregation"></a>3.7.&nbsp;Aggregation and Grouping</h2></div></div><div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="processingmodel_aggregation_irstream"></a>3.7.1.&nbsp;Insert and Remove Stream</h3></div></div><div></div></div><p>
				Statements that aggregate events via aggregation functions also post remove stream events as aggregated values change.
			</p><p>
				Consider the following statement that alerts when 2 Withdrawal events have been received:
			</p><pre class="programlisting">select count(*) as mycount from Withdrawal having count(*) = 2</pre><p>
				When the engine encounters the second withdrawal event, the engine posts a new event to update listeners. The value of the "mycount" property on that new event is 2.
				Additionally, when the engine encounters the third Withdrawal event, it posts an old event to update listeners containing the prior value of the count. The value of the "mycount" property on that old event is also 2.
			</p><p>
				The <tt class="literal">istream</tt> or <tt class="literal">rstream</tt> keyword can be used to eliminate either new events or old events posted to listeners. The next statement uses the <tt class="literal">istream</tt> keyword causing the engine to call the listener only once when the second Withdrawal event is received:
			</p><pre class="programlisting">select istream count(*) as mycount from Withdrawal having count(*) = 2</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="processingmodel_aggregation_output"></a>3.7.2.&nbsp;Output for Aggregation and Group-By</h3></div></div><div></div></div><p>
				Following SQL (Standard Query Language) standards for queries against relational databases, the presence or absence of aggregation functions and the presence or absence of the <tt class="literal">group by</tt> clause dictates the number of rows posted by the engine to listeners. The next sections outline the output model for batched events under aggregation and grouping. The examples also apply to data windows that don't batch events and post results continously as events arrive or leave data windows. The examples also apply to patterns providing events when a complete pattern matches.
			</p><p>
				In summary, as in SQL, if your query only selects aggregation values, the engine provides one row of aggregated values. It provides that row every time the aggregation is updated (insert stream), which is when events arrive or a batch of events gets processed, and when the events leave a data window or a new batch of events arrives. The remove stream then consists of prior aggregation values.
			</p><p>
				Also as in SQL, if your query selects non-aggregated values along with aggregation values in the select clause, the engine provides a row per event. The insert stream then consists of the aggregation values at the time the event arrives, while the remove stream is the aggregation value at the time the event leaves a data window, if any is defined in your query.
			</p><p>
				The documentation provides output examples for query types in <a href="#appendix_outputspec" title="Appendix&nbsp;A.&nbsp;Output Reference and Samples">Appendix&nbsp;A, <i>Output Reference and Samples</i></a>, and the next sections outlines each query type.
			</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="processingmodel_aggregation_batch_unagg"></a>3.7.2.1.&nbsp;Un-aggregated and Un-grouped</h4></div></div><div></div></div><p>
					An example statement for the un-aggregated and un-grouped case is as follows:
				</p><pre class="programlisting">select * from Withdrawal.win:time_batch(1 sec)</pre><p>
					At the end of a time interval, the engine posts to listeners one row for each event arriving during the time interval.
				</p><p>
					The appendix provides a complete example including input and output events over time at <a href="#outputspec-simple" title="A.2.&nbsp;Output for Un-aggregated and Un-grouped Queries">Section&nbsp;A.2, &#8220;Output for Un-aggregated and Un-grouped Queries&#8221;</a>
				</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="processingmodel_aggregation_batch_full_agg"></a>3.7.2.2.&nbsp;Fully Aggregated and Un-grouped</h4></div></div><div></div></div><p>
					If your statement only selects aggregation values and does not group, your statement may look as the example below:
				</p><pre class="programlisting">select sum(amount) 
from Withdrawal.win:time_batch(1 sec)</pre><p>
					At the end of a time interval, the engine posts to listeners a single row indicating the aggregation result. The aggregation result aggregates all events collected during the time interval.
				</p><p>
					The appendix provides a complete example including input and output events over time at <a href="#outputspec-rowforall" title="A.3.&nbsp;Output for Fully-aggregated and Un-grouped Queries">Section&nbsp;A.3, &#8220;Output for Fully-aggregated and Un-grouped Queries&#8221;</a>
				</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="processingmodel_aggregation_batch_event_agg"></a>3.7.2.3.&nbsp;Aggregated and Un-Grouped</h4></div></div><div></div></div><p>
					If your statement selects non-aggregated properties and aggregation values, and does not group, your statement may be similar to this statement:
				</p><pre class="programlisting">select account, sum(amount) 
from Withdrawal.win:time_batch(1 sec)</pre><p>
					At the end of a time interval, the engine posts to listeners one row per event. The aggregation result aggregates all events collected during the time interval.
				</p><p>
					The appendix provides a complete example including input and output events over time at <a href="#outputspec-aggregateall" title="A.4.&nbsp;Output for Aggregated and Un-grouped Queries">Section&nbsp;A.4, &#8220;Output for Aggregated and Un-grouped Queries&#8221;</a>
				</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="processingmodel_aggregation_batch_group_agg"></a>3.7.2.4.&nbsp;Fully Aggregated and Grouped</h4></div></div><div></div></div><p>
					If your statement selects aggregation values and all non-aggregated properties in the <tt class="literal">select</tt> clause are listed in the <tt class="literal">group by</tt> clause, then your statement may look similar to this example:
				</p><pre class="programlisting">select account, sum(amount) 
from Withdrawal.win:time_batch(1 sec) 
group by account</pre><p>
					At the end of a time interval, the engine posts to listeners one row per unique account number. The aggregation result aggregates per unique account.
				</p><p>
					The appendix provides a complete example including input and output events over time at <a href="#outputspec-groupedrowpergroup" title="A.5.&nbsp;Output for Fully-aggregated and Grouped Queries">Section&nbsp;A.5, &#8220;Output for Fully-aggregated and Grouped Queries&#8221;</a>
				</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="processingmodel_aggregation_batch_event_agg_group"></a>3.7.2.5.&nbsp;Aggregated and Grouped</h4></div></div><div></div></div><p>
					If your statement selects non-aggregated properties and aggregation values, and groups only some properties using the <tt class="literal">group by</tt> clause,  your statement may look as below:
				</p><pre class="programlisting">select account, accountName, sum(amount) 
from Withdrawal.win:time_batch(1 sec) 
group by account</pre><p>
					At the end of a time interval, the engine posts to listeners one row per event. The aggregation result aggregates per unique account.
				</p><p>
					The appendix provides a complete example including input and output events over time at <a href="#outputspec-aggregategrouped" title="A.6.&nbsp;Output for Aggregated and Grouped Queries">Section&nbsp;A.6, &#8220;Output for Aggregated and Grouped Queries&#8221;</a>
				</p></div></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="epl_clauses"></a>Chapter&nbsp;4.&nbsp;EPL Reference: Clauses</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="epl-intro"></a>4.1.&nbsp;EPL Introduction</h2></div></div><div></div></div><p>
			The Event Processing Language (EPL) is a SQL-like language with <tt class="literal">SELECT</tt>, <tt class="literal">FROM</tt>, <tt class="literal">WHERE</tt>, <tt class="literal">GROUP BY</tt>, <tt class="literal">HAVING</tt> and <tt class="literal">ORDER BY</tt> clauses. Streams replace tables as the source of data with events replacing rows as the basic unit of data. Since events are composed of data, the SQL concepts of correlation through joins, filtering and aggregation through grouping can be effectively leveraged. The <tt class="literal">INSERT INTO</tt> clause is recast as a means of forwarding events to other streams for further downstream processing. External data accessible through JDBC may be queried and joined with the stream data. Additional clauses such as the <tt class="literal">PATTERN</tt> and <tt class="literal">OUTPUT</tt> clauses are also available to provide the missing SQL language constructs specific to event processing.
        </p><p>
			EPL statements are used to derive and aggregate information from one or more streams of events, and to join or merge event streams. This section outlines EPL syntax. It also outlines the built-in views, which are the building blocks for deriving and aggregating information from event streams. 
        </p><p>
			EPL statements contain definitions of one or more views. Similar to tables in a SQL statement, views define the data available for querying and filtering. 
			Some views represent windows over a stream of events. Other views derive statistics from event properties, group events or handle unique event property values.
            Views can be staggered onto each other to build a chain of views. The Esper engine makes sure that views are reused among EPL statements for efficiency.
        </p><p>
			The built-in set of views is:
         </p><div class="orderedlist"><ol type="1" compact><li><p>
					Data window views: <tt class="literal">win:length</tt>, <tt class="literal">win:length_batch</tt>, <tt class="literal">win:time</tt>, <tt class="literal">win:time_batch</tt>, <tt class="literal">win:time_length_batch</tt>, <tt class="literal">win:time_accum</tt>, <tt class="literal">win:ext_timed</tt>, <tt class="literal">ext:sort_window</tt>, <tt class="literal">ext:time_order</tt>, <tt class="literal">std:unique</tt>, <tt class="literal">std:groupby</tt>, <tt class="literal">std:lastevent</tt>, <tt class="literal">std:firstevent</tt>, <tt class="literal">std:firstunique</tt>, <tt class="literal">win:firstlength</tt>,  <tt class="literal">win:firsttime</tt>.
				</p></li><li><p>
					Views that derive statistics: <tt class="literal">std:size</tt>, <tt class="literal">stat:uni</tt>, <tt class="literal">stat:linest</tt>, <tt class="literal">stat:correl</tt>, <tt class="literal">stat:weighted_avg</tt>.
				</p></li></ol></div><p>
			EPL provides the concept of <span class="emphasis"><em>named window</em></span>. Named windows are data windows that can be inserted-into and deleted-from by one or more statements, and that can queried by one or more statements. Named windows have a global character, being visible and shared across an engine instance beyond a single statement. Use the <tt class="literal">CREATE WINDOW</tt> clause to create named windows. Use the <tt class="literal">INSERT INTO</tt> clause to insert data into a named window, the <tt class="literal">ON DELETE</tt> clause to remove events from a named window, and the <tt class="literal">ON SELECT</tt> clause to perform a non-continuous fire-once query on a named window. Finally, the name of the named window can occur in a statement's <tt class="literal">FROM</tt> clause to query a named window or include the named window in a join or subquery.
        </p><p>
			<span class="emphasis"><em>Variables</em></span> can come in handy to parameterize statements and change parameters on-the-fly and in response to events. Variables can be used in an expression anywhere in a statement as well as in the output clause for dynamic control of output rates.
        </p><p>
			Esper can be extended by plugging-in custom developed views and aggregation functions.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="epl-select-syntax"></a>4.2.&nbsp;EPL Syntax</h2></div></div><div></div></div><p>
			EPL queries are created and stored in the engine, and publish results to listeners as events are received by the engine or timer events occur that match the criteria specified in the query. Events can also be obtained from running EPL queries via the <tt class="literal">safeIterator</tt> and <tt class="literal">iterator</tt> methods that provide a pull-data API.
		</p><p>
			The <tt class="literal">select</tt> clause in an EPL query specifies the event properties or events to retrieve. The <tt class="literal">from</tt> clause in an EPL query specifies the event stream definitions and stream names to use. The <tt class="literal">where</tt> clause in an EPL query specifies search conditions that specify which event or event combination to search for. For example, the following statement returns the average price for IBM stock ticks in the last 30 seconds.
		</p><pre class="programlisting">select avg(price) from StockTick.win:time(30 sec) where symbol='IBM'</pre><p>
			EPL queries follow the below syntax. EPL queries can be simple queries or more complex queries. A simple select contains only a <tt class="literal">select</tt> clause and a single stream definition. Complex EPL queries can be build that feature a more elaborate select list utilizing expressions, may join multiple streams, may contain a <tt class="literal">where</tt> clause with search conditions and so on.
		</p><pre class="synopsis">[insert into <span class="emphasis"><em>insert_into_def</em></span>]
select <span class="emphasis"><em>select_list</em></span>
from <span class="emphasis"><em>stream_def</em></span> [as name] [, <span class="emphasis"><em>stream_def</em></span> [as name]] [,...]
[where <span class="emphasis"><em>search_conditions</em></span>]
[group by <span class="emphasis"><em>grouping_expression_list</em></span>]
[having <span class="emphasis"><em>grouping_search_conditions</em></span>]
[output <span class="emphasis"><em>output_specification</em></span>]
[order by <span class="emphasis"><em>order_by_expression_list</em></span>]
[limit <span class="emphasis"><em>num_rows</em></span>]
</pre><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="epl-syntax-time-periods"></a>4.2.1.&nbsp;Specifying Time Periods</h3></div></div><div></div></div><p>
					Time-based windows as well as pattern observers and guards take a time period as a parameter. Time periods follow the syntax below.
			</p><pre class="synopsis">time-period : [<span class="emphasis"><em>day-part</em></span>] [<span class="emphasis"><em>hour-part</em></span>] [<span class="emphasis"><em>minute-part</em></span>] [<span class="emphasis"><em>seconds-part</em></span>] [<span class="emphasis"><em>milliseconds-part</em></span>]

day-part : <span class="emphasis"><em>(number|variable_name)</em></span> ("days" | "day")
hour-part : <span class="emphasis"><em>(number|variable_name)</em></span> ("hours" | "hour")
minute-part : <span class="emphasis"><em>(number|variable_name)</em></span> ("minutes" | "minute" | "min")
seconds-part : <span class="emphasis"><em>(number|variable_name)</em></span> ("seconds" | "second" | "sec")
milliseconds-part : <span class="emphasis"><em>(number|variable_name)</em></span> ("milliseconds" | "millisecond" | "msec")</pre><p>
					Some examples of time periods are:
			</p><pre class="programlisting">10 seconds
10 minutes 30 seconds
20 sec 100 msec
1 day 2 hours 20 minutes 15 seconds 110 milliseconds
0.5 minutes</pre><p>
					Variable names and substitution parameters '<tt class="literal">?</tt>' for prepared statements are also allowed as part of a time period expression.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="epl-syntax-comments"></a>4.2.2.&nbsp;Using Comments</h3></div></div><div></div></div><p>
				Comments can appear anywhere in the EPL or pattern statement text where whitespace is allowed. Comments can be written in two ways: slash-slash (<tt class="literal">// ...</tt>) comments and slash-star (<tt class="literal">/* ... */</tt>) comments.
			</p><p>
				Slash-slash comments extend to the end of the line:
			</p><pre class="programlisting">// This comment extends to the end of the line.
// Two forward slashes with no whitespace between them begin such comments.

select * from MyEvent  // this is a slash-slash comment

// All of this text together is a valid statement.</pre><p>
				Slash-star comments can span multiple lines:
			</p><pre class="programlisting">/* This comment is a "slash-star" comment that spans multiple lines.
 * It begins with the slash-star sequence with no space between the '/' and '*' characters.
 * By convention, subsequent lines can begin with a star and are aligned, but this is 
 * not required.
 */		
select * from MyEvent  /* this also works */</pre><p>
				Comments styles can also be mixed:
			</p><pre class="programlisting">select field1, // first comment
  /* second comment*/  field2
  from MyEvent</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="epl-syntax-keywords"></a>4.2.3.&nbsp;Reserved Keywords</h3></div></div><div></div></div><a class="indexterm" name="d0e2648"></a><p>
				Certain words such as <tt class="literal">select</tt>, <tt class="literal">delete</tt> or <tt class="literal">set</tt> are reserved and may not be used as identifiers. Please consult <a href="#appendix_keywords" title="Appendix&nbsp;B.&nbsp;Reserved Keywords">Appendix&nbsp;B, <i>Reserved Keywords</i></a> for the list of reserved keywords and permitted keywords.
			</p><p>
				Names of built-in functions and certain auxiliary keywords are permitted as event property names and in the rename syntax of the <tt class="literal">select</tt> clause. For example, <tt class="literal">count</tt> is acceptable. 
			</p><p>
				Consider the example below, which assumes that <tt class="literal">'last'</tt> is an event property of MyEvent:
			</p><pre class="programlisting">// valid
select last, count(*) as count from MyEvent</pre><p>
				This example shows an incorrect use of a reserved keyword:
			</p><pre class="programlisting">// invalid
select insert from MyEvent</pre><p>
				EPL offers an escape syntax for reserved keywords: Event properties as well as event or stream names may be escaped via the backwards apostrophe <tt class="literal">`</tt> (ASCII 96) character.
			</p><p>
				The next example queries an event type by name <tt class="literal">Order</tt> (a reserved keyword) that provides a property by name <tt class="literal">insert</tt> (a reserved keyword):
			</p><pre class="programlisting">// valid
select `insert` from `Order`</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="epl-syntax-datatype"></a>4.2.4.&nbsp;Data Types</h3></div></div><div></div></div><a class="indexterm" name="d0e2701"></a><p>
				EPL honors all Java built-in primitive and boxed types, including <tt class="literal">java.math.BigInteger</tt> and <tt class="literal">java.math.BigDecimal</tt>.
			</p><p>
				EPL also follows Java standards in terms of widening, performing widening automatically in cases where widening type conversion is allowed without loss of precision, for both boxed and primitive types and including <tt class="literal">BigInteger</tt> and <tt class="literal">BigDecimal</tt>:
			</p><div class="orderedlist"><ol type="1" compact><li><p>
						byte to short, int, long, float, double, BigInteger or BigDecimal
					</p></li><li><p>
						short to int, long, float, or double, BigInteger or BigDecimal
					</p></li><li><p>
						char to int, long, float, or double, BigInteger or BigDecimal
					</p></li><li><p>
						int to long, float, or double, BigInteger or BigDecimal
					</p></li><li><p>
						long to float or double, BigInteger or BigDecimal
					</p></li><li><p>
						float to double or BigDecimal
					</p></li><li><p>
						double to BigDecimal
					</p></li></ol></div><p>
				In cases where loss of precision is possible because of narrowing requirements, EPL compilation outputs a compilation error.
			</p><p>
				EPL supports casting via the <tt class="literal">cast</tt> function.
			</p><p>
				EPL returns double-type values for division regardless of operand type. EPL can also be configured to follow Java rules for integer arithmetic instead as described in <a href="#config-engine-expression" title="10.4.18.&nbsp;Engine Settings related to Expression Evaluation">Section&nbsp;10.4.18, &#8220;Engine Settings related to Expression Evaluation&#8221;</a>.
			</p><p>
				Division by zero returns positive or negative infinity. Division by zero can be configured to return null instead.
			</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="epl-syntax-datatype-constants"></a>4.2.4.1.&nbsp;Data Type of Constants</h4></div></div><div></div></div><a class="indexterm" name="d0e2758"></a><a class="indexterm" name="d0e2761"></a><p>
					An EPL constant is a number or a character string that indicates a fixed value. Constants can be used as expressions in many EPL statements, including variable assignment and case-when statements. They can also be used as parameter values for many built-in objects and clauses. Constants are also called literals.				
				</p><p>
					EPL supports the standard SQL constant notation as well as Java data type literals.
				</p><p>
					The following are types of EPL constants:
				</p><div class="table"><a name="d0e2770"></a><p class="title"><b>Table&nbsp;4.1.&nbsp;Types of EPL constants</b></p><table summary="Types of EPL constants" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>Type</th><th>Description</th><th>Examples</th></tr></thead><tbody><tr><td>string</td><td>A single character to an unlimited number of characters. Valid delimiters are the single quote (') or double quote (").</td><td><pre class="programlisting">select 'volume' as field1,
   "sleep" as field2, 
  "\u0041" as unicodeA</pre></td></tr><tr><td>boolean</td><td>A boolean value.</td><td><pre class="programlisting">select true as field1, 
  false as field2</pre></td></tr><tr><td>integer</td><td>An integer value (4 byte).</td><td><pre class="programlisting">select 1 as field1, 
  -1 as field2, 
  1e2 as field3</pre></td></tr><tr><td>long</td><td>A long value (8 byte). Use the "L" or "l" (lowercase L) suffix.</td><td><pre class="programlisting">select 1L as field1, 
  1l as field2</pre></td></tr><tr><td>double</td><td>A double-precision 64-bit IEEE 754 floating point.</td><td><pre class="programlisting">select 1.67 as field1, 
  167e-2 as field2, 
  1.67d as field3</pre></td></tr><tr><td>float</td><td>A single-precision 32-bit IEEE 754 floating point. Use the "f" suffix.</td><td><pre class="programlisting">select 1.2f as field1, 
  1.2F as field2</pre></td></tr><tr><td>byte</td><td>A 8-bit signed two's complement integer.</td><td><pre class="programlisting">select 0x10 as field1</pre></td></tr></tbody></table></div><p>
					EPL does not have a single-byte character data type for its literals. Single character literals are treated as string.
				</p><p>
					Internal byte representation and boundary values of constants follow the Java standard.
				</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="epl-syntax-datatype-bignumber"></a>4.2.4.2.&nbsp;BigInteger and BigDecimal</h4></div></div><div></div></div><p>
					EPL automatically performs widening of numbers to <tt class="literal">BigInteger</tt> and <tt class="literal">BigDecimal</tt> as required, and employs the respective <tt class="literal">equals</tt>, <tt class="literal">compareTo</tt> and arithmetic methods provided by <tt class="literal">BigInteger</tt> and <tt class="literal">BigDecimal</tt>.
				</p><p>
					To explicitly create <tt class="literal">BigInteger</tt> and <tt class="literal">BigDecimal</tt> constants in EPL, please use the cast syntax : <tt class="literal">cast(<span class="emphasis"><em>value</em></span>, BigInteger)</tt>.
				</p><p>
					Note that since <tt class="literal">BigDecimal.valueOf(1.0)</tt> is not the same as <tt class="literal">BigDecimal.valueOf(1)</tt> (in terms of equality through <tt class="literal">equals</tt>), care should be taken towards the consistent use of scale.
				</p><p>
					When using aggregation functions for <tt class="literal">BigInteger</tt> and <tt class="literal">BigDecimal</tt> values, please note these limitations:
				</p><div class="orderedlist"><ol type="1" compact><li><p>
							The <tt class="literal">median</tt>, <tt class="literal">stddev</tt> and <tt class="literal">avedev</tt> aggregation functions operate on the double value of the object and return a double value.
						</p></li><li><p>
							All other aggregation functions return <tt class="literal">BigDecimal</tt> or <tt class="literal">BigInteger</tt> values (except <tt class="literal">count</tt>).
						</p></li></ol></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="epl-syntax-annotation"></a>4.2.5.&nbsp;Annotation</h3></div></div><div></div></div><a class="indexterm" name="d0e2930"></a><p>
				An annotation is an addition made to information in a statement. Esper provides certain built-in annotations for defining statement name, adding a statement description or for tagging statements such as for managing statements or directing statement output. 
				Other then the built-in annotations, applications can provide their own annotation classes that the EPL compiler can populate.
			</p><p>
				An annotation is part of the statement text and precedes the EPL select or pattern statement. Annotations are therefore part of the EPL grammar. The syntax for annotations follows the host language (Java, .NET) annotation syntax:
			</p><pre class="synopsis">@<span class="emphasis"><em>annotation_name</em></span> [(<span class="emphasis"><em>annotation_parameters</em></span>)]</pre><p>
				An annotation consists of the annotation name and optional annotation parameters. The <span class="emphasis"><em>annotation_name</em></span> is the simple class name or fully-qualified class name of the annotation class. The optional <span class="emphasis"><em>annotation_parameters</em></span> 
				are a list of key-value pairs following the syntax:
			</p><pre class="synopsis">@<span class="emphasis"><em>annotation_name</em></span> (<span class="emphasis"><em>attribute_name</em></span> = <span class="emphasis"><em>attribute_value</em></span>, [name=value, ...])</pre><p>
				The <span class="emphasis"><em>attribute_name</em></span> is an identifier that must match the attributes defined by the annotation class. An <span class="emphasis"><em>attribute_value</em></span> is a constant of any of the primitive types or string, an array, an enumeration value or another (nested) annotation. Null values are not allowed as annotation attribute values. Enumeration values are supported in EPL statements and not support in statements created via the <tt class="literal">createPattern</tt> method.
			</p><p>
				Use the <tt class="literal">getAnnotations</tt> method of <tt class="literal">EPStatement</tt> to obtain annotations provided via statement text.
			</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="epl-syntax-annotation-application"></a>4.2.5.1.&nbsp;Application-Provided Annotations</h4></div></div><div></div></div><a class="indexterm" name="d0e2986"></a><p>
					Your application may provide its own annotation classes. The engine detects and populates annotation instances for application annotation classes.
				</p><p>
					To enable the engine to recognize application annotation classes, your annotation name must include the package name (i.e. be fully-qualified) or your engine configuration must import the annotation class or package via the configuration API.  
				</p><p>
					For example, assume that your application defines an annotation in its application code as follows:
				</p><pre class="programlisting">public @interface ProcessMonitor {
  String processName();
  boolean isLongRunning default false;
  int[] subProcessIds;
}</pre><p>
					Shown next is an EPL statement text that utilizes the annotation class defined earlier:
				</p><pre class="programlisting">@ProcessMonitor(processName='CreditApproval',
  isLongRunning=true, subProcessIds = {1, 2, 3} )
  
select count(*) from ProcessEvent(processId in (1, 2, 3).win:time(30)</pre><p>
					Above example assumes the <tt class="literal">ProcessMonitor</tt> annotation class is imported via configuration XML or API. Here is an example API call to import annotations provided by a package <tt class="literal">com.mycompany.myannotations</tt>:
				</p><pre class="programlisting">epService.getEPAdministrator().getConfiguration().addImport("com.mycompany.myannotations.*");</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="epl-syntax-annotation-builtin"></a>4.2.5.2.&nbsp;Built-In Annotations</h4></div></div><div></div></div><a class="indexterm" name="d0e3016"></a><p>
					The list of built-in EPL annotations is:
				</p><div class="table"><a name="d0e3023"></a><p class="title"><b>Table&nbsp;4.2.&nbsp;Built-In EPL Annotations</b></p><table summary="Built-In EPL Annotations" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>Name</th><th>Purpose and Attributes</th><th>Example</th></tr></thead><tbody><tr><td>Name</td><td><p>Provides a statement name. Attributes are:</p><p>value : Statement name.</p></td><td><pre class="programlisting">@Name("MyStatementName")</pre></td></tr><tr><td>Description</td><td><p>Provides a statement textual description. Attributes are:</p><p>value : Statement description.</p></td><td><pre class="programlisting">@Description("A statement description 
is placed here.")</pre></td></tr><tr><td>Tag</td><td><p>For tagging a statement with additional information. Attributes are:</p><p>name : Tag name.</p><p>value : Tag value.</p></td><td><pre class="programlisting">@Tag(name="MyTagName", 
 value="MyTagValue")</pre></td></tr><tr><td>Priority</td><td><p>Applicable when an event (or schedule) matches filter criteria for multiple statements: Defines the order of statement processing (requires an engine-level setting).</p><p>Attributes are:</p><p>value : priority value.</p></td><td><pre class="programlisting">@Priority(10)</pre></td></tr><tr><td>Drop</td><td><p>Applicable when an event (or schedule) matches filter criteria for multiple statements, drops the event after processing the statement (requires an engine-level setting).</p><p>No attributes.</p></td><td><pre class="programlisting">@Drop</pre></td></tr></tbody></table></div><p>
					The following example statement text specifies some of the built-in annotations in combination:
				</p><pre class="programlisting">@Name("RevenuePerCustomer")
@Description("Outputs revenue per customer considering all events encountered so far.")
@Tag(name="grouping", value="customer")

select customerId, sum(revenue) from CustomerRevenueEvent</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="epl-syntax-annotation-name"></a>4.2.5.3.&nbsp;@Name</h4></div></div><div></div></div><p>
					Use the @Name EPL annotation to specify a statement name within the EPL statement itself, as an alternative to specifying the statement name via API.
				</p><p>
					If your application is also providing a statement name through the API, the statement name provided through the API overrides the annotation-provided statement name.
				</p><p>
					Example:
				</p><pre class="programlisting">@Name("SecurityFilter1") select * from SecurityFilter(ip="127.0.0.1")</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="epl-syntax-annotation-description"></a>4.2.5.4.&nbsp;@Description</h4></div></div><div></div></div><p>
					Use the @Description EPL annotation to add a statement textual description.
				</p><p>
					Example:
				</p><pre class="programlisting">@Description('This statement filters localhost.') select * from SecurityFilter(ip="127.0.0.1")</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="epl-syntax-annotation-tag"></a>4.2.5.5.&nbsp;@Tag</h4></div></div><div></div></div><p>
					Use the @Tag EPL annotation to tag statements with name-value pairs, effectively adding a property to the statement. The attributes <tt class="literal">name</tt> and <tt class="literal">value</tt> are of type string.
				</p><p>
					Example:
				</p><pre class="programlisting">@Tag(name='ip_sensitive', value='Y') 
@Tag(name='author', value='Jim')
select * from SecurityFilter(ip="127.0.0.1")</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="epl-syntax-annotation-priority"></a>4.2.5.6.&nbsp;@Priority</h4></div></div><div></div></div><p>
					This annotation only takes effect if the engine-level setting for prioritized execution is set via configuration, as described in <a href="#config-engine-execution" title="10.4.19.&nbsp;Engine Settings related to Execution of Statements">Section&nbsp;10.4.19, &#8220;Engine Settings related to Execution of Statements&#8221;</a>.
				</p><p>
					Use the @Priority EPL annotation to tag statements with a priority value. The default priority value is zero (0) for all statements. When an event (or single timer execution) requires processing the event for multiple statements, processing begins with the highest priority statement and ends with the lowest-priority statement.
				</p><p>
					Example:
				</p><pre class="programlisting">@Priority(10) select * from SecurityFilter(ip="127.0.0.1")</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="epl-syntax-annotation-drop"></a>4.2.5.7.&nbsp;@Drop</h4></div></div><div></div></div><p>
					This annotation only takes effect if the engine-level setting for prioritized execution is set via configuration, as described in <a href="#config-engine-execution" title="10.4.19.&nbsp;Engine Settings related to Execution of Statements">Section&nbsp;10.4.19, &#8220;Engine Settings related to Execution of Statements&#8221;</a>.
				</p><p>
					Use the @Drop EPL annotation to tag statements that preempt all other same or lower-priority statements. When an event (or single timer execution) requires processing the event for multiple statements, processing begins with the highest priority statement and ends with the first statement marked with @Drop, which becomes the last statement to process that event.
				</p><p>
					Unless a different priority is specified, the statement with the @Drop EPL annotation executes at priority 1. Thereby @Drop alone is an effective means to remove events from a stream.
				</p><p>
					Example:
				</p><pre class="programlisting">@Drop select * from SecurityFilter(ip="127.0.0.1")</pre></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="epl-select-list"></a>4.3.&nbsp;Choosing Event Properties And Events: the <span class="emphasis"><em>Select</em></span> Clause</h2></div></div><div></div></div><a class="indexterm" name="d0e3171"></a><a class="indexterm" name="d0e3174"></a><p>
			The <tt class="literal">select</tt> clause is required in all EPL statements. The <tt class="literal">select</tt> clause can be used to select all properties via the wildcard <tt class="literal">*</tt>, or to specify a list of event properties and expressions. The <tt class="literal">select</tt> clause defines the event type (event property names and types) of the resulting events published by the statement, or pulled from the statement via the iterator methods.
		</p><p>
			The <tt class="literal">select</tt> clause also offers optional <tt class="literal">istream</tt>, <tt class="literal">irstream</tt> and <tt class="literal">rstream</tt> keywords to control whether input stream, remove stream or input and remove stream events are posted to <tt class="literal">UpdateListener</tt> instances and observers to a statement. By default, the engine provides only the insert stream to listener and observers. See <a href="#config-engine-stream-selection" title="10.4.14.&nbsp;Engine Settings related to Stream Selection">Section&nbsp;10.4.14, &#8220;Engine Settings related to Stream Selection&#8221;</a> on how to change the default.
		</p><p>
			The syntax for the <tt class="literal">select</tt> clause is summarized below.
		</p><pre class="synopsis">select [istream | irstream | rstream] * | <span class="emphasis"><em>expression_list</em></span> ... </pre><p>
			The <tt class="literal">istream</tt> keyword is the default, and indicates that the engine only delivers insert stream events to listeners and observers. The <tt class="literal">irstream</tt> keyword indicates that the engine delivers both insert and remove stream. Finally, the <tt class="literal">rstream</tt> keyword tells the engine to deliver only the remove stream.
		</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="epl-select-all-props"></a>4.3.1.&nbsp;Choosing all event properties: select *</h3></div></div><div></div></div><p>
				The syntax for selecting all event properties in a stream is:
			</p><pre class="synopsis">select * from <span class="emphasis"><em>stream_def</em></span></pre><p>
				The following statement selects StockTick events for the last 30 seconds of IBM stock ticks.
			</p><pre class="programlisting">select * from StockTick(symbol='IBM').win:time(30 sec)</pre><p>
				The <tt class="literal">*</tt> wildcard and expressions can also be combined in a <tt class="literal">select</tt> clause. The combination selects all event properties and in addition the computed values
				as specified by any additional expressions that are part of the <tt class="literal">select</tt> clause. Here is an example that selects all properties of stock tick events plus a computed product of price and volume that the 
				statement names 'pricevolume':
			</p><pre class="programlisting">select *, price * volume as pricevolume from StockTick(symbol='IBM')</pre><p>
				When using wildcard (*), Esper does not actually copy your event properties out of your event or events. It simply wraps your native type in an <tt class="literal">EventBean</tt> interface. Your application has access to
				the underlying event object through the <tt class="literal">getUnderlying</tt> method and has access to the property values through the <tt class="literal">get</tt> method.
			</p><p>
				In a join statement, using the <tt class="literal">select *</tt> syntax selects one event property per stream to hold the event for that stream. The property name is the stream name in the <tt class="literal">from</tt> clause. 
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="epl-select-event-props"></a>4.3.2.&nbsp;Choosing specific event properties</h3></div></div><div></div></div><p>
				To choose the particular event properties to return:
			</p><pre class="synopsis">select <span class="emphasis"><em>event_property</em></span> [, <span class="emphasis"><em>event_property</em></span>] [, ...] from <span class="emphasis"><em>stream_def</em></span></pre><p>
				The following statement simply selects the symbol and price properties of stock ticks, and the total volume for stock tick events in a 60-second time window. 
			</p><pre class="programlisting">select symbol, price, sum(volume) from StockTick(symbol='IBM').win:time(60 sec)
</pre><p>
				The following statement declares a further view onto the event stream of stock ticks: the univariate statistics view (<tt class="literal">stat:uni</tt>). The statement selects the properties that this view derives from the stream, for the last 100 events of IBM stock ticks in the length window.
			</p><pre class="programlisting">select datapoints, total, average, variance, stdev, stdevpa 
from StockTick(symbol='IBM').win:length(100).stat:uni(volume)</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="epl-select-expressions"></a>4.3.3.&nbsp;Expressions</h3></div></div><div></div></div><p>
				The <tt class="literal">select</tt> clause can contain one or more expressions.
			</p><pre class="synopsis">select <span class="emphasis"><em>expression</em></span> [, <span class="emphasis"><em>expression</em></span>] [, ...] from <span class="emphasis"><em>stream_def</em></span></pre><p>
				The following statement selects the volume multiplied by price for a time batch of the last 30 seconds of stock tick events. 
			</p><pre class="programlisting">select volume * price from StockTick.win:time_batch(30 sec)</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="epl-select-renaming"></a>4.3.4.&nbsp;Renaming event properties</h3></div></div><div></div></div><p>
				Event properties and expressions can be renamed using below syntax.
			</p><pre class="synopsis">select [<span class="emphasis"><em>event_property</em></span> | <span class="emphasis"><em>expression</em></span>] as <span class="emphasis"><em>identifier</em></span> [, ...]</pre><p>
				The following statement selects volume multiplied by price and specifies the name <span class="emphasis"><em>volPrice</em></span> for the resulting column.
			</p><pre class="programlisting">select volume * price as volPrice from StockTick.win:length(100)</pre><p>
				Identifiers cannot contain the "." (dot) character, i.e. "vol.price" is not a valid identifier for the rename syntax.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="epl-select-all-join"></a>4.3.5.&nbsp;Choosing event properties and events in a join</h3></div></div><div></div></div><p>
				If your statement is joining multiple streams, your may specify property names that are unique among the joined streams, or use wildcard (*) as explained earlier.
			</p><p>
				In case the property name in your <tt class="literal">select</tt> or other clauses is not unique considering all joined streams, you will need to use the name of the stream as a prefix to the property.
			</p><p>
				This example is a join between the two streams StockTick and News, respectively named as 'tick' and 'news'. The example selects from the StockTick event the symbol value using the 'tick' stream name as a prefix:
			</p><pre class="programlisting">select tick.symbol from StockTick.win:time(10) as tick, News.win:time(10) as news</pre><p>
				Use the wildcard (*) selector in a join to generate a property for each stream, with the property value being the event itself. The output events of the statement below have two properties: the 'tick' property holds the StockTick event and the 'news' property holds the News event:
			</p><pre class="programlisting">select * from StockTick.win:time(10) as tick, News.win:time(10) as news</pre><p>
				The following syntax can also be used to specify what stream's properties to select:
			</p><pre class="synopsis">select <span class="emphasis"><em>stream_name</em></span>.* [as <span class="emphasis"><em>name</em></span>] from ...</pre><p>
				The selection of <tt class="literal">tick.*</tt> selects the StockTick stream events only:
			</p><pre class="programlisting">select tick.* from StockTick.win:time(10) as tick, News.win:time(10) as news
where tick.symbol = news.symbol</pre><p>
				The next example uses the <tt class="literal">as</tt> keyword to name each stream's joined events. This instructs the engine to create a property for each named event:
			</p><pre class="programlisting">select tick.* as stocktick, news.* as news 
from StockTick.win:time(10) as tick, News.win:time(10) as news
where stock.symbol = news.symbol</pre><p>
				The output events of the above example have two properties 'stocktick' and 'news' that are the StockTick and News events.
			</p><p>
				The stream name itself, as further described in <a href="#epl-from-clause-stream-name" title="4.4.5.&nbsp;Using the Stream Name">Section&nbsp;4.4.5, &#8220;Using the Stream Name&#8221;</a>, may be used within expressions or alone. 
			</p><p>
				This example passes events to a user-defined function named <tt class="literal">compute</tt> and also shows <tt class="literal">insert-into</tt> to populate an event stream of combined events:
			</p><pre class="programlisting">insert into TickNewStream select tick, news, MyLib.compute(news, tick) as result
from StockTick.win:time(10) as tick, News.win:time(10) as news
where tick.symbol = news.symbol

// second statement that uses the TickNewStream stream
select tick.price, news.text, result from TickNewStream</pre><p>
				In summary, the <span class="emphasis"><em>stream_name.*</em></span> streamname wildcard syntax can be used to select a stream as the underlying event or as a property, but cannot appear within an expression. While the <span class="emphasis"><em>stream_name</em></span> syntax (without wildcard) always selects a property (and not as an underlying event), and can occur anywhere within an expression.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="epl-select-pattern"></a>4.3.6.&nbsp;Choosing event properties and events from a pattern</h3></div></div><div></div></div><p>
				If your statement employs pattern expressions, then your pattern expression tags events with a tag name. Each tag name becomes available for use as a property in the <tt class="literal">select</tt> clause and all other clauses.
			</p><p>
				For example, here is a very simple pattern that matches on every StockTick event received within 30 seconds after start of the statement. The sample selects the symbol and price properties of the matching events:
			</p><pre class="programlisting">select tick.symbol as symbol, tick.price as price
from pattern[every tick=StockTick where timer:within(10 sec)]</pre><p>
				The use of the wildcard selector, as shown in the next statement, creates a property for each tagged event in the output. The next statement outputs events that hold a single 'tick' property whose value is the event itself:
			</p><pre class="programlisting">select * from pattern[every tick=StockTick where timer:within(10 sec)]</pre><p>
				You may also select the matching event itself using the <tt class="literal">tick.*</tt> syntax. The engine outputs the StockTick event itself to listeners:
			</p><pre class="programlisting">select tick.* from pattern[every tick=StockTick where timer:within(10 sec)]</pre><p>
				A tag name as specified in a pattern is a valid expression itself. This example uses the <tt class="literal">insert into</tt> clause to make available the events matched by a pattern to further statements:
			</p><pre class="programlisting">// make a new stream of ticks and news available
insert into StockTickAndNews 
select tick, news from pattern [every tick=StockTick -&gt; news=News(symbol=tick.symbol)]
      
// second statement to select from the stream of ticks and news
select tick.symbol, tick.price, news.text from StockTickAndNews</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="epl-select-using-istream-rstream"></a>4.3.7.&nbsp;Selecting <tt class="literal">insert</tt> and <tt class="literal">remove</tt> stream events</h3></div></div><div></div></div><p>
				The optional <tt class="literal">istream</tt>, <tt class="literal">irstream</tt> and <tt class="literal">rstream</tt> keywords in the <tt class="literal">select</tt> clause control the event streams posted to listeners and observers to a statement. 
			</p><p>
				If neither keyword is specified, and in the default engine configuration, the engine posts only 
				insert stream events via the <tt class="literal">newEvents</tt> parameter to the <tt class="literal">update</tt> method of <tt class="literal">UpdateListener</tt> instances listening to 
				the statement. The engine does not post remove stream events, by default.
				</p><p>
				The insert stream consists of the events entering the respective window(s) or stream(s) or aggregations, while the remove stream consists of the events leaving the respective window(s) or the changed aggregation result.
				See <a href="#processingmodel" title="Chapter&nbsp;3.&nbsp;Processing Model">Chapter&nbsp;3, <i>Processing Model</i></a> for more information on insert and remove streams.
				</p><p>
				The engine posts remove stream events to the <tt class="literal">oldEvents</tt> parameter of the <tt class="literal">update</tt> method only if either the <tt class="literal">irstream</tt> or the <tt class="literal">rstream</tt> keyword
				occurs in the <tt class="literal">select</tt> clause. This behavior can be changed via engine-wide configuration as described in <a href="#config-engine-stream-selection" title="10.4.14.&nbsp;Engine Settings related to Stream Selection">Section&nbsp;10.4.14, &#8220;Engine Settings related to Stream Selection&#8221;</a>.
			</p><p>
				By specifying the <tt class="literal">istream</tt> keyword you can instruct the engine to only post insert stream events via the <tt class="literal">newEvents</tt> parameter to the <tt class="literal">update</tt> method on listeners. The engine will then not post any remove stream events, and the <tt class="literal">oldEvents</tt> parameter is always a null value.
			</p><p>
				By specifying the <tt class="literal">irstream</tt> keyword you can instruct the engine to post both insert stream and remove stream events.
			</p><p>
				By specifying the <tt class="literal">rstream</tt> keyword you can instruct the engine to only post remove stream events via the <tt class="literal">newEvents</tt> parameter to the <tt class="literal">update</tt> method on listeners. The engine will then not post any insert stream events, and the <tt class="literal">oldEvents</tt> parameter is also always a null value.
			</p><p>
				The following statement selects only the events that are leaving the 30 second time window.
			</p><pre class="programlisting">select rstream * from StockTick.win:time(30 sec)</pre><p>
				The <tt class="literal">istream</tt> and <tt class="literal">rstream</tt> keywords in the <tt class="literal">select</tt> clause are matched by same-name keywords available in the <tt class="literal">insert into</tt> clause. While the keywords in the <tt class="literal">select</tt> clause control the event stream posted to listeners to the statement, the same keywords in the <tt class="literal">insert into</tt> clause specify the event stream that the engine makes available to other statements.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="epl-syntax-prefix-propsandstream"></a>4.3.8.&nbsp;Qualifying property names and stream names</h3></div></div><div></div></div><p>
				Property or column names can optionally be qualified by a stream name and the provider URI. The syntax is:
			</p><pre class="synopsis">[[<span class="emphasis"><em>provider_URI</em></span>.]<span class="emphasis"><em>stream_name</em></span>.]<span class="emphasis"><em>property_name</em></span></pre><p>
				The <span class="emphasis"><em>provider_URI</em></span> is the URI supplied to the <tt class="literal">EPServiceProviderManager</tt> class, or the string <tt class="literal">default</tt> for the default provider.
			</p><p>
				This example assumes the provider is the default provider:
			</p><pre class="programlisting">select MyEvent.myProperty from MyEvent
// ... equivalent to ...
select default.MyEvent.myProperty from MyEvent</pre><p>
				Stream names can also be qualified by the provider URI. The syntax is:
			</p><pre class="synopsis">[<span class="emphasis"><em>provider_URI</em></span>.]<span class="emphasis"><em>stream_name</em></span></pre><p>
				The next example assumes a provider URI by name of <tt class="literal">Processor</tt>:
			</p><pre class="programlisting">select Processor.MyEvent.myProperty from Processor.MyEvent</pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="epl-from-clause"></a>4.4.&nbsp;Specifying Event Streams: the <span class="emphasis"><em>From</em></span> Clause</h2></div></div><div></div></div><a class="indexterm" name="d0e3613"></a><a class="indexterm" name="d0e3618"></a><a class="indexterm" name="d0e3621"></a><p>
			The <tt class="literal">from</tt> clause is required in all EPL statements. It specifies one or more event streams or named windows. Each event stream or named window can optionally be given a name by means of the <tt class="literal">as</tt> keyword.
		</p><pre class="synopsis">from <span class="emphasis"><em>stream_def</em></span> [as <span class="emphasis"><em>name</em></span>] [unidirectional] [retain-union | retain-intersection] 
    [, <span class="emphasis"><em>stream_def</em></span> [as <span class="emphasis"><em>stream_name</em></span>]] [, ...]</pre><p>
			The event stream definition <span class="emphasis"><em>stream_def</em></span> as shown in the syntax above can consists of either a filter-based event stream definition or a pattern-based event stream definition. 
		</p><p>
			For joins and outer joins, specify two or more event streams. Joins between pattern-based and filter-based event streams are also supported. Joins and the <tt class="literal">unidirectional</tt> keyword are described in more detail in <a href="#epl-join" title="4.11.&nbsp;Joining Event Streams">Section&nbsp;4.11, &#8220;Joining Event Streams&#8221;</a>.
		</p><p>
			Esper supports joins against relational databases for access to historical or reference data as explained in <a href="#histdata_overview" title="4.15.&nbsp;Accessing Relational Data via SQL">Section&nbsp;4.15, &#8220;Accessing Relational Data via SQL&#8221;</a>. Esper can also join results returned by an arbitrary method invocation, as discussed in <a href="#joining_method" title="4.16.&nbsp;Accessing Non-Relational Data via Method Invocation">Section&nbsp;4.16, &#8220;Accessing Non-Relational Data via Method Invocation&#8221;</a>.
		</p><p>
			The <span class="emphasis"><em>stream_name</em></span> is an optional identifier assigned to the stream. The stream name can itself occur in any expression and provides access to the event itself from the named stream. Also, a stream name may be combined with a method name to invoke instance methods on events of that stream.
		</p><p>
			For all streams with the exception of historical sources your query may employ data window views as outlined below. The <tt class="literal">retain-intersection</tt> (the default) and <tt class="literal">retain-union</tt> keywords build a union or intersection of two or more data windows as described in <a href="#epl-from-clause-view-multidatawindow" title="4.4.4.&nbsp;Multiple Data Window Views">Section&nbsp;4.4.4, &#8220;Multiple Data Window Views&#8221;</a>.
		</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="epl-from-clause-filter"></a>4.4.1.&nbsp;Filter-based Event Streams</h3></div></div><div></div></div><p>
				The <span class="emphasis"><em>stream_def</em></span> syntax for a filter-based event stream is as below:
			</p><pre class="synopsis"><span class="emphasis"><em>event_stream_name</em></span> [(<span class="emphasis"><em>filter_criteria</em></span>)] [<span class="emphasis"><em>contained_selection</em></span>] [.<span class="emphasis"><em>view_spec</em></span>] [.<span class="emphasis"><em>view_spec</em></span>] [...]</pre><p>
			  The <span class="emphasis"><em>event_stream_name</em></span> is either the name of an event type or name of an event stream populated by an <tt class="literal">insert into</tt> statement or the name of a named window.
			</p><p>
			  The <span class="emphasis"><em>filter_criteria</em></span> is optional and consists of a list of expressions filtering the events of the event stream, within parenthesis after the event stream name.
			</p><p>
			  The <span class="emphasis"><em>contained_selection</em></span> is optional and is for use with coarse-grained events that have properties that are themselves one or more events, see <a href="#epl-containedeventselect" title="4.20.&nbsp;Contained-Event Selection">Section&nbsp;4.20, &#8220;Contained-Event Selection&#8221;</a> for the synopsis and examples.
			</p><p>
			  The <span class="emphasis"><em>view_spec</em></span> are optional view specifications, which are combinable definitions for retaining events and for deriving information from events.
			</p><p>
				The following EPL statement shows event type, filter criteria and views combined in one statement. It selects all event properties for the last 100 events of IBM stock ticks for volume. In the example, the event type is the fully qualified Java class name <tt class="literal">org.esper.example.StockTick</tt>. The expression filters for events where the property <tt class="literal">symbol</tt> has a value of "IBM". The optional view specifications for deriving data from the StockTick events are a length window and a view for computing statistics on volume. The name for the event stream is "volumeStats".
			</p><pre class="programlisting">select * from 
  org.esper.example.StockTick(symbol='IBM').win:length(100).stat:uni(volume) as volumeStats</pre><p>
				Esper filters out events in an event stream as defined by filter criteria before it sends events to subsequent views. Thus, compared to search conditions in a <tt class="literal">where</tt> clause, filter criteria remove unneeded events early. In the above example, events with a symbol other then IBM do not enter the time window.
			</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="epl-filter-event-type"></a>4.4.1.1.&nbsp;Specifying an Event Type</h4></div></div><div></div></div><p>
					The simplest form of filter is a filter for events of a given type without any conditions on the event property values. This filter matches any event of that type regardless of the event's properties. The example below is such a filter. 
				 </p><pre class="programlisting">select * from com.mypackage.myevents.RfidEvent</pre><p>
					Instead of the fully-qualified Java class name any other event name can be mapped via Configuration to a Java class, making the resulting statement more readable:
				</p><pre class="programlisting">select * from RfidEvent</pre><p>
					 Interfaces and superclasses are also supported as event types. In the below example <tt class="literal">IRfidReadable</tt> is an interface class.
				 </p><pre class="programlisting">select * from org.myorg.rfid.IRfidReadable</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="epl-filter-criteria"></a>4.4.1.2.&nbsp;Specifying Filter Criteria</h4></div></div><div></div></div><p>
					The filtering criteria to filter for events with certain event property values are placed within parenthesis after the event type name:
				 </p><pre class="programlisting">select * from RfidEvent(category="Perishable")</pre><p>
					All expressions can be used in filters, including static methods that return a boolean value:
				 </p><pre class="programlisting">select * from com.mycompany.RfidEvent(MyRFIDLib.isInRange(x, y) or (x &lt; 0 and y &lt; 0))</pre><p>
					Filter expressions can be separated via a single comma '<tt class="literal">,</tt>'. The comma represents a logical AND between filter expressions:
				 </p><pre class="programlisting">select * from RfidEvent(zone=1, category=10)
...is equivalent to...
select * from RfidEvent(zone=1 and category=10)</pre><p>
					The following operators are highly optimized through indexing and are the preferred means of filtering in high-volume event streams:
				</p><div class="itemizedlist"><ul type="disc" compact><li><p>
							equals <tt class="literal">=</tt>
						</p></li><li><p>
							not equals <tt class="literal">!=</tt>
						</p></li><li><p>
							comparison operators <tt class="literal">&lt; , &gt; , &gt;=, &lt;=</tt>
						</p></li><li><p>
							ranges 
						</p><div class="itemizedlist"><ul type="circle" compact><li><p>
									use the <tt class="literal">between</tt> keyword for a closed range where both endpoints are included
								</p></li><li><p>
									use the <tt class="literal">in </tt> keyword and round <tt class="literal">()</tt> or square brackets <tt class="literal">[]</tt> to control how endpoints are included
								</p></li><li><p>
									for inverted ranges use the <tt class="literal">not</tt> keyword and the <tt class="literal">between</tt> or <tt class="literal">in</tt> keywords
								</p></li></ul></div></li><li><p>
							list-of-values checks using the <tt class="literal">in</tt> keyword or the <tt class="literal">not in </tt> keywords followed by a comma-separated list of values
						</p></li></ul></div><p>
					At compile time as well as at run time, the engine scans new filter expressions for sub-expressions that can be indexed. Indexing filter values to match event properties of incoming events enables the engine to match incoming events faster. The above list of operators represents the set of operators that the engine can best convert into indexes. The use of comma or logical <tt class="literal">and</tt> in filter expressions does not impact optimizations by the engine. 
				</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="epl-filter-ranges"></a>4.4.1.3.&nbsp;Filtering Ranges</h4></div></div><div></div></div><p>
					Ranges come in the following 4 varieties. The use of round <tt class="literal">()</tt> 
					or square <tt class="literal">[]</tt> bracket dictates whether an endpoint is included or excluded. The low point and the high-point of the range are separated by the colon <tt class="literal">:</tt> character.
				 </p><div class="itemizedlist"><ul type="disc" compact><li><p>
							Open ranges that contain neither endpoint <tt class="literal">(low:high)</tt>
						</p></li><li><p>
							Closed ranges that contain both endpoints <tt class="literal">[low:high]</tt>. The equivalent 'between' keyword also defines a closed range.
						</p></li><li><p>
							Half-open ranges that contain the low endpoint but not the high endpoint <tt class="literal">[low:high)</tt>
						</p></li><li><p>
							Half-closed ranges that contain the high endpoint but not the low endpoint <tt class="literal">(low:high]</tt>
						</p></li></ul></div><p>
					The next statement shows a filter specifying a range for <tt class="literal">x</tt> and <tt class="literal">y</tt> values of RFID events. The range includes both endpoints therefore uses <tt class="literal">[]</tt> hard brackets.
				</p><pre class="programlisting">mypackage.RfidEvent(x in [100:200], y in [0:100])</pre><p>
					The <tt class="literal">between</tt> keyword is equivalent for closed ranges. The same filter using the <tt class="literal">between</tt> keyword is:
				</p><pre class="programlisting">mypackage.RfidEvent(x between 100 and 200, y between 0 and 50)</pre><p>
					The <tt class="literal">not</tt> keyword can be used to determine if a value falls outside a given range:
				</p><pre class="programlisting">mypackage.RfidEvent(x not in [0:100])</pre><p>
					The equivalent statement using the <tt class="literal">between</tt> keyword is:
				</p><pre class="programlisting">mypackage.RfidEvent(x not between 0 and 100)</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="epl-filter-in"></a>4.4.1.4.&nbsp;Filtering Sets of Values</h4></div></div><div></div></div><p>
					The <tt class="literal">in</tt> keyword for filter criteria determines if a given value matches any value in a list of values.
				 </p><p>
					In this example we are interested in RFID events where the category matches any of the given values:
				</p><pre class="programlisting">mypackage.RfidEvent(category in ('Perishable', 'Container'))</pre><p>
					By using the <tt class="literal">not in </tt>keywords we can filter events with a property value that does not match any of the values in a list of values:
				 </p><pre class="programlisting">mypackage.RfidEvent(category not in ('Household', 'Electrical'))</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="epl-filter-limitations"></a>4.4.1.5.&nbsp;Filter Limitations</h4></div></div><div></div></div><p>
					The following restrictions apply to filter criteria:
				</p><div class="itemizedlist"><ul type="disc" compact><li><p>
							Range and comparison operators require the event property to be of a numeric type. 
						</p></li><li><p>
							Aggregation functions are not allowed within filter expressions.
						</p></li><li><p>
							The <tt class="literal">prev</tt> previous event function and the <tt class="literal">prior</tt> prior event function cannot be used in filter expressions.
						</p></li></ul></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="epl-from-clause-patterns"></a>4.4.2.&nbsp;Pattern-based Event Streams</h3></div></div><div></div></div><p>
				Event pattern expressions can also be used to specify one or more event streams in an EPL statement.
				For pattern-based event streams, the event stream definition <span class="emphasis"><em>stream_def</em></span> consists of the keyword <tt class="literal">pattern</tt> and a pattern expression in brackets <tt class="literal">[]</tt>. The syntax for an event stream definition using a pattern expression is below. As in filter-based event streams, an optional list of views that derive data from the stream can be supplied.
			</p><pre class="synopsis">pattern [<span class="emphasis"><em>pattern_expression</em></span>] [.<span class="emphasis"><em>view_spec</em></span>] [.<span class="emphasis"><em>view_spec</em></span>] [...]</pre><p>
				The next statement specifies an event stream that consists of both stock tick events and trade events. The example tags stock tick events with the name "tick" and trade events with the name "trade".
			</p><pre class="programlisting">select * from pattern [every tick=StockTickEvent or every trade=TradeEvent]</pre><p>
				This statement generates an event every time the engine receives either one of the event types. The generated events resemble a map with "tick" and "trade" keys. For stock tick events, the "tick" key value is the underlying stock tick event, and the "trade" key value is a null value. For trade events, the "trade" key value is the underlying trade event, and the "tick" key value is a null value.
			</p><p>
				Lets further refine this statement adding a view the gives us the last 30 seconds of either stock tick or trade events. Lets also select prices and a price total.
			</p><pre class="programlisting">select tick.price as tickPrice, trade.price as tradePrice, 
       sum(tick.price) + sum(trade.price) as total
  from pattern [every tick=StockTickEvent or every trade=TradeEvent].win:time(30 sec)</pre><p>
				Note that in the statement above <tt class="literal">tickPrice</tt> and <tt class="literal">tradePrice</tt> can each be null values depending on the event processed. Therefore, an aggregation function such as <tt class="literal">sum(tick.price + trade.price))</tt> would always return null values as either of the two price properties are always a null value for any event matching the pattern. Use the <tt class="literal">coalesce</tt> function to handle null values, for example: <tt class="literal">sum(coalesce(tick.price, 0) + coalesce(trade.price, 0))</tt>.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="epl-from-clause-view-spec"></a>4.4.3.&nbsp;Specifying Views</h3></div></div><div></div></div><p>
				Views are used to derive or aggregate data. Views can be staggered onto each other. See the section <a href="#epl-views" title="Chapter&nbsp;8.&nbsp;EPL Reference: Views">Chapter&nbsp;8, <i>EPL Reference: Views</i></a> on the views available that also outlines the different types of views: Data Window views and Derived-Value views.
			</p><p>
				Views can optionally take one or more parameters. These parameters are expressions themselves that may consists of any combination of variables, arithmatics, user-define function or substituion parameters for prepared statements, as example.
			</p><p>
				The below example serves to show views and staggering of views. It uses a car location event that contains information about the location of a car on a highway. 
			</p><pre class="programlisting">select * from CarLocEvent.std:groupby(carId).win:length(4).
  std:groupby(expressway, direction, segment).std:size()</pre><p>
				The first view <tt class="literal">std:groupby(carId)</tt> groups car location events by car id. The second view <tt class="literal">win:length(4)</tt> keeps a length window of the 4 last events, with one length window for each car id. The next view <tt class="literal">std:groupby(expressway, direction, segment)</tt> groups each event by its expressway, direction and segment property values. Again, the grouping is done for each car id considering the last 4 events only. The last view <tt class="literal">std:size()</tt> is used to report the number of events. Thus the below example reports the number of events per car id and per expressway, direction and segment considering the last 4 events for each car id only. 
			</p><p>
				When views are staggered onto each other as a chain of views, then the insert and remove stream received by each view is the insert and remove stream made available by the view (or stream) earlier in the chain. 
			</p><p>
				The special keep-all view keeps all events: It does not provide a remove stream, i.e. events are not removed from the keep-all view unless by means of the <tt class="literal">on-delete</tt> syntax or by revision events.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="epl-from-clause-view-multidatawindow"></a>4.4.4.&nbsp;Multiple Data Window Views</h3></div></div><div></div></div><p>
			   Data window views provide an expiry policy that indicates when to remove events from the data window, with the exception of the keep-all data window which has no expiry policy and the group-by view for allocating a new data window per group.
		   </p><p>
			   EPL allows the freedom to use multiple data window views onto a stream and thus combine expiry policies. Combining data windows into a intersection (the default) or a union can achieve a useful strategy for retaining events and expiring events that are no longer of interest. Named windows and the <tt class="literal">on-delete</tt> syntax provide an additional degree of freedom.
		   </p><p>
			   In order to combine two or more data window views there is no keyword required. The <span class="emphasis"><em>retain-intersection</em></span> keyword is the default and the <span class="emphasis"><em>retain-union</em></span> keyword may instead be provided for a stream.
		   </p><p>
				The concept of union and intersection come from Set mathematics. In the language of Set mathematics, two sets A and B can be "added" together: The intersection of A and B is the set of all things which are members of both A and B, i.e. the members two sets have "in common". The union of A and B is the set of all things which are members of either A or B. 
			</p><p>
			   Use the <span class="emphasis"><em>retain-intersection</em></span> (the default) keyword to retain an intersection of all events as defined by two or more data windows. All events removed from any of the intersected data windows are entered into the remove stream. This is the default behavior if neither retain keyword is specified.
		   </p><p>
			   Use the <span class="emphasis"><em>retain-union</em></span> keyword to retain a union of all events as defined by two or more data windows. Only events removed from all data windows are entered into the remove stream.
		   </p><p>
				As you can see, it is the remove stream that the combined multiple data windows provide which differs when retaining an intersection and retaining a union, the insert stream is the same to all data windows and their staggered views. Therefore, when coming batching data windows with further data windows, the insert stream still remains the insert stream of the set overall (not batched). Consider using <tt class="literal">output snapshot</tt> to obtain regular updates instead of combining batch and other data windows.
		   </p><p>
			   The next example statement totals the price of OrderEvent events in a union of the last 30 seconds and unique by product name:
		   </p><pre class="programlisting">select sum(price) from OrderEvent.win:time(30 sec).std:unique(productName) retain-union</pre><p>
			   In the above statement, all OrderEvent events that are either less then 30 seconds old or that are the last event for the product name are considered.
		   </p><p>
			   Here is an example statement totals the price of OrderEvent events in an intersection of the last 30 seconds and unique by product name:
		   </p><pre class="programlisting">select sum(price) from OrderEvent.win:time(30 sec).std:unique(productName) retain-intersection</pre><p>
			   In the above statement, only those OrderEvent events that are both less then 30 seconds old and are the last event for the product name are considered.
		   </p><p>
			   For advanced users and for backward compatibility, it is possible to configure Esper to allow multiple data window views without either of the <tt class="literal">retain</tt> keywords, as described in <a href="#config-engine-viewresources-multipolicy" title="10.4.11.2.&nbsp;Configuring Multi-Expiry Policy Defaults">Section&nbsp;10.4.11.2, &#8220;Configuring Multi-Expiry Policy Defaults&#8221;</a>.
		   </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="epl-from-clause-stream-name"></a>4.4.5.&nbsp;Using the Stream Name</h3></div></div><div></div></div><p>
				Your <tt class="literal">from</tt> clause may assign a name to each stream. This assigned stream name can serve any of the following purposes.
			</p><p>
				First, the stream name can be used to disambiguate property names. The <tt class="literal">stream_name.property_name</tt> syntax uniquely identifies which property to select if property names overlap between streams. Here is an example:
			</p><pre class="programlisting">select prod.productId, ord.productId from ProductEvent as prod, OrderEvent as ord</pre><p>
				Second, the stream name can be used with a wildcard (*) character to select events in a join, or assign new names to the streams in a join:
			</p><pre class="programlisting">// Select ProductEvent only
select prod.* from ProductEvent as prod, OrderEvent

// Assign column names 'product' and 'order' to each event
select prod.* as product, ord.* as order from ProductEvent as prod, OrderEvent as ord</pre><p>
				Further, the stream name by itself can occur in any expression: The engine passes the event itself to that expression. For example, the engine passes the ProductEvent and the OrderEvent to the user-defined function 'checkOrder':
			</p><pre class="programlisting">select prod.productId, MyFunc.checkOrder(prod, ord) 
from ProductEvent as prod, OrderEvent as ord</pre><p>
				Last, you may invoke an instance method on each event of a stream, and pass parameters to the instance method as well. Instance method calls are allowed anywhere in an expression.
			</p><p>
				The next statement demonstrates this capability by invoking a method 'computeTotal' on OrderEvent events and a method 'getMultiplier' on ProductEvent events:
			</p><pre class="programlisting">select ord.computeTotal(prod.getMultiplier()) from ProductEvent as prod, OrderEvent as ord</pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="epl-where-clause"></a>4.5.&nbsp;Specifying Search Conditions: the <span class="emphasis"><em>Where</em></span> Clause</h2></div></div><div></div></div><a class="indexterm" name="d0e4141"></a><a class="indexterm" name="d0e4144"></a><p>
			The <tt class="literal">where</tt> clause is an optional clause in EPL statements. Via the <tt class="literal">where</tt> clause event streams can be joined and events can be filtered. 
		</p><p>
			Comparison operators <tt class="literal">=, &lt; , &gt; , &gt;=, &lt;=, !=, &lt;&gt;, is null, is not null</tt> and logical combinations via <tt class="literal">and</tt> and <tt class="literal">or</tt> are supported in the <tt class="literal">where</tt> clause. The <tt class="literal">where</tt> clause can also introduce join conditions as outlined in <a href="#epl-join" title="4.11.&nbsp;Joining Event Streams">Section&nbsp;4.11, &#8220;Joining Event Streams&#8221;</a>. <tt class="literal">where</tt> clauses can also contain expressions. Some examples are listed below.
		</p><pre class="programlisting">...where fraud.severity = 5 and amount &gt; 500
...where (orderItem.orderId is null) or (orderItem.class != 10)		 
...where (orderItem.orderId = null) or (orderItem.class &lt;&gt; 10)		 
...where itemCount / packageCount &gt; 10		 </pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="epl-grouping-aggregating"></a>4.6.&nbsp;Aggregates and grouping: the <span class="emphasis"><em>Group-by</em></span> Clause and the <span class="emphasis"><em>Having</em></span> Clause</h2></div></div><div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="epl-grouping-aggregate-functions"></a>4.6.1.&nbsp;Using aggregate functions</h3></div></div><div></div></div><p>
					The aggregate functions are <tt class="literal">sum, avg, count, max, min, median, stddev, avedev</tt>. You can use aggregate functions to
					calculate and summarize data from event properties.
					For example, to find out the total price for all stock tick events in the last 30 seconds, type:
				</p><pre class="programlisting">select sum(price) from StockTickEvent.win:time(30 sec)</pre><p>
					Here is the syntax for aggregate functions: 
				</p><pre class="synopsis"><span class="emphasis"><em>aggregate_function</em></span>( [all | distinct] <span class="emphasis"><em>expression</em></span>)</pre><p>
					You can apply aggregate functions to all events in an event stream window or other view, or to one or more groups of events. From each set of events to which 
					an aggregate function is applied, Esper generates a single value. 
				</p><p>
					<tt class="literal">Expression</tt> is usually an event property name. However it can also be a constant, function, or any combination of event property names, constants, 
					and functions connected by arithmetic operators.
				</p><p>
					For example, to find out the average price for all stock tick events in the last 30 seconds if the price was doubled:
				</p><pre class="programlisting">select avg(price * 2) from StockTickEvent.win:time(30 seconds)</pre><p>
					You can use the optional keyword <tt class="literal">distinct</tt> with all aggregate functions to eliminate duplicate values before the aggregate function is applied. The optional 
					keyword <tt class="literal">all</tt> which performs the operation on all events is the default. 
				</p><p>
					You can use aggregation functions in a <tt class="literal">select</tt> clause and in a <tt class="literal">having</tt> clause. You cannot use aggregate functions in a <tt class="literal">where</tt> clause, but you can use the <tt class="literal">where</tt> clause to restrict the events to which the aggregate is applied. The next query computes the average and sum of the price of stock tick events for the symbol IBM only, for the last 10 stock tick events regardless of their symbol.
				</p><pre class="programlisting">select 'IBM stats' as title, avg(price) as avgPrice, sum(price) as sumPrice
from StockTickEvent.win:length(10)
where symbol='IBM'</pre><p>
					In the above example the length window of 10 elements is not affected by the <tt class="literal">where</tt> clause, i.e. all events enter and leave the length window regardless of their symbol. If we only care about the last 10 IBM events, we need to add filter criteria as below.
				</p><pre class="programlisting">select 'IBM stats' as title, avg(price) as avgPrice, sum(price) as sumPrice
from StockTickEvent(symbol='IBM').win:length(10)
where symbol='IBM'</pre><p>
					You can use aggregate functions with any type of event property or expression, with the following exceptions:
				</p><div class="orderedlist"><ol type="1" compact><li><p>
							You can use <tt class="literal">sum, avg, median, stddev, avedev</tt> with numeric event properties only	
						</p></li></ol></div><p>
					Esper ignores any null values returned by the event property or expression on which the aggregate function is operating, except for the <tt class="literal">count(*)</tt> function, which counts null values as well. All aggregate functions return null if the data set contains no events, or if all events in the data set contain only null values for the aggregated expression.
				</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="epl-grouping-group-by"></a>4.6.2.&nbsp;Organizing statement results into groups: the <span class="emphasis"><em>Group-by</em></span> clause</h3></div></div><div></div></div><a class="indexterm" name="d0e4271"></a><a class="indexterm" name="d0e4274"></a><p>
					The <tt class="literal">group by</tt> clause is optional in all EPL statements. The <tt class="literal">group by</tt> clause divides the output of an EPL statement into groups. You can group by one or more event property names, or by the result of computed expressions. When used with aggregate functions, <tt class="literal">group by</tt> retrieves the calculations in each subgroup. You can use <tt class="literal">group by</tt> without aggregate functions, but generally that can produce confusing results.
				</p><p>
					For example, the below statement returns the total price per symbol for all stock tick events in the last 30 seconds:
				</p><pre class="programlisting">select symbol, sum(price) from StockTickEvent.win:time(30 sec) group by symbol</pre><p>
					The syntax of the <tt class="literal">group by</tt> clause is:
				</p><pre class="synopsis">group by <span class="emphasis"><em>arregate_free_expression</em></span> [, <span class="emphasis"><em>arregate_free_expression</em></span>] [, ...]</pre><p>
					Esper places the following restrictions on expressions in the <tt class="literal">group by</tt> clause:
				</p><div class="orderedlist"><ol type="1" compact><li><p>
							Expressions in the <tt class="literal">group by</tt> cannot contain aggregate functions
						</p></li><li><p>
							Event properties that are used within aggregate functions in the <tt class="literal">select</tt> clause cannot also be used in a <tt class="literal">group by</tt> expression
						</p></li></ol></div><p>
					You can list more then one expression in the <tt class="literal">group by</tt> clause to nest groups. Once the sets are established with <tt class="literal">group by</tt> the aggregation
					functions are applied. This statement posts the median volume for all stock tick events in the last 30 seconds per symbol and tick data feed. Esper posts one event for each group to statement listeners:
				</p><pre class="programlisting">select symbol, tickDataFeed, median(volume) 
from StockTickEvent.win:time(30 sec) 
group by symbol, tickDataFeed</pre><p>
					In the statement above the event properties in the <tt class="literal">select</tt> list (symbol, tickDataFeed) are also listed in the <tt class="literal">group by</tt> clause.
					The statement thus follows the SQL standard which prescribes that non-aggregated event properties in the <tt class="literal">select</tt> list must match the 
					<tt class="literal">group by</tt> columns.
				</p><p>
					Esper also supports statements in which one or more event properties in the <tt class="literal">select</tt> list are not listed in the <tt class="literal">group by</tt> clause.
					The statement below demonstrates this case. It calculates the standard deviation for the last 30 seconds of stock ticks aggregating by symbol and posting for 
					each event the symbol, tickDataFeed and the standard deviation on price.
				</p><pre class="programlisting">select symbol, tickDataFeed, stddev(price) from StockTickEvent.win:time(30 sec) group by symbol</pre><p>
					The above example still aggregates the <tt class="literal">price</tt> event property based on the <tt class="literal">symbol</tt>, but produces one event per incoming event, not one 
					event per group.
				</p><p>
					Additionally, Esper supports statements in which one or more event properties in the <tt class="literal">group by</tt> clause are not listed in the <tt class="literal">select</tt> list.
					This is an example that calculates the mean deviation per <tt class="literal">symbol</tt> and <tt class="literal">tickDataFeed</tt> and posts one event per group with <tt class="literal">symbol</tt> and mean deviation of price in the generated events. Since tickDataFeed is not in the posted results, this can potentially be confusing.
				</p><pre class="programlisting">select symbol, avedev(price) 
from StockTickEvent.win:time(30 sec) 
group by symbol, tickDataFeed</pre><p>
					Expressions are also allowed in the <tt class="literal">group by</tt> list:
				</p><pre class="programlisting">select symbol * price, count(*) from StockTickEvent.win:time(30 sec) group by symbol * price</pre><p>
					If the <tt class="literal">group by</tt> expression resulted in a null value, the null value becomes its own group. All null values are aggregated into the same group. If you are using the <tt class="literal">count(expression)</tt> aggregate function which does not count null values, the count returns zero if only null values are encountered.								
				</p><p>
					You can use a <tt class="literal">where</tt> clause in a statement with <tt class="literal">group by</tt>. Events that do not satisfy the conditions in the <tt class="literal">where</tt> clause are eliminated before any grouping is done. For example, the statement below posts the number of stock ticks in the last 30 seconds with a volume larger then 100, posting one event per group (symbol).
				</p><pre class="programlisting">select symbol, count(*) from StockTickEvent.win:time(30 sec) where volume &gt; 100 group by symbol</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="epl-grouping-having"></a>4.6.3.&nbsp;Selecting groups of events: the <span class="emphasis"><em>Having</em></span> clause</h3></div></div><div></div></div><a class="indexterm" name="d0e4426"></a><a class="indexterm" name="d0e4429"></a><p>
					Use the <tt class="literal">having</tt> clause to pass or reject events defined by the <tt class="literal">group-by</tt> clause. The <tt class="literal">having</tt> clause sets conditions for the <tt class="literal">group by</tt> clause in the same way <tt class="literal">where</tt> sets conditions for the <tt class="literal">select</tt> clause, except <tt class="literal">where</tt> cannot include aggregate functions, while <tt class="literal">having</tt> often does.
				</p><p>
					This statement is an example of a <tt class="literal">having</tt> clause with an aggregate function. It posts the total price per symbol for the last 30 seconds of stock tick events for only those symbols in which the total price exceeds 1000. The <tt class="literal">having</tt> clause eliminates all symbols where the total price is equal or less then 1000.
				</p><pre class="programlisting">select symbol, sum(price) 
from StockTickEvent.win:time(30 sec) 
group by symbol 
having sum(price) &gt; 1000</pre><p>
					To include more then one condition in the <tt class="literal">having</tt> clause combine the conditions with <tt class="literal">and</tt>, <tt class="literal">or</tt> or <tt class="literal">not</tt>.
					This is shown in the statement below which selects only groups with a total price greater then 1000 and an average volume less then 500.
				</p><pre class="programlisting">select symbol, sum(price), avg(volume)
from StockTickEvent.win:time(30 sec) 
group by symbol 
having sum(price) &gt; 1000 and avg(volume) &lt; 500</pre><p>
					Esper places the following restrictions on expressions in the <tt class="literal">having</tt> clause:
				</p><div class="orderedlist"><ol type="1" compact><li><p>
							Any expressions that contain aggregate functions must also occur in the <tt class="literal">select</tt> clause
						</p></li></ol></div><p>
					A statement with the <tt class="literal">having</tt> clause should also have a <tt class="literal">group by</tt> clause. If you omit <tt class="literal">group-by</tt>, all the events not excluded
					by the <tt class="literal">where</tt> clause return as a single group. In that case <tt class="literal">having</tt> acts like a <tt class="literal">where</tt> except that <tt class="literal">having</tt> can have aggregate functions. 
				</p><p>
					The <tt class="literal">having</tt> clause can also be used without <tt class="literal">group by</tt> clause as the below example shows. The example below posts events where the price is less then the current running average price of all stock tick events in the last 30 seconds.
				</p><pre class="programlisting">select symbol, price, avg(price) 
from StockTickEvent.win:time(30 sec) 
having price &lt; avg(price)</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="epl-filter-where-grouping-having-interactions"></a>4.6.4.&nbsp;How the stream filter, <span class="emphasis"><em>Where</em></span>, <span class="emphasis"><em>Group By</em></span> and <span class="emphasis"><em>Having</em></span> clauses interact</h3></div></div><div></div></div><p>
					When you include filters, the <tt class="literal">where</tt> condition, the <tt class="literal">group by</tt> clause and the <tt class="literal">having</tt> condition in an EPL statement
					the sequence in which each clause affects events determines the final result:
				</p><div class="orderedlist"><ol type="1" compact><li><p>
							The event stream's filter condition, if present, dictates which events enter a window (if one is used). The filter discards any events not meeting filter criteria.
						</p></li><li><p>
							The <tt class="literal">where</tt> clause excludes events that do not meet its search condition.
						</p></li><li><p>
							Aggregate functions in the select list calculate summary values for each group.
						</p></li><li><p>
							The <tt class="literal">having</tt> clause excludes events from the final results that do not meet its search condition.
						</p></li></ol></div><p>
					The following query illustrates the use of filter, <tt class="literal">where</tt>, <tt class="literal">group by</tt> and <tt class="literal">having</tt> clauses in one statement with 
					a <tt class="literal">select</tt> clause containing an aggregate function.
				</p><pre class="programlisting">select tickDataFeed, stddev(price)
from StockTickEvent(symbol='IBM').win:length(10) 
where volume &gt; 1000
group by tickDataFeed 
having stddev(price) &gt; 0.8</pre><p>
					Esper filters events using the filter criteria for the event stream <tt class="literal">StockTickEvent</tt>. In the example above only events with symbol IBM enter the length window over the last 10 events, all other events are simply discarded. The <tt class="literal">where</tt> clause removes any events posted by the length window (events entering the window and event leaving the window) that do not match the condition of volume greater then 1000. Remaining events are applied to the <tt class="literal">stddev</tt> standard deviation aggregate function for each tick data feed as specified in the <tt class="literal">group by</tt> clause. Each <tt class="literal">tickDataFeed</tt> value generates one event. Esper applies the <tt class="literal">having</tt> clause and only lets events pass for <tt class="literal">tickDataFeed</tt> groups with a standard deviation of price greater then 0.8.
				</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="epl-group-by-versus-view"></a>4.6.5.&nbsp;Comparing the <span class="emphasis"><em>Group By</em></span> clause and the <span class="emphasis"><em>std:groupby</em></span> view</h3></div></div><div></div></div><p>
				The <span class="emphasis"><em>group by</em></span> clause as well as the built-in <span class="emphasis"><em>std:groupby</em></span> view are similar in their ability to group events. This section explains the key differences in their behavior and use.
			</p><p>
				The <span class="emphasis"><em>group by</em></span> clause works together with aggregation functions in your statement to produce an aggregation result per group. In greater detail, this means that when a new event arrives, the engine applies the expressions in the <span class="emphasis"><em>group by</em></span> clause to determine a grouping key. If the engine has not encountered that grouping key before (a new group), the engine creates a set of new aggregation results for that grouping key and performs the aggregation changing that new set of aggregation results. If the grouping key points to an existing set of prior aggregation results (an existing group), the engine performs the aggregation changing the prior set of aggregation results for that group.
			</p><p>
				The <span class="emphasis"><em>std:groupby</em></span> view is a built-in view that also groups events. The view is described in greater detail in <a href="#view-std-groupby" title="8.2.2.&nbsp;Group-By (std:groupby)">Section&nbsp;8.2.2, &#8220;Group-By (std:groupby)&#8221;</a>. Its primary use is to create a separate data window per group, or more generally to create separate instances of all its sub-views for each grouping key encountered.
			</p><p>
				The next example shows two queries that produce equivalent results. The query using the <span class="emphasis"><em>group by</em></span> clause is generally preferable as is easier to read. The second form introduces the <tt class="literal">stat:uni</tt> view which computes univariate statistics for a given property:
			</p><pre class="programlisting">select symbol, avg(price) from StockTickEvent group by symbol
// ... is equivalent to ...
select symbol, average from StockTickEvent.std:groupby(symbol).stat:uni(price)</pre><p>
				The next example shows two queries that are NOT equivalent as the length window is ungrouped in the first query, and grouped in the second query:
			</p><pre class="programlisting">select symbol, sum(price) from StockTickEvent.win:length(10) group by symbol
// ... NOT equivalent to ...
select symbol, sum(price) from StockTickEvent.std:groupby(symbol).win:length(10)</pre><p>
				The key difference between the two statements is that in the first statement the length window is ungrouped and applies to all events regardless of group. While in the second query each group gets its own instance of a length window. For example, in the second query events arriving for symbol "ABC" get a length window of 10 events, and events arriving for symbol "DEF" get their own length window of 10 events. 
			</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="epl-output-rate"></a>4.7.&nbsp;Stabilizing and Controlling Output: the <span class="emphasis"><em>Output</em></span> Clause</h2></div></div><div></div></div><a class="indexterm" name="d0e4666"></a><a class="indexterm" name="d0e4669"></a><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="epl-output-options"></a>4.7.1.&nbsp;Output Clause Options</h3></div></div><div></div></div><p>
					The <tt class="literal">output</tt> clause is optional in Esper and is used to control or stabilize the rate at which events are output. The EPL language provides for several different ways to control output rate.
				</p><p>
					Here is the syntax for the <tt class="literal">output</tt> clause that specifies a rate in time interval or number of events:
				</p><pre class="synopsis">output [all | first | last | snapshot] every <span class="emphasis"><em>output_rate</em></span> [minutes | seconds | events]</pre><p>
					An alternate syntax specifies the time period between output as outlined in <a href="#epl-syntax-time-periods" title="4.2.1.&nbsp;Specifying Time Periods">Section&nbsp;4.2.1, &#8220;Specifying Time Periods&#8221;</a> :
				</p><pre class="synopsis">output [all | first | last | snapshot] every <span class="emphasis"><em>time_period</em></span></pre><p>
					A crontab-like schedule can also be specified. The schedule parameters follow the pattern observer parameters and are further described in <a href="#pattern-timer-at" title="5.6.2.2.&nbsp;timer:at">Section&nbsp;5.6.2.2, &#8220;timer:at&#8221;</a> :
				</p><pre class="synopsis">output [all | first | last | snapshot] at 
  (<span class="emphasis"><em>minutes, hours, days of month, months, days of week [, seconds]</em></span>)</pre><p>
					Last, output can be controlled by an expression that may contain variables, user-defined functions and information about the number of collected events. Output that is controlled by an expression is discussed in detail below.
				</p><p>
					For example, the following statement outputs, every 60 seconds, the total price for all orders in the 30-minute time window:		
				</p><pre class="programlisting">select sum(price) from OrderEvent.win:time(30 min) output snapshot every 60 seconds</pre><p>
					The <tt class="literal">all</tt> keyword is the default and specifies that all events in a batch should be output, each incoming row in the batch producing an output row.
					Note that for statements that group via the <tt class="literal">group by</tt> clause, the <tt class="literal">all</tt> keyword provides special behavior as below.
				</p><p>
					The <tt class="literal">first</tt> keyword specifies that only the first event in an output batch is to be output.
					Using the <tt class="literal">first</tt> keyword instructs the engine to output the first matching event as soon as it arrives, and then ignores matching events for the time interval or number of events specified. 
					After the time interval elapsed, or the number of matching events has been reached, the next first matching event is output again and the following interval the engine again ignores matching events.
				</p><p>
					The <tt class="literal">last</tt> keyword specifies to only output the last event at the end of the given time interval or after the given number of matching events
					have been accumulated. Again, for statements that group via the <tt class="literal">group by</tt> clause the <tt class="literal">last</tt> keyword provides special behavior as below.
				</p><p>
					The <tt class="literal">snapshot</tt> keyword indicates that the engine output current computation results considering all events as per views specified and/or current aggregation results. While the other keywords control how a batch of events between output intervals is being considered, the <tt class="literal">snapshot</tt> keyword outputs all current state of a statement independent of the last batch. It's output is equivalent to the <tt class="literal">iterator</tt> method provided by a statement.
				</p><p>
					The <span class="emphasis"><em>output_rate</em></span> is the frequency at which the engine outputs events. It can be specified in terms of time or number of events. The value can be a number to denote a fixed output rate, or the name of a variable whose value is the output rate. By means of a variable the output rate can be controlled externally and changed dynamically at runtime. 
				</p><p>
					Please consult the <a href="#appendix_outputspec" title="Appendix&nbsp;A.&nbsp;Output Reference and Samples">Appendix&nbsp;A, <i>Output Reference and Samples</i></a> for detailed information on insert and remove stream output for the various <tt class="literal">output</tt> clause keywords.
				</p><p>
					The time interval can also be specified in terms of minutes; the following statement is identical to the first one.
				</p><pre class="programlisting">select * from StockTickEvent.win:length(5) output every 1.5 minutes</pre><p>
					A second way that output can be stabilized is by batching events until a certain number of events have been collected. The next statement only outputs when either 5 (or more) new or 5 (or more) old events have been batched.
				</p><pre class="programlisting">select * from StockTickEvent.win:time(30 sec) output every 5 events</pre><p>
					Additionally, event output can be further modified by the optional <tt class="literal">last</tt> keyword, which causes output of only the last event to arrive into an output batch.
				</p><pre class="programlisting">select * from StockTickEvent.win:time(30 sec) output last every 5 events</pre><p>
					Using the <tt class="literal">first</tt> keyword you can be notified at the start of the interval. The allows to watch for situations such as a rate falling below a threshold
					and only be informed every now and again after the specified output interval, but be informed the moment it first happens. 
				</p><pre class="programlisting">select * from TickRate.win:time(30 seconds) where rate&lt;100 output first every 60 seconds</pre><p>
					A sample statement using the Unix "crontab"-command schedule is shown next. See <a href="#pattern-timer-at" title="5.6.2.2.&nbsp;timer:at">Section&nbsp;5.6.2.2, &#8220;timer:at&#8221;</a> for details on schedule syntax. Here, output occurs every 15 minutes from 8am to 5:45pm (hours 8 to 17 at 0, 15, 30 and 45 minutes past the hour):
				</p><pre class="synopsis">select symbol, sum(price) from StockTickEvent group by symbol output at (*/15, 8:17, *, *, *)</pre><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="epl-output-expression"></a>4.7.1.1.&nbsp;Controlling Output Using an Expression</h4></div></div><div></div></div><a class="indexterm" name="d0e4799"></a><p>
						Output can also be controlled by an expression that may check variable values, use user-defined functions and query built-in properties that provide additional information. The synopsis is as follows:
					</p><pre class="synopsis">output [all | first | last | snapshot] when <span class="emphasis"><em>trigger_expression</em></span> 
    [then set <span class="emphasis"><em>variable_name</em></span> = <span class="emphasis"><em>assign_expression</em></span> [, <span class="emphasis"><em>variable_name</em></span> = <span class="emphasis"><em>assign_expression</em></span> [,...]]]</pre><p>
						The <tt class="literal">when</tt> keyword must be followed by a trigger expression returning a boolean value of true or false, indicating whether to output.
						Use the optional <tt class="literal">then</tt> keyword to change variable values after the trigger expression evaluates to true. An assignment expression assigns a new value to variable(s).
					</p><p>
						Lets consider an example. The next statement assumes that your application has defined a variable by name OutputTriggerVar of boolean type. The statement outputs rows only when the OutputTriggerVar variable has a boolean value of true:
					</p><pre class="synopsis">select sum(price) from StockTickEvent output when OutputTriggerVar = true</pre><p>
						The engine evaluates the trigger expression when streams and data views post one or more insert or remove stream events after considering the <tt class="literal">where</tt> clause, if present. It also evaluates the trigger expression when any of the variables used in the trigger expression, if any, changes value. Thus output occurs as follows:
					</p><div class="orderedlist"><ol type="1" compact><li><p>
								When there are insert or remove stream events and the <tt class="literal">when</tt> trigger expression evaluates to true, the engine outputs the resulting rows.
							</p></li><li><p>
								When any of the variables in the <tt class="literal">when</tt> trigger expression changes value, the engine evaluates the expression and outputs results. Result output occurs within the minimum time interval of timer resolution (100 milliseconds).
							</p></li></ol></div><p>
						By adding a <tt class="literal">then</tt> part to the EPL, we can reset any variables after the trigger expression evaluated to true:
					</p><pre class="synopsis">select sum(price) from StockTickEvent 
  output when OutputTriggerVar = true  
  then set OutputTriggerVar = false</pre><p>
						Expressions in the <tt class="literal">when</tt> and <tt class="literal">then</tt> may, for example, use variables, user defined functions or any of the built-in named properties that are described in the below list.
					</p><p>
						The following built-in properties are available for use:
					</p><div class="table"><a name="epl-output-expression-builtin"></a><p class="title"><b>Table&nbsp;4.3.&nbsp;Built-In Properties for Use with Output When</b></p><table summary="Built-In Properties for Use with Output When" border="1"><colgroup><col><col></colgroup><thead><tr><th>Built-In Property Name</th><th>Description</th></tr></thead><tbody><tr><td><tt class="literal">last_output_timestamp</tt></td><td>Timestamp when the last output occurred for the statement; Initially set to time of statement creation</td></tr><tr><td><tt class="literal">count_insert</tt></td><td>Number of insert stream events</td></tr><tr><td><tt class="literal">count_remove</tt></td><td>Number of remove stream events</td></tr></tbody></table></div><p>
						The values provided by <tt class="literal">count_insert</tt> and <tt class="literal">count_remove</tt> are non-continues: The number returned for these properties may 'jump' up rather then count up by 1.
						The counts reset to zero upon output.
					</p><p>
						The following restrictions apply to expressions used in the output rate clause:
					</p><div class="itemizedlist"><ul type="disc" compact><li><p>
								Event property names cannot be used in the output clause.
							</p></li><li><p>
								Aggregation functions cannot be used in the output clause.
							</p></li><li><p>
								The <tt class="literal">prev</tt> previous event function and the <tt class="literal">prior</tt> prior event function cannot be used in the output clause.
							</p></li></ul></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="epl-output-groupby"></a>4.7.2.&nbsp;Aggregation, Group By, Having and Output clause interaction</h3></div></div><div></div></div><p>
					Remove stream events can also useful in conjunction with aggregation and the <tt class="literal">output</tt> clause: When the engine posts remove stream events for fully-aggregated queries, it presents the aggregation state before the expiring event leaves the data window. Your application can thus easily obtain a delta between the new aggregation value and the prior aggregation value.
				</p><p>
					The engine evaluates the having-clause at the granularity of the data posted by views. That is, if you utilize a time window and output every 10 events, the <tt class="literal">having</tt> clause applies to each individual event or events entering and leaving the time window (and not once per batch of 10 events).
				</p><p>
					The <tt class="literal">output</tt> clause interacts in two ways with the <tt class="literal">group by</tt> and <tt class="literal">having</tt> clauses. First, in the <tt class="literal">output every n events </tt>case, the number <tt class="literal">n</tt> refers to the number of events arriving into the <tt class="literal">group by clause</tt>. That is, if the <tt class="literal">group by</tt> clause outputs only 1 event per group, or if the arriving events don't satisfy the <tt class="literal">having</tt> clause, then the actual number of events output by the statement could be fewer than <tt class="literal">n</tt>.
				</p><p>
					Second, the <tt class="literal">last</tt> and <tt class="literal">all</tt> keywords have special meanings when used in a statement with aggregate functions and the <tt class="literal">group by</tt> clause:
				</p><div class="itemizedlist"><ul type="disc" compact><li><p>
							When no keyword is specified, the engine produces an output row for each row in the batch.
						</p></li><li><p>
							The <tt class="literal">all</tt> keyword (the default) specifies that the most recent data for <span class="emphasis"><em>all</em></span> groups seen so far should be output, whether or not these groups' aggregate values have just been updated
						</p></li><li><p>
							The <tt class="literal">last</tt> keyword specifies that only groups whose aggregate values have been updated with the most recent batch of events should be output.
						</p></li></ul></div><p>
					Please consult the <a href="#appendix_outputspec" title="Appendix&nbsp;A.&nbsp;Output Reference and Samples">Appendix&nbsp;A, <i>Output Reference and Samples</i></a> for detailed information on insert and remove stream output for aggregation and group-by.
				</p><p>
					By adding an output rate limiting clause to a statement that contains a <span class="emphasis"><em>group by</em></span> clause we can control output of groups to obtain one row for each group, generating an event per group at the given output frequency:
				</p><pre class="programlisting">select symbol, sum(price) from StockTickEvent group by symbol output all every 5 seconds</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="epl-output-runtime"></a>4.7.3.&nbsp;Runtime Considerations</h3></div></div><div></div></div><p>
					Output rate limiting provides output events to your application in regular intervals. Between intervals, the engine uses a buffer to hold events until the output condition is reached. If your application
					has high-volume streams, you may need to be mindful of the memory needs for output rates.
				</p><p>
					The <tt class="literal">output</tt> clause with the <tt class="literal">snapshot</tt> keyword does not require a buffer, all other output keywords do consume memory until the output condition is reached.
				</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="epl-order-by"></a>4.8.&nbsp;Sorting Output: the <span class="emphasis"><em>Order By</em></span> Clause</h2></div></div><div></div></div><a class="indexterm" name="d0e5027"></a><a class="indexterm" name="d0e5030"></a><a class="indexterm" name="d0e5033"></a><a class="indexterm" name="d0e5036"></a><p>
			The <tt class="literal">order by</tt> clause is optional. It is used for ordering output events by their properties, or by expressions involving those properties. .				
		</p><p>
			For example, the following statement outputs batches of 5 or more stock tick events that are sorted first by price ascending and then by volume ascending:
		</p><pre class="programlisting">select symbol from StockTickEvent.win:time(60 sec) 
output every 5 events 
order by price, volume</pre><p>
			Here is the syntax for the <tt class="literal">order by</tt> clause:				
		</p><pre class="synopsis">order by <span class="emphasis"><em>expression</em></span> [asc | desc] [, <span class="emphasis"><em>expression</em></span> [asc | desc]] [, ...]</pre><p>
			If the <tt class="literal">order by</tt> clause is absent then the engine still makes certain guarantees about the ordering of output: 
		</p><div class="itemizedlist"><ul type="disc" compact><li><p>
					If the statement is not a join, does not group via <tt class="literal">group by</tt> clause and does not declare grouped data windows via <tt class="literal">std:groupby</tt> view, the order in which events are delivered to listeners and through the <tt class="literal">iterator</tt> pull API is the order of event arrival.
				</p></li><li><p>
					If the statement is a join or outer join, or groups, then the order in which events are delivered to listeners and through the <tt class="literal">iterator</tt> pull API is not well-defined. Use the <tt class="literal">order by</tt> clause if your application requires events to be delivered in a well-defined order.
				</p></li></ul></div><p>
			Esper places the following restrictions on the expressions in the <tt class="literal">order by</tt> clause:
		</p><div class="orderedlist"><ol type="1" compact><li><p>
					All aggregate functions that appear in the <tt class="literal">order by</tt> clause must also appear in the <tt class="literal">select</tt> expression.
				</p></li></ol></div><p>
			Otherwise, any kind of expression that can appear in the <tt class="literal">select</tt> clause, 
			as well as any name defined in the <tt class="literal">select</tt> clause, is also valid in the order by clause.
		</p><p>
			By default all sort operations on string values are performed via the <tt class="literal">compare</tt> method and are thus not locale dependent. To account for differences in language or locale, see <a href="#config-engine-language" title="10.4.17.&nbsp;Engine Settings related to Language and Locale">Section&nbsp;10.4.17, &#8220;Engine Settings related to Language and Locale&#8221;</a> to change this setting.
		</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="epl-limit"></a>4.9.&nbsp;Limiting Row Count: the <span class="emphasis"><em>Limit</em></span> Clause</h2></div></div><div></div></div><a class="indexterm" name="d0e5126"></a><a class="indexterm" name="d0e5129"></a><a class="indexterm" name="d0e5132"></a><a class="indexterm" name="d0e5135"></a><p>
			The <tt class="literal">limit</tt> clause is typically used together with the <tt class="literal">order by</tt> and <tt class="literal">output</tt> clause to limit your query results to those that fall within a specified range. You can use it to receive the first given number of result rows, or to receive a range of result rows. 
		</p><p>
			There are two syntaxes for the <tt class="literal">limit</tt> clause, each can be parameterized by integer constants or by variable names. The first syntax is shown below:				
		</p><pre class="synopsis">limit <span class="emphasis"><em>row_count</em></span> [offset <span class="emphasis"><em>offset_count</em></span>]</pre><p>
			The required <span class="emphasis"><em>row_count</em></span> parameter specifies the number of rows to output. The <span class="emphasis"><em>row_count</em></span> can be an integer constant 
			and can also be the name of the integer-type variable to evaluate at runtime.
		</p><p>
			The optional <span class="emphasis"><em>offset_count</em></span> parameter specifies the number of rows that should be skipped (offset) at the beginning of the result set. A variable can also be used for this parameter.
		</p><p>
			The next sample EPL query outputs the top 10 counts per property 'uri' every 1 minute.
		</p><pre class="programlisting">select uri, count(*) from WebEvent 
group by uri 
output snapshot every 1 minute
order by count(*) desc 
limit 10</pre><p>
			The next statement demonstrates the use of the <tt class="literal">offset</tt> keyword. It outputs ranks 3 to 10 per property 'uri' every 1 minute:
		</p><pre class="programlisting">select uri, count(*) from WebEvent 
group by uri 
output snapshot every 1 minute
order by count(*) desc 
limit 8 offset 2</pre><p>
			The second syntax for the <tt class="literal">limit</tt> clause is for SQL standard compatibility and specifies the offset first, followed by the row count:
		</p><pre class="synopsis">limit <span class="emphasis"><em>offset_count</em></span>[, <span class="emphasis"><em>row_count</em></span>]</pre><p>
			The following are equivalent:
		</p><pre class="programlisting">limit 8 offset 2
// ...equivalent to
limit 2, 8</pre><p>
			A negative value for <span class="emphasis"><em>row_count</em></span> returns an unlimited number or rows, and a zero value returns no rows. If variables are used, then the current variable value at the time of output dictates the row count and offset. A variable returning a null value for <span class="emphasis"><em>row_count</em></span> also returns an unlimited number or rows. 
		</p><p>
			A negative value for offset is not allowed. If your variable returns a negative or null value for offset then the value is assumed to be zero (i.e. no offset).
		</p><p>
			The <tt class="literal">iterator</tt> pull API also honors the <tt class="literal">limit</tt> clause, if present.
		</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="epl-insert-into"></a>4.10.&nbsp;Merging Streams and Continuous Insertion: the <span class="emphasis"><em>Insert Into</em></span> Clause</h2></div></div><div></div></div><a class="indexterm" name="d0e5229"></a><a class="indexterm" name="d0e5232"></a><p>
			The <tt class="literal">insert into</tt> clause is optional in Esper. The clause can be specified to make the results of a statement available as an event stream for use
			in further statements, or to insert events into a named window. The clause can also be used to merge multiple event streams to form a single stream of events.
		</p><p>
			The syntax for the <tt class="literal">insert into</tt> clause is as follows:
		</p><pre class="synopsis">insert [istream | rstream] into <span class="emphasis"><em>event_stream_name</em></span>  [ (<span class="emphasis"><em>property_name</em></span> [, property_name] ) ]</pre><p>
			The <tt class="literal">istream</tt> (default) and <tt class="literal">rstream</tt> keywords are optional. If no keyword or the <tt class="literal">istream</tt> keyword is specified, the engine supplies the insert stream events generated by the statement. The insert stream consists of the events entering the respective window(s) or stream(s). If the <tt class="literal">rstream</tt> keyword is specified, the engine supplies the remove stream events generated by the statement. The remove stream consists of the events leaving the respective window(s). 
		</p><p>
			The <tt class="literal">event_stream_name</tt> is an identifier that names the event stream (and also implicitly names the types of events in the stream) generated by the engine. The identifier can be used in further statements to filter and
			process events of that event stream. The <tt class="literal">insert into</tt> clause can consist of just an event stream name, or an event stream name and one or more property names.
		</p><p>
			The engine also allows listeners to be attached to a statement that contain an <tt class="literal">insert into</tt> clause. Listeners receive all events posted to the event stream.
		</p><p>
			To merge event streams, simply use the same <tt class="literal">event_stream_name</tt> identifier in all EPL statements that merge their result event streams. Make sure to use the
			same number and names of event properties and event property types match up.
		</p><p>
			Esper places the following restrictions on the <tt class="literal">insert into</tt> clause:
		</p><div class="orderedlist"><ol type="1" compact><li><p>
					The number of elements in the <tt class="literal">select</tt> clause must match the number of elements in the <tt class="literal">insert into</tt> clause if the clause specifies a list of event property names
				</p></li><li><p>
					If the event stream name has already been defined by a prior statement or configuration, and the event property names and/or event types do not match, an exception is thrown at statement creation time.
				</p></li></ol></div><p>
			The following sample inserts into an event stream by name CombinedEvent:
		</p><pre class="programlisting">insert into CombinedEvent
select A.customerId as custId, A.timestamp - B.timestamp as latency
  from EventA.win:time(30 min) A, EventB.win:time(30 min) B
 where A.txnId = B.txnId</pre><p>
			Each event in the <tt class="literal">CombinedEvent</tt> event stream has two event properties named "custId" and "latency". The events generated by the above statement can be used in further statements, such as shown in the next statement:
		</p><pre class="programlisting">select custId, sum(latency)
  from CombinedEvent.win:time(30 min)
 group by custId</pre><p>
			The example statement below shows the alternative form of the <tt class="literal">insert into</tt> clause that explicitly defines the property names to use.
		</p><pre class="programlisting">insert into CombinedEvent (custId, latency)
select A.customerId, A.timestamp - B.timestamp 
...</pre><p>
			The <tt class="literal">rstream</tt> keyword can be useful to indicate to the engine to generate only remove stream events. This can be useful if we want to trigger 
			actions when events leave a window rather then when events enter a window. The statement below generates <tt class="literal">CombinedEvent</tt> events when
			EventA and EventB leave the window after 30 minutes.
		</p><pre class="programlisting">insert rstream into CombinedEvent
select A.customerId as custId, A.timestamp - B.timestamp as latency
  from EventA.win:time(30 min) A, EventB.win:time(30 min) B
 where A.txnId = B.txnId</pre><p>
			The <tt class="literal">insert into</tt> clause can be used in connection with patterns to provide pattern results to further statements for analysis:
		</p><pre class="programlisting">insert into ReUpEvent
select linkUp.ip as ip 
from pattern [every linkDown=LinkDownEvent -&gt; linkUp=LinkUpEvent(ip=linkDown.ip)]</pre><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="insert-into-property-transpose"></a>4.10.1.&nbsp;Transposing a Property To a Stream</h3></div></div><div></div></div><p>
				Sometimes your events may carry properties that are themselves event objects. Therefore EPL offers a special syntax to insert the value of a property itself as an event into a stream:
			</p><pre class="synopsis">insert into <span class="emphasis"><em>stream_name</em></span> select <span class="emphasis"><em>property_name</em></span>.* from ...</pre><p>
				This feature is only supported for JavaBean events and is not supported for <tt class="literal">Map</tt> or <tt class="literal">XML</tt> events. Nested property names are also not supported.
			</p><p>
				In this example, the class <tt class="literal">Summary</tt> with properties <tt class="literal">bid</tt> and <tt class="literal">ask</tt> that are of type <tt class="literal">Quote</tt> is:
			</p><pre class="programlisting">public class Summary {
  private Quote bid;
  private Quote ask;
  ...</pre><p>
				The statement to populate a stream of <tt class="literal">Quote</tt> events is thus:
			</p><pre class="programlisting">insert into MyBidStream select bid.* from Summary</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="insert-into-merging-columns"></a>4.10.2.&nbsp;Merging Streams By Event Type</h3></div></div><div></div></div><p>
				The <tt class="literal">insert into</tt> clause allows to merge multiple event streams into a event single stream. 
				The clause names an event stream to insert into by specifing an <span class="emphasis"><em>event_stream_name</em></span>. The first statement that inserts into the named stream defines the stream's event types. Further statements that
				insert into the same event stream must match the type of events inserted into the stream as declared by the first statement.
			</p><p>
			    One approach to merging event streams specifies individual colum names either in the <tt class="literal">select</tt> clause or in the <tt class="literal">insert into</tt> clause of the statement. This approach has been shown in earlier examples.
			</p><p>
			    Another approach to merging event streams specifies the wildcard (*) in the <tt class="literal">select</tt> clause (or the stream wildcard) to select the underlying event. The events in the event stream must then 
			    have the same event type as generated by the <tt class="literal">from</tt> clause.
			</p><p>
			    Assume a statement creates an event stream named MergedStream by selecting OrderEvent events:
			</p><pre class="programlisting">insert into MergedStream select * from OrderEvent</pre><p>
			    A statement can use the stream wildcard selector to select only OrderEvent events in a join:
			</p><pre class="programlisting">insert into MergedStream select ord.* from ItemScanEvent, OrderEvent as ord</pre><p>
			    And a statement may also use an application-supplied user-defined function to convert events to OrderEvent instances:
			</p><pre class="programlisting">insert into MergedStream select MyLib.convert(item) from ItemScanEvent as item</pre><p>
			    Esper specifically recognizes a conversion function: A conversion function must be the only selected column, and it must return either a Java object or <tt class="literal">java.util.Map</tt>.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="insert-into-merging-types"></a>4.10.3.&nbsp;Merging Disparate Types of Events: Variant Streams</h3></div></div><div></div></div><a class="indexterm" name="d0e5431"></a><p>
				A <span class="emphasis"><em>variant stream</em></span> is a predefined stream into which events of multiple disparate event types can be inserted. 
			</p><p>
				A variant stream name may appear anywhere in a pattern or <tt class="literal">from</tt> clause. In a pattern, a filter against a variant stream matches any events of any of the event types inserted into the variant stream. 
				In a <tt class="literal">from</tt> clause including for named windows, views declared onto a variant stream may hold events of any of the event types inserted into the variant stream.
			</p><p>
				A variant stream is thus useful in problems that require different types of event to be treated the same.
			</p><p>
				Variant streams are predefined via runtime or initialization-time configuration as described in <a href="#config-variantstream" title="10.4.21.&nbsp;Variant Stream">Section&nbsp;10.4.21, &#8220;Variant Stream&#8221;</a>. Your application may predefine variant streams to carry events of a limited set of event types, or you may choose the variant stream to carry any and all types of events. This choice affects what event properties are available for consuming statements or patterns of the variant stream.
			</p><p>
				Assume that an application predefined a variant stream named <tt class="literal">OrderStream</tt> to carry only <tt class="literal">ServiceOrder</tt> and <tt class="literal">ProductOrder</tt> events. An <tt class="literal">insert into</tt> clause inserts events into
				the variant stream:
			</p><pre class="programlisting">insert into OrderStream select * from ServiceOrder
insert into OrderStream select * from ProductOrder</pre><p>
				Here is a sample statement that consumes the variant stream and outputs a total price per customer id for the last 30 seconds of <tt class="literal">ServiceOrder</tt> and <tt class="literal">ProductOrder</tt> events:
			</p><pre class="programlisting">select customerId, sum(price) from OrderStream.win:time(30 sec) group by customerId</pre><p>
				If your application predefines the variant stream to hold specific type of events, as the sample above did, then all event properties that are common to all specified types are visible on the variant stream, including nested, indexed and mapped properties. For access to properties that are only available on one of the types, the dynamic property syntax must be used. In the example above, the <tt class="literal">customerId</tt> and <tt class="literal">price</tt> were properties common to both <tt class="literal">ServiceOrder</tt> and <tt class="literal">ProductOrder</tt> events.
			</p><p>
				For example, here is a consuming statement that selects a <tt class="literal">service duraction</tt> property that only <tt class="literal">ServiceOrder</tt> events have, and that must therefore be casted to double and null values removed in order to aggregate:
			</p><pre class="programlisting">select customerId, sum(coalesce(cast(serviceDuraction?, double), 0)) 
from OrderStream.win:time(30 sec) group by customerId</pre><p>
				If your application predefines a variant stream to hold any type of events (the <tt class="literal">any</tt> type variance), then all event properties of the variant stream are effectively dynamic properties. 
			</p><p>
				For example, an application may define an <tt class="literal">OutgoingEvents</tt> variant stream to hold any type of event. The next statement is a sample consumer of the <tt class="literal">OutgoingEvents</tt> variant stream that looks for the <tt class="literal">destination</tt> property and fires for each event in which the property exists with a value of <tt class="literal">'email'</tt>:
			</p><pre class="programlisting">select * from OutgoingEvents(destination = 'email')</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="insert-into-decorated"></a>4.10.4.&nbsp;Decorated Events</h3></div></div><div></div></div><a class="indexterm" name="d0e5527"></a><p>
				Your <tt class="literal">select</tt> clause may use the '*' wildcard together with further expressions to populate a stream of events. A sample statement is:				
			</p><pre class="programlisting">insert into OrderStream select *, price*units as linePrice from PurchaseOrder</pre><p>
				When using wildcard and selecting additional expression results, the engine produces what is called <span class="emphasis"><em>decorating</em></span> events for the resulting stream. Decorating events add additional property values to an underlying event.
			</p><p>
				In the above example the resulting OrderStream consists of underlying PurchaseOrder events <span class="emphasis"><em>decorated</em></span> by a <tt class="literal">linePrice</tt> property that is a result of the <tt class="literal">price*units</tt> expression.
			</p><p>
				In order to use <tt class="literal">insert into </tt> to insert into an existing stream of decorated events, your underlying event type must match, and all additional decorating property names and types of the <tt class="literal">select</tt> clause must also match.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="insert-into-eventasproperty"></a>4.10.5.&nbsp;Event as a Property</h3></div></div><div></div></div><a class="indexterm" name="d0e5564"></a><p>
				Your <tt class="literal">select</tt> clause may use the stream name to populate a stream of events in which each event has properties that are itself an event. A sample statement is:				
			</p><pre class="programlisting">insert into CompositeStream select order, service, order.price+service.price as totalPrice 
from PurchaseOrder.std:lastevent() as order, ServiceEvent:std:lastevent() as service</pre><p>
				When using the stream name (or tag in patterns) in the select clause, the engine produces composite events: One or more of the properties of the composite event are events themselves.
			</p><p>
				In the above example the resulting CompositeStream consists of 3 columns: the PurchaseOrder event, the ServiceEvent event and the <tt class="literal">totalPrice</tt> property that is a result of the <tt class="literal">order.price+service.price</tt> expression.
			</p><p>
				In order to use <tt class="literal">insert into </tt> to insert into an existing stream of events in which properties are themselves events, each event column's event type must match, and all additional property names and types of the <tt class="literal">select</tt> clause must also match.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="insert-into-populate"></a>4.10.6.&nbsp;Populating an Underlying Event Object</h3></div></div><div></div></div><p>
				Your <tt class="literal">insert into</tt> clause may also directly instantiate and populate application underlying event objects or <tt class="literal">Map</tt> event objects. This is described in greater detail in <a href="#eventrep-insertinto" title="2.11.&nbsp;Event Objects Populated by Insert Into">Section&nbsp;2.11, &#8220;Event Objects Populated by Insert Into&#8221;</a>.
			</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="epl-join"></a>4.11.&nbsp;Joining Event Streams</h2></div></div><div></div></div><a class="indexterm" name="d0e5608"></a><a class="indexterm" name="d0e5611"></a><p>
			Two or more event streams can be part of the <tt class="literal">from</tt> clause and thus both (all) streams determine the resulting events. The <tt class="literal">where</tt> clause lists the join conditions that Esper uses to relate events in the two or more streams. Reference and historical data such as stored in your relational database, and data returned by a method invocation, can also be included in joins. Please see <a href="#histdata_overview" title="4.15.&nbsp;Accessing Relational Data via SQL">Section&nbsp;4.15, &#8220;Accessing Relational Data via SQL&#8221;</a> and <a href="#joining_method" title="4.16.&nbsp;Accessing Non-Relational Data via Method Invocation">Section&nbsp;4.16, &#8220;Accessing Non-Relational Data via Method Invocation&#8221;</a> for details.
		</p><p>
			Each point in time that an event arrives to one of the event streams, the two event streams are joined and output events are produced according to the <tt class="literal">where</tt> clause.
		</p><p>
			This example joins 2 event streams. The first event stream consists of fraud warning events for which we keep the last 30 minutes. The second stream is withdrawal events for which we consider the last 30 seconds. The streams are joined on account number.
		</p><pre class="programlisting">select fraud.accountNumber as accntNum, fraud.warning as warn, withdraw.amount as amount,
       max(fraud.timestamp, withdraw.timestamp) as timestamp, 'withdrawlFraud' as desc
  from com.espertech.esper.example.atm.FraudWarningEvent.win:time(30 min) as fraud,
       com.espertech.esper.example.atm.WithdrawalEvent.win:time(30 sec) as withdraw
 where fraud.accountNumber = withdraw.accountNumber</pre><p>
			Joins can also include one or more pattern statements as the next example shows:
		</p><pre class="programlisting">select * from FraudWarningEvent.win:time(30 min) as fraud,
    pattern [every w=WithdrawalEvent -&gt; PINChangeEvent(acct=w.acct)].std:lastevent() as withdraw
 where fraud.accountNumber = withdraw.w.accountNumber</pre><p>
			The statement above joins the last 30 minutes of fraud warnings with a pattern. The pattern consists of every withdrawal event that is followed by a PIN change event for the same account number. It joins the two event streams on account number. The last-event view instucts the join to only consider the last pattern match.
		</p><p>
			In a join and outer join, your statement must declare a data window view or other view onto each stream. Streams that are marked as unidirectional and named windows as well as database or methods in a join are an exception and do not require a view to be specified. If you are joining an event to itself via contained-event selection, views also do not need to be specified.
		</p><p>
			The next example joins all FraudWarningEvent events that arrived since the statement was started, with the last 20 seconds of PINChangeEvent events:
		</p><pre class="programlisting">select * from FraudWarningEvent.win:keepall() as fraud, PINChangeEvent.win:time(20 sec) as pin
 where fraud.accountNumber = pin.accountNumber</pre><p>
			The above example employed the special keep-all view that retains all events.
		</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="epl-outerjoin"></a>4.12.&nbsp;Outer and Inner Joins</h2></div></div><div></div></div><a class="indexterm" name="d0e5654"></a><a class="indexterm" name="d0e5657"></a><a class="indexterm" name="d0e5660"></a><a class="indexterm" name="d0e5665"></a><p>
			Esper supports left outer joins, right outer joins, full outer joins and inner joins in any combination between an unlimited number of event streams. Outer and inner joins can also join reference and historical data as explained in <a href="#histdata_overview" title="4.15.&nbsp;Accessing Relational Data via SQL">Section&nbsp;4.15, &#8220;Accessing Relational Data via SQL&#8221;</a>, as well as join data returned by a method invocation as outlined in <a href="#joining_method" title="4.16.&nbsp;Accessing Non-Relational Data via Method Invocation">Section&nbsp;4.16, &#8220;Accessing Non-Relational Data via Method Invocation&#8221;</a>.
		</p><p>
			The keywords <tt class="literal">left, right, full</tt> and <tt class="literal">inner</tt> control the type of the join between two streams. The <tt class="literal">on</tt> clause specifies one or more properties that join each stream. The synopsis is as follows:
		</p><pre class="synopsis">...from <span class="emphasis"><em>stream_def</em></span> [as name] 
  ((left|right|full outer) | inner) join <span class="emphasis"><em>stream_def</em></span> 
  on <span class="emphasis"><em>property</em></span> = <span class="emphasis"><em>property</em></span> [and <span class="emphasis"><em>property</em></span> = <span class="emphasis"><em>property</em></span> ...]
  [ ((left|right|full outer) | inner) join <span class="emphasis"><em>stream_def</em></span> on ...]...
</pre><p>
			If the outer join is a left outer join, there will be an output event for each event of the stream on the left-hand side of the clause. For example, in the left outer join shown below we will get output for each event in the stream RfidEvent, even if the event does not match any event in the event stream OrderList.
		</p><pre class="programlisting">select * from RfidEvent.win:time(30 sec) as rfid
       left outer join
       OrderList.win:length(10000) as orderlist
     on rfid.itemId = orderList.itemId</pre><p>
			Similarly, if the join is a Right Outer Join, then there will be an output event for each event of the stream on the right-hand side of the clause. For example, in the right outer join shown below we will get output for each event in the stream OrderList, even if the event does not match any event in the event stream RfidEvent.
		</p><pre class="programlisting">select * from RfidEvent.win:time(30 sec) as rfid
       right outer join
       OrderList.win:length(10000) as orderlist
       on rfid.itemId = orderList.itemId</pre><p>
			For all types of outer joins, if the join condition is not met, the select list is computed with the event properties of the arrived event while all other event properties are considered to be null.
		</p><p>
			The next type of outer join is a full outer join. In a full outer join, each point in time that an event arrives to one of the event streams, one or more output events are produced. In the example below, when either an RfidEvent or an OrderList event arrive, one or more output event is produced. The next example shows a full outer join that joins on multiple properties:
		</p><pre class="programlisting">select * from RfidEvent.win:time(30 sec) as rfid
       full outer join
       OrderList.win:length(10000) as orderlist
       on rfid.itemId = orderList.itemId and rfid.assetId = orderList.assetId</pre><p>
			The last type of join is an inner join. In an inner join, the engine produces an output event for each event of the stream on the left-hand side that matches at least one event on the right hand side considering the join properties. For example, in the inner join shown below we will get output for each event in the RfidEvent stream that matches one or more events in the OrderList data window:
		</p><pre class="programlisting">select * from RfidEvent.win:time(30 sec) as rfid
       inner join
       OrderList.win:length(10000) as orderlist
       on rfid.itemId = orderList.itemId and rfid.assetId = orderList.assetId</pre><p>
			Patterns as streams in a join follow this rule: If no data window view is declared for the pattern then the pattern stream retains the last match. Thus a pattern must have matched at least once for the last row to become available in a join. Multiple rows from a pattern stream may be retained by declaring a data window view onto a pattern using the <tt class="literal">pattern [...].</tt><span class="emphasis"><em>view_specification</em></span> syntax.
		</p><p>
			Finally, this example outer joins multiple streams. Here the RfidEvent stream is outer joined to both ProductName and LocationDescription via left outer join:
		</p><pre class="programlisting">select * from RfidEvent.win:time(30 sec) as rfid
      left outer join ProductName.win:keepall() as refprod
        on rfid.productId = refprod.prodId
      left outer join LocationDescription.win:keepall() as refdesc
        on rfid.location = refdesc.locId</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="epl-unidirectional"></a>4.13.&nbsp;Unidirectional Joins</h2></div></div><div></div></div><a class="indexterm" name="d0e5742"></a><a class="indexterm" name="d0e5745"></a><a class="indexterm" name="d0e5750"></a><p>
			In a join or outer join your statement lists multiple event streams, views and/or patterns in the <tt class="literal">from</tt> clause. As events arrive into the engine, each of the streams (views, patterns) provides insert and remove stream events. The engine evaluates each insert and remove stream event provided by each stream, and joins or outer joins each event against data window contents of each stream, and thus generates insert and remove stream join results.
		</p><p>
		    The direction of the join execution depends on which stream or streams are currently providing an insert or remove stream event for executing the join. A join is thus multidirectional, or bidirectional when only two streams are joined.
			A join can be made unidirectional if your application does not want new results when events arrive on a given stream or streams.
		</p><p>
			The <tt class="literal">unidirectional</tt> keyword can be used in the <tt class="literal">from</tt> clause to identify a single stream that provides the events to execute the join. If the keyword is present for a stream, all other streams in the <tt class="literal">from</tt> clause become passive streams. When events arrive or leave a data window of a passive stream then the join does not generate join results. 
		</p><p>
			For example, consider a use case that requires us to join stock tick events (TickEvent) and news events (NewsEvent). The <tt class="literal">unidirectional</tt> keyword allows to generate results only when TickEvent events arrive, and not when NewsEvent arrive or leave the 10-second time window:
		</p><pre class="programlisting">select * from TickEvent unidirectional, NewsEvent.win:time(10 sec) 
where tick.symbol = news.symbol</pre><p>
			Aggregation functions in a <tt class="literal">unidirectional</tt> join aggregate within the context of each unidirectional event evaluation and are not cumulative.
		</p><p>
			The count function in the next query returns, for each TickEvent, the number of matching NewEvent events:
		</p><pre class="programlisting">select count(*) from TickEvent unidirectional, NewsEvent.win:time(10 sec) 
where tick.symbol = news.symbol</pre><p>
			The following restrictions apply to unidirectional joins:
		</p><div class="orderedlist"><ol type="1" compact><li><p>
					The <tt class="literal">unidirectional</tt> keyword can only be specified for a single stream in the <tt class="literal">from</tt> clause. 
				</p></li><li><p>
					Receiving data from a unidirectional join via the pull API (<tt class="literal">iterator</tt> method) is not allowed. This is because the engine holds no state for the single stream that provides the events to execute the join.
				</p></li><li><p>
					The stream that declares the <tt class="literal">unidirectional</tt> keyword cannot declare a data window view or other view for that stream, since remove stream events are not processed for the single stream.
				</p></li></ol></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="epl-subqueries"></a>4.14.&nbsp;Subqueries</h2></div></div><div></div></div><a class="indexterm" name="d0e5816"></a><a class="indexterm" name="d0e5819"></a><p>
			A subquery is a <tt class="literal">select</tt> within another statement. Esper supports subqueries in the <tt class="literal">select</tt> clause and in the <tt class="literal">where</tt> clause of EPL statements. Subqueries provide an alternative way to perform operations that would otherwise require complex joins. Subqueries can also make statements more readable then complex joins. 
	    </p><p>
			Esper supports both simple subqueries as well as correlated subqueries. In a simple subquery, the inner query is not correlated to the outer query. Here is an example simple subquery within a <tt class="literal">select</tt> clause:
	    </p><pre class="programlisting">select assetId, (select zone from ZoneClosed.std:lastevent) as lastClosed from RFIDEvent</pre><p>
			If the inner query is dependent on the outer query, we will have a correlated subquery. An example of a correlated subquery is shown below. Notice the <tt class="literal">where</tt> clause in the inner query, where the condition involves a stream from the outer query:
	    </p><pre class="programlisting">select * from RfidEvent as RFID where 'Dock 1' = 
  (select name from Zones.std:unique(zoneId) where zoneId = RFID.zoneId)</pre><p>
			The example above shows a subquery in the <tt class="literal">where</tt> clause. The statement selects RFID events in which the zone name matches a string constant based on zone id. The statement uses the view <tt class="literal">std:unique</tt> to guarantee that only the last event per zone id is held from processing by the subquery.
		</p><p>
			The next example is a correlated subquery within a <tt class="literal">select</tt> clause. In this statement the <tt class="literal">select</tt> clause retrieves the zone name by means of a subquery against the Zones set of events correlated by zone id:
		</p><pre class="programlisting">select zoneId, (select name from Zones.std:unique(zoneId) 
  where zoneId = RFID.zoneId) as name from RFIDEvent</pre><p>
			Note that when a simple or correlated subquery returns multiple rows, the engine returns a <tt class="literal">null</tt> value as the subquery result. To limit the number of events returned by a subquery consider using one of the views <tt class="literal">std:lastevent</tt>, <tt class="literal">std:unique</tt> and <tt class="literal">std:groupby</tt>.
		</p><p>
			The <tt class="literal">select</tt> clause of a subquery also allows wildcard selects, which return as an event property the underlying event object of the event type as defined in the <tt class="literal">from</tt> clause. An example:
		</p><pre class="programlisting">select (select * from MarketData.std:lastevent()) as md 
  from pattern [every timer:interval(10 sec)]</pre><p>
			The output events to the statement above contain the underlying MarketData event in a property named "md". The statement populates the last MarketData event into a property named "md" every 10 seconds following the pattern definition, or populates a <tt class="literal">null</tt> value if no MarketData event has been encountered so far.
		</p><p>
			Aggregation functions may be used in the <tt class="literal">select</tt> clause of the subselect as this example outlines:
		</p><pre class="programlisting">select * from MarketData
where price &gt; (select max(price) from MarketData(symbol='GOOG').std:lastevent())</pre><p>
			As the sub-select expression is evaluated first, the query above actually never fires for the GOOG symbol, only for other symbols that have a price higher then the current maximum for GOOG. As a sidenote, the <tt class="literal">insert into</tt> clause can also be handy to compute aggregation results for use in multiple subqueries.
		</p><p>
			The following restrictions apply to subqueries:
		</p><div class="orderedlist"><ol type="1" compact><li><p>
					The subquery stream definition must define a data window or other view to limit subquery results, reducing the number of events held for subquery execution
				</p></li><li><p>
					Subqueries can only consist of a <tt class="literal">select</tt> clause, a <tt class="literal">from</tt> clause and a <tt class="literal">where</tt> clause. The <tt class="literal">group by</tt> and <tt class="literal">having</tt> clauses, as well as joins, outer-joins and output rate limiting are not permitted within subqueries.
				</p></li><li><p>
					If using aggregation functions in a subquery, note these limitations:
				</p><div class="orderedlist"><ol type="a" compact><li><p>
							None of the properties of the correlated stream(s) can be used within aggregation functions.
						</p></li><li><p>
							The properties of the subselect stream must all be within aggregation functions.
						</p></li><li><p>
							The <tt class="literal">where</tt> clause cannot be used to correlate between the subselect stream and the enclosing stream, since the engine would otherwise be forced to re-evaluate 
							the aggregation considering all events in the subselect-stream data window, which would likely be a very expensive operation.
						</p></li></ol></div></li></ol></div><p>
			The order of evaluation of subqueries relative to the containing statement is guaranteed: If the containing statement and its subqueries are reacting to the same type of event, the subquery will receive the
			event first before the containing statement's clauses are evaluated. This behavior can be changed via configuration. The order of evaluation of subqueries is not guaranteed between subqueries.
		</p><p>
			Performance of your statement containing one or more subqueries principally depends on two parameters. First, if your subquery correlates one or more columns in the subquery stream with the enclosing statement's streams via equals '=', the engine automatically builds the appropriate indexes for fast row retrieval based on the key values correlated (joined). The second parameter is the number of rows found in the subquery stream and the complexity of the filter criteria (<tt class="literal">where</tt> clause), as each row in the subquery stream must evaluate against the <tt class="literal">where</tt> clause filter.
		</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="epl-subqueries-exists"></a>4.14.1.&nbsp;The '<tt class="literal">exists</tt>' Keyword</h3></div></div><div></div></div><p>
				The <tt class="literal">exists</tt> condition is considered "to be met" if the subquery returns at least one row. The <tt class="literal">not exists</tt> condition is considered true if the subquery returns no rows.
			</p><p>
				The synopsis for the <tt class="literal">exists</tt> keyword is as follows:
			</p><pre class="synopsis">exists (<span class="emphasis"><em>subquery</em></span>)</pre><p>
				Let's take a look at a simple example. The following is an EPL statement that uses the <tt class="literal">exists</tt> condition:
			</p><pre class="programlisting">select assetId from RFIDEvent as RFID 
  where exists (select * from Asset.std:unique(assetId) where assetId = RFID.assetId)</pre><p>
				This select statement will return all RFID events where there is at least one event in Assets unique by asset id with the same asset id.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="epl-subqueries-in"></a>4.14.2.&nbsp;The '<tt class="literal">in</tt>' and '<tt class="literal">not in</tt>' Keywords</h3></div></div><div></div></div><p>
				The <tt class="literal">in</tt> subquery condition is true if the value of an expression matches one or more of the values returned by the subquery. Consequently, the <tt class="literal">not in</tt> condition is true if the value of an expression matches none of the values returned by the subquery.
			</p><p>
				The synopsis for the <tt class="literal">in</tt> keyword is as follows:
			</p><pre class="synopsis"><span class="emphasis"><em>expression</em></span> in (<span class="emphasis"><em>subquery</em></span>)</pre><p>
				The right-hand side subquery must return exactly one column.
			</p><p>
				The next statement demonstrates the use of the <tt class="literal">in</tt> subquery condition: 
			</p><pre class="programlisting">select assetId from RFIDEvent
  where zone in (select zone from ZoneUpdate(status = 'closed').win:time(10 min))</pre><p>
				The above statement demonstrated the <tt class="literal">in</tt> subquery to select RFID events for which the zone status is in a closed state. 
			</p><p>
				Note that if the left-hand expression yields null, or if there are no equal right-hand values and at least one right-hand row yields null, the result of the <tt class="literal">in</tt> construct will be null, not false (or true for <tt class="literal">not-in</tt>). This is in accordance with SQL's normal rules for Boolean combinations of null values.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="epl-subqueries-anysome"></a>4.14.3.&nbsp;The '<tt class="literal">any</tt>' and '<tt class="literal">some</tt>' Keywords</h3></div></div><div></div></div><p>
				The <tt class="literal">any</tt> subquery condition is true if the expression returns true for one or more of the values returned by the subquery.
			</p><p>
				The synopsis for the <tt class="literal">any</tt> keyword is as follows:
			</p><pre class="synopsis"><span class="emphasis"><em>expression</em></span> <span class="emphasis"><em>operator</em></span> any (<span class="emphasis"><em>subquery</em></span>)
<span class="emphasis"><em>expression</em></span> <span class="emphasis"><em>operator</em></span> some (<span class="emphasis"><em>subquery</em></span>)</pre><p>
				The left-hand expression is evaluated and compared to each row of the subquery result using the given operator, which must yield a Boolean result. The result of <tt class="literal">any</tt> is "true" if any true result is obtained. The result is "false" if no true result is found (including the special case where the subquery returns no rows). 
			</p><p>
				The <span class="emphasis"><em>operator</em></span> can be any of the following values: <tt class="literal">=, !=, &lt;&gt;, &lt;, &lt;=, &gt;, &gt;=</tt>.
			</p><p>
				The <tt class="literal">some</tt> keyword is a synonym for <tt class="literal">any</tt>. The <tt class="literal">in</tt> construct is equivalent to <tt class="literal">= any</tt>.
			</p><p>
				The right-hand side subquery must return exactly one column.
			</p><p>
				The next statement demonstrates the use of the <tt class="literal">any</tt> subquery condition: 
			</p><pre class="programlisting">select * from ProductOrder as ord
  where quantity &lt; any
    (select minimumQuantity from MinimumQuantity.win:keepall())</pre><p>
				The above query compares ProductOrder event's quantity value with all rows from the MinimumQuantity stream of events and returns only those ProductOrder events that have a quantity that is less then any of the minimum quantity values of the MinimumQuantity events.
			</p><p>
				Note that if there are no successes and at least one right-hand row yields null for the operator's result, the result of the <tt class="literal">any</tt> construct will be null, not false. This is in accordance with SQL's normal rules for Boolean combinations of null values. 
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="epl-subqueries-all"></a>4.14.4.&nbsp;The '<tt class="literal">all</tt>' Keyword</h3></div></div><div></div></div><p>
				The <tt class="literal">all</tt> subquery condition is true if the expression returns true for all of the values returned by the subquery.
			</p><p>
				The synopsis for the <tt class="literal">all</tt> keyword is as follows:
			</p><pre class="synopsis"><span class="emphasis"><em>expression</em></span> <span class="emphasis"><em>operator</em></span> all (<span class="emphasis"><em>subquery</em></span>)</pre><p>
				The left-hand expression is evaluated and compared to each row of the subquery result using the given operator, which must yield a Boolean result. The result of <tt class="literal">all</tt> is "true" if all rows yield true (including the special case where the subquery returns no rows). The result is "false" if any false result is found. The result is <tt class="literal">null</tt> if the comparison does not return false for any row, and it returns <tt class="literal">null</tt> for at least one row.
			</p><p>
				The <span class="emphasis"><em>operator</em></span> can be any of the following values: <tt class="literal">=, !=, &lt;&gt;, &lt;, &lt;=, &gt;, &gt;=</tt>.
			</p><p>
				The <tt class="literal">not in</tt> construct is equivalent to <tt class="literal">!= all</tt>.
			</p><p>
				The right-hand side subquery must return exactly one column.
			</p><p>
				The next statement demonstrates the use of the <tt class="literal">all</tt> subquery condition: 
			</p><pre class="programlisting">select * from ProductOrder as ord
  where quantity &lt; all
    (select minimumQuantity from MinimumQuantity.win:keepall())</pre><p>
				The above query compares ProductOrder event's quantity value with all rows from the MinimumQuantity stream of events and returns only those ProductOrder events that have a quantity that is less then all of the minimum quantity values of the MinimumQuantity events.
			</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="histdata_overview"></a>4.15.&nbsp;Accessing Relational Data via SQL</h2></div></div><div></div></div><a class="indexterm" name="d0e6190"></a><a class="indexterm" name="d0e6193"></a><a class="indexterm" name="d0e6198"></a><a class="indexterm" name="d0e6201"></a><p>
			This chapter outlines how reference data and historical data that are stored in a relational database can be queried via SQL within EPL statements. 
		</p><p>
			Esper can access via join and outer join as well as via iterator (poll) API all types of event streams to stored data. In order for such data sources to become accessible to Esper, some configuration is required. The <a href="#config-database-ref" title="10.4.8.&nbsp;Relational Database Access">Section&nbsp;10.4.8, &#8220;Relational Database Access&#8221;</a> explains the required configuration for database access in greater detail, and includes information on configuring a query result cache.
		</p><p>
			Esper does not parse of otherwise inspect your SQL query. Therefore your SQL can make use of any database-specific SQL language extensions or features that your database provides.
		</p><p>
			If you have enabled query result caching in your Esper database configuration, Esper retains SQL query results in cache following the configured cache eviction policy. 
		</p><p>
			Also if you have enabled query result caching in your Esper database configuration and provide EPL <tt class="literal">where</tt> clause and/or <tt class="literal">on</tt> clause (outer join) expressions, then 
			Esper builds indexes on the SQL query results to enable fast lookup. This is especially useful if your queries return a large number of rows. For building the proper indexes, Esper inspects the expression found in your EPL query <tt class="literal">where</tt> clause, if present. For outer joins, Esper also inspects your EPL query <tt class="literal">on</tt> clause. Esper analyzes the EPL <tt class="literal">on</tt> clause and <tt class="literal">where</tt> clause expressions, if present, looking for property comparison with or without logical AND-relationships between properties. When a SQL query returns rows for caching, Esper builds the appropriate index and lookup strategies for fast row matching against indexes.
		</p><p>
			Joins or outer joins in which only SQL statements or method invocations are listed in the <tt class="literal">from</tt> clause and no other event streams are termed <span class="emphasis"><em>passive</em></span> joins. A passive join does not produce an insert or remove stream and therefore does not invoke statement listeners with results. A passive join can be iterated on (polled) using a statement's <tt class="literal">safeIterator</tt> and <tt class="literal">iterator</tt> methods.
		</p><p>
			There are no restrictions to the number of SQL statements or types of streams joined. The following restrictions currently apply:
		</p><div class="itemizedlist"><ul type="disc" compact><li><p>
					Sub-views on an SQL query are not allowed; That is, one cannot create a time or length window on an SQL query. However one can use the <tt class="literal">insert into</tt> syntax to make join results available to a further statement.
				</p></li><li><p>
					Your database software must support JDBC prepared statements that provide statement meta data at compilation time. Most major databases provide this function. A workaround is available for databases that do not provide this function.
				</p></li><li><p>
					JDBC drivers must support the getMetadata feature. A workaround is available as below for JDBC drivers that don't support getting metadata.
				</p></li></ul></div><p>
			The next sections assume basic knowledge of SQL (Structured Query Language).
		</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="histdata_join"></a>4.15.1.&nbsp;Joining SQL Query Results</h3></div></div><div></div></div><p>
				To join an event stream against stored data, specify the <tt class="literal">sql</tt> keyword followed by the name of the database and a parameterized SQL query. The syntax to use in the <tt class="literal">from</tt> clause of an EPL statement is:
			</p><pre class="synopsis">sql:<span class="emphasis"><em>database_name</em></span> [" <span class="emphasis"><em>parameterized_sql_query</em></span> "]</pre><p>
				The engine uses the <span class="emphasis"><em>database_name</em></span> identifier to obtain configuration information in order to establish a database connection, as well as settings that control connection creation and removal. Please see <a href="#config-database-ref" title="10.4.8.&nbsp;Relational Database Access">Section&nbsp;10.4.8, &#8220;Relational Database Access&#8221;</a> to configure an engine for database access.
			</p><p>
				Following the database name is the SQL query to execute. The SQL query can contain one or more substitution parameters. The SQL query string is placed in single brackets <tt class="literal">[</tt> and <tt class="literal">]</tt>. The SQL query can be placed in either single quotes (') or double quotes ("). The SQL query grammer is passed to your database software unchanged, allowing you to write any SQL query syntax that your database understands, including stored procedure calls.
			</p><p>
				Substitution parameters in the SQL query string take the form <tt class="literal">${</tt><span class="emphasis"><em>event_property_name</em></span><tt class="literal">}</tt>. The engine resolves <span class="emphasis"><em>event_property_name</em></span> at statement execution time to the actual event property value supplied by the events in the joined event stream.
			</p><p>
				The engine determines the type of the SQL query output columns by means of the result set metadata that your database software returns for the statement. The actual 
				query results are obtained via the <tt class="literal">getObject</tt> on <tt class="literal">java.sql.ResultSet</tt>.
			</p><p>
				The sample EPL statement below joins an event stream consisting of <tt class="literal">CustomerCallEvent</tt> events with the results of an SQL query against the database named <tt class="literal">MyCustomerDB</tt> and table <tt class="literal">Customer</tt>: 
			</p><pre class="programlisting">select custId, cust_name from CustomerCallEvent,
  sql:MyCustomerDB [' select cust_name from Customer where cust_id = ${custId} ']</pre><p>
				The example above assumes that <tt class="literal">CustomerCallEvent</tt> supplies an event property named <tt class="literal">custId</tt>. The SQL query selects the customer name from the Customer table. The <tt class="literal">where</tt> clause in the SQL matches the Customer table column <tt class="literal">cust_id</tt> with the value of <tt class="literal">custId</tt> in each <tt class="literal">CustomerCallEvent</tt> event. The engine executes the SQL query for each new <tt class="literal">CustomerCallEvent</tt> encountered.
			</p><p>
				If the SQL query returns no rows for a given customer id, the engine generates no output event. Else the engine generates one output event for each row returned by the SQL query. An outer join as described in the next section can be used to control whether the engine should generate output events even when the SQL query returns no rows.
			</p><p>
				The next example adds a time window of 30 seconds to the event stream <tt class="literal">CustomerCallEvent</tt>. It also renames the selected properties to customerName and customerId to demonstrate how the naming of columns in an SQL query can be used in the <tt class="literal">select</tt> clause in the EPL query. And the example uses explicit stream names via the <tt class="literal">as</tt> keyword.
			</p><pre class="programlisting">select customerId, customerName from
  CustomerCallEvent.win:time(30 sec) as cce,
  sql:MyCustomerDB ["select cust_id as customerId, cust_name as customerName from Customer 
                  where cust_id = ${cce.custId}"] as cq</pre><p>
				Any window, such as the time window, generates insert stream (istream) events as events enter the window, and remove stream (rstream) events as events leave the window. The engine executes the given SQL query for each <tt class="literal">CustomerCallEvent</tt> in both the insert stream and the remove stream. As a performance optimization, the <tt class="literal">istream</tt> or <tt class="literal">rstream</tt> keywords in the <tt class="literal">select</tt> clause can be used to instruct the engine to only join insert stream or remove stream events, reducing the number of SQL query executions.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="histdata_join_where"></a>4.15.2.&nbsp;SQL Query and the EPL <tt class="literal">Where</tt> Clause</h3></div></div><div></div></div><p>
				Consider using the EPL <tt class="literal">where</tt> clause to join the SQL query result to your event stream. Similar to EPL joins and outer-joins that join event streams or patterns, the EPL <tt class="literal">where</tt> clause provides join criteria between the SQL query results and the event stream (as a side note, an SQL <tt class="literal">where</tt> clause is a filter of rows executed by your database on your database server before returning SQL query results).
			</p><p>
				Esper analyzes the expression in the EPL <tt class="literal">where</tt> clause and outer-join <tt class="literal">on</tt> clause, if present, and builds the appropriate indexes from that information at runtime, to ensure fast matching of event stream events to SQL query results, even if your SQL query returns a large number of rows. Your applications must ensure to configure a cache for your database using Esper configuration, as such indexes are held with regular data in a cache. If you application does not enable caching of SQL query results, the engine does not build indexes on cached data.
			</p><p>
				The sample EPL statement below joins an event stream consisting of <tt class="literal">OrderEvent</tt> events with the results of an SQL query against the database named <tt class="literal">MyRefDB</tt> and table <tt class="literal">SymbolReference</tt>: 
			</p><pre class="programlisting">select symbol, symbolDesc from OrderEvent as orders,
  sql:MyRefDB ['select symbolDesc from SymbolReference'] as reference
  where reference.symbol = orders.symbol</pre><p>
				Notice how the EPL <tt class="literal">where</tt> clause joins the <tt class="literal">OrderEvent</tt> stream to the <tt class="literal">SymbolReference</tt> table. In this example, the SQL query itself does not have a SQL <tt class="literal">where</tt> clause 
				and therefore returns all rows from table <tt class="literal">SymbolReference</tt>.
			</p><p>
				If your application enables caching, the SQL query fires only at the arrival of the first <tt class="literal">OrderEvent</tt> event. When the second <tt class="literal">OrderEvent</tt> arrives, the join execution uses the cached query result. If the caching policy that you specified in the Esper database configuration evicts the SQL query result from cache, then the engine fires the SQL query again to obtain a new result and places the result in cache.
			</p><p>
				If SQL result caching is enabled and your EPL <tt class="literal">where</tt> clause, as show in the above example, provides the properties to join, then the engine indexes the SQL query results in cache and retains the index together with the query result in cache. Thus your application can benefit from high performance index-based lookups as long as the SQL query results are found in cache. 
			</p><p>
				The SQL result caches operate on the level of all result rows for a given parameter set. For example, if your query returns 10 rows for a certain set of parameter values then the cache treats all 10 rows as a single entry keyed by the parameter values, and the expiry policy applies to all 10 rows and not to each individual row.
			</p><p>
				It is also possible to join multiple autonomous database systems in a single query, for example:
			</p><pre class="programlisting">select symbol, symbolDesc from OrderEvent as orders,
  sql:My_Oracle_DB ['select symbolDesc from SymbolReference'] as reference,
  sql:My_MySQL_DB ['select orderList from orderHistory'] as history
  where reference.symbol = orders.symbol
  and history.symbol = orders.symbol </pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="histdata_outerjoin"></a>4.15.3.&nbsp;Outer Joins With SQL Queries</h3></div></div><div></div></div><p>
				You can use outer joins to join data obtained from an SQL query and control when an event is produced. Use a left outer join, such as in the next statement, if you need an output event for each event regardless of whether or not the SQL query returns rows. If the SQL query returns no rows, the join result populates null values into the selected properties.
			</p><pre class="programlisting">select custId, custName from
  CustomerCallEvent as cce
  left outer join 
  sql:MyCustomerDB ["select cust_id, cust_name as custName 
                     from Customer where cust_id = ${cce.custId}"] as cq
  on cce.custId = cq.cust_id</pre><p>
				The statement above always generates at least one output event for each <tt class="literal">CustomerCallEvent</tt>, containing all columns selected by the SQL query, even if the SQL query does not return any rows. Note the <tt class="literal">on</tt> expression that is required for outer joins. The <tt class="literal">on</tt> acts as an additional filter to rows returned by the SQL query.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="histdata_polling_pattern"></a>4.15.4.&nbsp;Using Patterns to Request (Poll) Data</h3></div></div><div></div></div><p>
				Pattern statements and SQL queries can also be applied together in useful ways. One such use is to poll or request data from a database at regular intervals or following the schedule of the crontab-like <tt class="literal">timer:at</tt>.
			</p><p>
				The next statement is an example that shows a pattern that fires every 5 seconds to query the NewOrder table for new orders:
			</p><pre class="programlisting">insert into NewOrders
select orderId, orderAmount from
  pattern [every timer:interval(5 sec)],
  sql:MyCustomerDB ['select orderId, orderAmount from NewOrders']</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="histdata_polling"></a>4.15.5.&nbsp;Polling SQL Queries via Iterator</h3></div></div><div></div></div><p>
				Usually your SQL query will take part in a join and thus be triggered by an event or pattern occurrence. Instead, your application may need to poll a SQL query and thus use Esper query execution and caching facilities and obtain event data and metadata.
			</p><p>
				Your EPL statement can specify an SQL statement without a join. Such a stand-alone SQL statement does not post new events, and may only be queried via the <tt class="literal">iterator</tt> poll API. Your EPL and SQL statement may still use variables.
			</p><p>
				The next statement assumes that a <tt class="literal">price_var</tt> variable has been declared. It selects from the relational database table named <tt class="literal">NewOrder</tt> all rows in which the <tt class="literal">price</tt> column is greater 
				then the current value of the <tt class="literal">price_var</tt> EPL variable:
			</p><pre class="programlisting">select * from sql:MyCustomerDB ['select * from NewOrder where ${price_var} &gt; price']</pre><p>
				Use the <tt class="literal">iterator</tt> and <tt class="literal">safeIterator</tt> methods on <tt class="literal">EPStatement</tt> to obtain results. The statement does not post events to listeners, it is strictly passive in that sense.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="histdata_implementation"></a>4.15.6.&nbsp;JDBC Implementation Overview</h3></div></div><div></div></div><p>
				The engine translates SQL queries into JDBC <tt class="literal">java.sql.PreparedStatement</tt> statements by replacing ${name} parameters with '?' placeholders. It obtains name and type of result columns from the compiled <tt class="literal">PreparedStatement</tt> meta data when the EPL statement is created.
			</p><p>
				The engine supplies parameters to the compiled statement via the <tt class="literal">setObject</tt> method on <tt class="literal">PreparedStatement</tt>. The engine uses the <tt class="literal">getObject</tt> method on the compiled statement <tt class="literal">PreparedStatement</tt> to obtain column values.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="histdata_nometadata"></a>4.15.7.&nbsp;Oracle Drivers and No-Metadata Workaround</h3></div></div><div></div></div><p>
			   Certain JDBC database drivers are known to not return metadata for precompiled prepared SQL statements. This can be a problem as metadata is required by Esper. Esper obtains SQL result set metadata to validate an EPL statement and to provide column types for output events. JDBC drivers that do not provide metadata for precompiled SQL statements require a workaround. Such drivers do generally provide metadata for executed SQL statements, however do not provide the metadata for precompiled SQL statements.
			</p><p>
				Please consult the <a href="#configuration" title="Chapter&nbsp;10.&nbsp;Configuration">Chapter&nbsp;10, <i>Configuration</i></a> for the configuration options available in relation to metadata retrieval.
			</p><p>
				To obtain metadata for an SQL statement, Esper can alternatively fire a SQL statement which returns the same column names and types as the actual SQL statement but without returning any rows. This kind of SQL statement is referred to as a <span class="emphasis"><em>sample</em></span> statement in below workaround description. The engine can then use the sample SQL statement to retrieve metadata for the column names and types returned by the actual SQL statement.
			</p><p>
				Applications can provide a sample SQL statement to retrieve metadata via the <tt class="literal">metadatasql</tt> keyword:
			</p><pre class="synopsis">sql:<span class="emphasis"><em>database_name</em></span> ["<span class="emphasis"><em>parameterized_sql_query</em></span>" metadatasql "<span class="emphasis"><em>sql_meta_query</em></span>"] </pre><p>
				The <span class="emphasis"><em>sql_meta_query</em></span> must be an SQL statement that returns the same number of columns, the same type of columns and the same column names as the 
				<span class="emphasis"><em>parameterized_sql_query</em></span>, and does not return any rows.
			</p><p>
				Alternatively, applications can choose not to provide an explicit sample SQL statement. If the EPL statement does not use the <tt class="literal">metadatasql</tt> syntax, the engine applies lexical analysis to the SQL statement. From the lexical analysis Esper generates a sample SQL statement adding a restrictive clause "where 1=0"  to the SQL statement.
			</p><p>
				Alternatively, you can add the following tag to the SQL statement: <tt class="literal">${$ESPER-SAMPLE-WHERE}</tt>. If the tag  exists in the SQL statement, the engine does not perform lexical analysis and simply replaces the 
				tag with the SQL <tt class="literal">where</tt> clause "where 1=0". Therefore this workaround is applicable to SQL statements that cannot be correctly lexically analyzed. The SQL text after the placeholder is not part of the sample query. For example:
			</p><pre class="programlisting">select mycol from sql:myDB [
  'select mycol from mytesttable ${$ESPER-SAMPLE-WHERE} where ....'], ...</pre><p>
				If your <span class="emphasis"><em>parameterized_sql_query</em></span> SQL query contains vendor-specific SQL syntax, generation of the metadata query may fail to produce a valid SQL statement. If you experience an SQL error while fetching metadata, use any of the above workarounds with the Oracle JDBC driver. 
			</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="joining_method"></a>4.16.&nbsp;Accessing Non-Relational Data via Method Invocation</h2></div></div><div></div></div><a class="indexterm" name="d0e6613"></a><a class="indexterm" name="d0e6618"></a><p>
			Your application may need to join data that originates from a web service, a distributed cache, an object-oriented database or simply data held in memory by your application. Esper accommodates this need by allowing
			a method invocation (or procedure call or function) in the <tt class="literal">from</tt> clause of a statement. 
		</p><p>
			The results of such a method invocation in the <tt class="literal">from</tt> clause plays the same role as a relational database table in an inner and outer join in SQL. The role is thus dissimilar to the role of a user-defined function, which may occur in any expression such as in the <tt class="literal">select</tt> clause or the <tt class="literal">where</tt> clause. Both are backed by one or more static methods provided by your class library.
		</p><p>
			Esper can join and outer join an unlimited number and all types of event streams to the data returned by your method invocation. In addition, Esper can be configured to cache the data returned by your method invocations.
		</p><p>
			Joins or outer joins in which only SQL statements or method invocations are listed in the <tt class="literal">from</tt> clause and no other event streams are termed <span class="emphasis"><em>passive</em></span> joins. A passive join does not produce an insert or remove stream and therefore does not invoke statement listeners with results. A passive join can be iterated on (polled) using a statement's <tt class="literal">safeIterator</tt> and <tt class="literal">iterator</tt> methods.
		</p><p>
			The following restrictions currently apply:
		</p><div class="itemizedlist"><ul type="disc" compact><li><p>
					Sub-views on a method invocations are not allowed; That is, one cannot create a time or length window on a method invocation. However one can use the <tt class="literal">insert into</tt> syntax to make join results available to a further statement.
				</p></li></ul></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="joining_method_syntax"></a>4.16.1.&nbsp;Joining Method Invocation Results</h3></div></div><div></div></div><p>
				The syntax for a method invocation in the <tt class="literal">from</tt> clause of an EPL statement is:
			</p><pre class="synopsis">method:<span class="emphasis"><em>class_name</em></span>.<span class="emphasis"><em>method_name</em></span>[(<span class="emphasis"><em>parameter_expressions</em></span>)]</pre><p>
				The <tt class="literal">method</tt> keyword denotes a method invocation. It is followed by a class name and a method name separated by a dot (.) character. If you have parameters to your method invocation, these are placed in 
				round brackets after the method name. Any expression is allowed as a parameter, and individual parameter expressions are separated by a comma. Expressions may also use event properties of the joined stream. 
			</p><p>
				In the sample join statement shown next, the method 'lookupAsset' provided by class 'MyLookupLib' returns one or more rows based on the asset id (a property of the AssetMoveEvent) that is passed to the method:
			</p><pre class="programlisting">select * from AssetMoveEvent, method:MyLookupLib.lookupAsset(assetId)</pre><p>
				The following statement demonstrates the use of the <tt class="literal">where</tt> clause to join events to the rows returned by a method invocation, which in this example does not take parameters:
			</p><pre class="programlisting">select assetId, assetDesc from AssetMoveEvent as asset, 
       method:MyLookupLib.getAssetDescriptions() as desc 
where asset.assetid = desc.assetid</pre><p>
				Your method invocation may return zero, one or many rows for each method invocation. If you have caching enabled through configuration, then Esper can avoid the method invocation and instead use cached results. Similar to SQL joins, Esper also indexes cached result rows such that join operations based on the <tt class="literal">where</tt> clause or outer-join <tt class="literal">on</tt> clause can be very efficient, especially if your method invocation returns a large number of rows.
			</p><p>
				If the time taken by method invocations is critical to your application, you may configure local caches as <a href="#config-method-invocations" title="10.4.6.&nbsp;Cache Settings for From-Clause Method Invocations">Section&nbsp;10.4.6, &#8220;Cache Settings for From-Clause Method Invocations&#8221;</a> describes.
			</p><p>
				Esper analyzes the expression in the EPL <tt class="literal">where</tt> clause and outer-join <tt class="literal">on</tt> clause, if present, and builds the appropriate indexes from that information at runtime, to ensure fast matching of event stream events to method invocation results, even if your method invocation returns a large number of rows. Your applications must ensure to configure a cache for your method invocation using Esper configuration, as such indexes are held with regular data in a cache. If you application does not enable caching of method invocation results, the engine does not build indexes on cached data.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="joining_method_polling"></a>4.16.2.&nbsp;Polling Method Invocation Results via Iterator</h3></div></div><div></div></div><p>
				Usually your method invocation will take part in a join and thus be triggered by an event or pattern occurrence. Instead, your application may need to poll a method invocation and thus use Esper query execution and caching facilities and obtain event data and metadata.
			</p><p>
				Your EPL statement can specify a method invocation in the <tt class="literal">from</tt> clause without a join. Such a stand-alone method invocation does not post new events, and may only be queried via the <tt class="literal">iterator</tt> poll API. Your EPL statement may still use variables.
			</p><p>
				The next statement assumes that a <tt class="literal">category_var</tt> variable has been declared. It polls the <tt class="literal">getAssetDescriptions</tt> method passing the current value of the <tt class="literal">category_var</tt> EPL variable:
			</p><pre class="programlisting">select * from method:MyLookupLib.getAssetDescriptions(category_var)]</pre><p>
				Use the <tt class="literal">iterator</tt> and <tt class="literal">safeIterator</tt> methods on <tt class="literal">EPStatement</tt> to obtain results. The statement does not post events to listeners, it is strictly passive in that sense.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="joining_method_exposing"></a>4.16.3.&nbsp;Providing the Method</h3></div></div><div></div></div><p>
				Your application must provide a Java class that exposes a public static method. The method must accept the same number and type of parameters as listed in the parameter expression list. 
			</p><p>
				If your method invocation returns either no row or only one row, then the return type of the method can be a Java class or a <tt class="literal">java.util.Map</tt>. If your method invocation can return more then one row, then the return type of the method must be an array of Java class or an array of <tt class="literal">Map</tt>.
			</p><p>
				If you are using a Java class or an array of Java class as the return type, then the class must adhere to JavaBean conventions: it must expose properties through getter methods.
			</p><p>
				If you are using <tt class="literal">java.util.Map</tt> as the return type or an array of <tt class="literal">Map</tt>, then the map should have <tt class="literal">String</tt>-type keys and object values (<tt class="literal">Map&lt;String, Object&gt;</tt>). When using <tt class="literal">Map</tt> as the return type, your application must provide a second method that returns property metadata, as the next section outlines.
			</p><p>
				Your application method must return either of the following:
			</p><div class="orderedlist"><ol type="1"><li><p>
						A <tt class="literal">null</tt> value or an empty array to indicate an empty result (no rows).
					</p></li><li><p>
						A Java object or <tt class="literal">Map</tt> to indicate a one-row result, or an array that consists of a single Java object or <tt class="literal">Map</tt>.
					</p></li><li><p>
						An array of Java objects or <tt class="literal">Map</tt> instances to return multiple result rows.
					</p></li></ol></div><p>
				As an example, consider the method 'getAssetDescriptions' provided by class 'MyLookupLib' as discussed earlier:
			</p><pre class="programlisting">select assetId, assetDesc from AssetMoveEvent as asset,
       method:com.mypackage.MyLookupLib.getAssetDescriptions() as desc 
  where asset.assetid = desc.assetid</pre><p>
				The 'getAssetDescriptions' method may return multiple rows and is therefore declared to return an array of the class 'AssetDesc'. The class AssetDesc is a POJO class (not shown here):
			</p><pre class="programlisting">public class MyLookupLib {
  ...
  public static AssetDesc[] getAssetDescriptions() {
    ...
    return new AssetDesc[] {...};
  }</pre><p>
				The example above specifies the full Java class name of the class 'MyLookupLib' class in the EPL statement. The package name does not need to be part of the EPL if your application imports the package using the auto-import configuration through the API or XML, as outlined in <a href="#config-class--package-imports" title="10.4.5.&nbsp;Class and package imports">Section&nbsp;10.4.5, &#8220;Class and package imports&#8221;</a>.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="joining_method_map"></a>4.16.4.&nbsp;Using a <tt class="literal">Map</tt> Return Type</h3></div></div><div></div></div><p>
				Your application may return <tt class="literal">java.util.Map</tt> or an array of <tt class="literal">Map</tt> from method invocations. If doing so, your application must provide metadata about each row: it must declare the property name and property type of each <tt class="literal">Map</tt> entry of a row. This information allows the engine to perform type checking of expressions used within the statement.
			</p><p>
				You declare the property names and types of each row by providing a method that returns property metadata. The metadata method must follow these conventions:
			</p><div class="orderedlist"><ol type="1"><li><p>
						The method name providing the property metadata must have same method name appended by the literal <tt class="literal">Metadata</tt>.
					</p></li><li><p>
						The method must have an empty parameter list and must be declared public and static.
					</p></li><li><p>
						The method providing the metadata must return a <tt class="literal">Map</tt> of <tt class="literal">String</tt> property name keys and <tt class="literal">java.lang.Class</tt> property name types (<tt class="literal">Map&lt;String, Class&gt;</tt>).
					</p></li></ol></div><p>
				In the following example, a class 'MyLookupLib' provides a method to return historical data based on asset id and asset code:
			</p><pre class="programlisting">select assetId, location, x_coord, y_coord from AssetMoveEvent as asset,
       method:com.mypackage.MyLookupLib.getAssetHistory(assetId, assetCode) as history</pre><p>
				A sample implementation of the class 'MyLookupLib' is shown below. 
			</p><pre class="programlisting">public class MyLookupLib {
  ...
  // For each column in a row, provide the property name and type
  //
  public static Map&lt;String, Class&gt; getAssetHistoryMetadata() {
    Map&lt;String, Class&gt; propertyNames = new HashMap&lt;String, Class&gt;();
    propertyNames.put("location", String.class);
    propertyNames.put("x_coord", Integer.class);
    propertyNames.put("y_coord", Integer.class);
    return propertyNames;
  }
... 
  // Lookup rows based on assetId and assetCode
  // 
  public static Map&lt;String, Object&gt;[] getAssetHistory(String assetId, String assetCode) {
    Map rows = new Map[2];	// this sample returns 2 rows
    for (int i = 0; i &lt; 2; i++) {
      rows[i] = new HashMap();
      rows[i].put("location", "somevalue");
      rows[i].put("x_coord", 100);
      // ... set more values for each row
    }
    return rows;
  }</pre><p>
				In the example above, the 'getAssetHistoryMetadata' method provides the property metadata: the names and types of properties in each row.  The engine calls this method once per statement to determine event typing information.
			</p><p>
				The 'getAssetHistory' method returns an array of <tt class="literal">Map</tt> objects that are two rows. The implementation shown above is a simple example. The parameters to the method are the assetId and assetCode properties of the AssetMoveEvent joined to the method. The engine calls this method for each insert and remove stream event in AssetMoveEvent.
			</p><p>
				To indicate that no rows are found in a join, your application method may return either a <tt class="literal">null</tt> value or an array of size zero.
			</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="named_overview"></a>4.17.&nbsp;Creating and Using Named Windows</h2></div></div><div></div></div><a class="indexterm" name="d0e6891"></a><a class="indexterm" name="d0e6894"></a><p>
			A <span class="emphasis"><em>named window</em></span> is a global data window that can take part in many statement queries, and that can be inserted-into and deleted-from by multiple statements. A named window holds events of the same type or supertype, unless used with a variant stream. 
		</p><p>
			The <tt class="literal">create window</tt> clause declares a new named window. The named window starts up empty unless populated from an existing named window at time of creation. Events must be inserted into the named window using the <tt class="literal">insert into</tt> clause. Events can also be deleted from a named window via the <tt class="literal">on delete</tt> clause. 
		</p><p>
			Events enter the named window by means of <tt class="literal">insert into</tt> clause of a <tt class="literal">select</tt> statement. Events leave a named window either because the expiry policy of the declared data window removes events from the named window, or through statements that use the <tt class="literal">on delete</tt> clause to explicitly delete from a named window.
		</p><p>
			To query a named window, simply use the window name in the <tt class="literal">from</tt> clause of your statement, including statements that contain subqueries, joins and outer-joins.
		</p><p>
			A named window may also decorate an event to preserve original events as described in <a href="#insert-into-decorated" title="4.10.4.&nbsp;Decorated Events">Section&nbsp;4.10.4, &#8220;Decorated Events&#8221;</a> and <a href="#named-insertinto-decorated" title="4.17.3.1.&nbsp;Named Windows Holding Decorated Events">Section&nbsp;4.17.3.1, &#8220;Named Windows Holding Decorated Events&#8221;</a>.
			In addition, columns of a named window are allowed to hold events themselves, as further explained in <a href="#insert-into-eventasproperty" title="4.10.5.&nbsp;Event as a Property">Section&nbsp;4.10.5, &#8220;Event as a Property&#8221;</a> and <a href="#named-insertinto-eventasproperty" title="4.17.3.2.&nbsp;Named Windows Holding Events As Property">Section&nbsp;4.17.3.2, &#8220;Named Windows Holding Events As Property&#8221;</a>.
		</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="named_create"></a>4.17.1.&nbsp;Creating Named Windows: the <tt class="literal">Create Window</tt> clause</h3></div></div><div></div></div><p>
				The <tt class="literal">create window</tt> statement creates a named window by specifying a window name and one or more data window views, as well as the type of event to hold in the named window.
			</p><p>
				There are two syntaxes for creating a named window: The first syntax allows to model a named window after an existing event type or an existing named window. The second syntax is similar to the SQL create-table syntax and provides a list of column names and column types. 
			</p><p>
				A new named window starts up empty. It must be explicitly inserted into by one or more statements, as discussed below. A named window can also be populated at time of creation from an existing named window.
			</p><p>
				If your application stops or destroys the statement that creates the named window, any consuming statements no longer receive insert or remove stream events. The named window can also not be deleted from after it was stopped or destroyed.
			</p><p>
				The <tt class="literal">create window</tt> statement posts to listeners any events that are inserted into the named window as new data. The statement posts all deleted events or events that expire out of the data window to listeners as the remove stream (old data). The named window contents can also be iterated on via the pull API to obtain the current contents of a named window.
			</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="named_create_modelafter"></a>4.17.1.1.&nbsp;Creation by Modelling after an Existing Type</h4></div></div><div></div></div><p>
					The benefit of modelling a named window after an existing event type is that event properties can be nested, indexed, mapped or other types that your event objects may provide as properties, including the type of the underlying event itself. Also, using the wildcard (*) operator means your EPL does not need to list each individual property explicitly.
				</p><p>
					The syntax for creating a named window by modelling the named window after an existing event type, is as follows: 
				</p><pre class="synopsis">create window <span class="emphasis"><em>window_name</em></span>.<span class="emphasis"><em>view_specifications</em></span> 
    [as] [select <span class="emphasis"><em>list_of_properties</em></span> from] <span class="emphasis"><em>event_type_or_windowname</em></span>
    [insert [where <span class="emphasis"><em>filter_expression</em></span>]]</pre><p>
					The <span class="emphasis"><em>window_name</em></span> you assign to the named window can be any identifier. The name should not already be in use as an event type or stream name.
				</p><p>
					The <span class="emphasis"><em>view_specifications</em></span> are one or more data window views that define the expiry policy for removing events from the data window. Named windows must explicitly declare a data window view. This is required to ensure that the policy for retaining events in the data window is well defined. To keep all events, use the keep-all view: It indicates that the named window should keep all events and only remove events from the named window that are deleted via the <tt class="literal">on delete</tt> clause. The view specification can only list data window views, derived-value views are not allowed since these don't represent an expiry policy. Data window views are listed in <a href="#epl-views" title="Chapter&nbsp;8.&nbsp;EPL Reference: Views">Chapter&nbsp;8, <i>EPL Reference: Views</i></a>. View parameterization and staggering are described in <a href="#epl-from-clause-view-spec" title="4.4.3.&nbsp;Specifying Views">Section&nbsp;4.4.3, &#8220;Specifying Views&#8221;</a>.
				</p><p>				
					The <tt class="literal">select</tt> clause and <span class="emphasis"><em>list_of_properties</em></span> are optional. If present, they specify the column names and, implicitly by definition of the event type, the column types of events held by the named window. Expressions other then column names are not allowed in the <tt class="literal">select</tt> list of properties. Wildcards (*) and wildcards with additional properties can also be used.
				</p><p>				
					The <span class="emphasis"><em>event_type_or_windowname</em></span> is required if using the model-after syntax. It provides the name of the event type of events held in the data window, unless column names and types have been explicitly selected via <tt class="literal">select</tt>. The name of an (existing) other named window is also allowed here. Please find more details in <a href="#named_populate_named" title="4.17.7.&nbsp;Populating a Named Window from an Existing Named Window">Section&nbsp;4.17.7, &#8220;Populating a Named Window from an Existing Named Window&#8221;</a>.
				</p><p>				
					Finally, the <tt class="literal">insert</tt> clause and optional <span class="emphasis"><em>filter_expression</em></span> are used if the new named windows is modelled after an existing named window, and the data of the existing named window is to be populated, upon time of creation of the new window, from the existing named window. The optional <span class="emphasis"><em>filter_expression</em></span> can be used to exclude events.
				</p><p>
					The next statement creates a named window 'AllOrdersNamedWindow' for which the expiry policy is simply to keep all events. Assume that the event type 'OrderMapEventType' has been configured. The named window is to hold events of type 'OrderMapEventType':
				</p><pre class="programlisting">create window AllOrdersNamedWindow.win:keepall() as OrderMapEventType</pre><p>
					The below sample statement demonstrates the <tt class="literal">select</tt> syntax. It defines a named window in which each row has the three properties 'symbol', 'volume' and 'price'. This named window actively removes events from the window that are older then 30 seconds.
				</p><pre class="programlisting">create window OrdersTimeWindow.win:time(30 sec) as 
  select symbol, volume, price from OrderEvent</pre><p>
					In an alternate form, the <tt class="literal">as</tt> keyword can be used to rename columns, and constants may occur in the select clause as well:
				</p><pre class="programlisting">create window OrdersTimeWindow.win:time(30 sec) as 
  select symbol as sym, volume as vol, price, 1 as alertId from OrderEvent</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="named_create_explicit"></a>4.17.1.2.&nbsp;Creation By Defining Columns Names and Types</h4></div></div><div></div></div><p>
					The second syntax for creating a named window is by supplying column names and types: 
				</p><pre class="synopsis">create window <span class="emphasis"><em>window_name</em></span>.<span class="emphasis"><em>view_specifications</em></span> [as] (<span class="emphasis"><em>column_name</em></span> <span class="emphasis"><em>column_type</em></span> 
  [,<span class="emphasis"><em>column_name</em></span> <span class="emphasis"><em>column_type</em></span> [,...])</pre><p>				
					The <span class="emphasis"><em>column_name</em></span> is an identifier providing the event property name. The <span class="emphasis"><em>column_type</em></span> is also required for each column. Valid column types are listed in <a href="#variable_create" title="4.19.1.&nbsp;Creating Variables: the Create Variable clause">Section&nbsp;4.19.1, &#8220;Creating Variables: the Create Variable clause&#8221;</a>
					and are the same as for variable types.
				</p><p>
					The next statement creates a named window:
				</p><pre class="programlisting">create window SecurityEvent.win:time(30 sec) 
    (ipAddress string, userId String, numAttempts int)</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="named_create_drop"></a>4.17.1.3.&nbsp;Dropping or Removing Named Windows</h4></div></div><div></div></div><p>
					There is no syntax to drop or remove a named window.
				</p><p>
					The <tt class="literal">destroy</tt> method on the <tt class="literal">EPStatement</tt> that created the named window removes the named window. However the implicit event type associated with the named window remains active since further statements may continue to use that type. Therefore a named window of the same name can only be created again if the type information matches the prior declaration for a named window.
				</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="named_delete"></a>4.17.2.&nbsp;Deleting From Named Windows: the <tt class="literal">On Delete</tt> clause</h3></div></div><div></div></div><a class="indexterm" name="d0e7112"></a><a class="indexterm" name="d0e7115"></a><a class="indexterm" name="d0e7120"></a><p>
				An <tt class="literal">on delete</tt> clause removes events from a named window. The clause can be used to remove all events, or only events that match certain criteria, or events that correlate with an arriving event or a pattern of arriving events.
			</p><p>
				The syntax for the <tt class="literal">on delete</tt> clause is as follows: 
			</p><pre class="synopsis">on <span class="emphasis"><em>event_type</em></span>[<span class="emphasis"><em>(filter_criteria)</em></span>] [as <span class="emphasis"><em>stream_name</em></span>]
delete from <span class="emphasis"><em>window_name</em></span> [as <span class="emphasis"><em>stream_name</em></span>]
[where <span class="emphasis"><em>criteria_expression</em></span>]</pre><p>
				The <span class="emphasis"><em>event_type</em></span> is the name of the type of events that trigger removal from the named window. It is optionally followed by <span class="emphasis"><em>filter_criteria</em></span> which are filter expressions to apply to arriving events. The optional <tt class="literal">as</tt> keyword can be used to assign an name for use in the <tt class="literal">where</tt> clause. Patterns and named windows can also be specified in the <tt class="literal">on</tt> clause as described in the next section.
			</p><p>
				The <span class="emphasis"><em>window_name</em></span> is the name of the named window to delete events from. The <tt class="literal">as</tt> keyword is also available to assign a name to the named window.
			</p><p>
				The optional <tt class="literal">where</tt> clause contains a <span class="emphasis"><em>criteria_expression</em></span> that correlates the arriving (triggering) event to the events to be removed from the named window. The <span class="emphasis"><em>criteria_expression</em></span> may also simply filter for events in the named window to be removed from the named window.
			</p><p>
				The <tt class="literal">iterator</tt> of the <tt class="literal">EPStatement</tt> object representing the <tt class="literal">on delete</tt> clause can also be helpful: It returns the last batch of deleted events in response to the last triggering event, in any order, or null if the last triggering event did not remove any rows.
			</p><p>				
				Let's look at a couple of examples. In the simplest form, this statement deletes all events from the named window 'AllOrdersNamedWindow' when any 'FlushOrderEvent' arrives:
			</p><pre class="programlisting">on FlushOrderEvent delete from AllOrdersNamedWindow</pre><p>				
				This example adds a <tt class="literal">where</tt> clause to the example above. Upon arrival of a triggering 'ZeroVolumeEvent', the statement removes from the named window any orders that have a volume of zero or less:
			</p><pre class="programlisting">on ZeroVolumeEvent delete from AllOrdersNamedWindow where volume &lt;= 0</pre><p>				
				The next example shows a more complete use of the syntax, and correlates the triggering event with events held by the named window:
			</p><pre class="programlisting">on NewOrderEvent(volume&gt;0) as myNewOrders
delete from AllOrdersNamedWindow as myNamedWindow 
where myNamedWindow.symbol = myNewOrders.symbol</pre><p>				
				In the above sample statement, only if a 'NewOrderEvent' event with a volume greater then zero arrives does the statement trigger. Upon triggering, all events in the named window that have the same value for the symbol property as the triggering 'NewOrderEvent' event are then removed from the named window. The statement also showcases the <tt class="literal">as</tt> keyword to assign a name for use in the <tt class="literal">where</tt> expression.
			</p><p>				
				For correlated queries (as above) that correlate triggering events with events held by a named window, Esper internally creates efficient indexes to enable high performance removal of events especially from named windows that hold large numbers of events.
			</p><p>
				Your application can subscribe a listener to your <tt class="literal">on delete</tt> statements to determine removed events. The statement post any events that are deleted from a named window to all listeners attached to the statement as new data. Upon iteration, the statement provides the last deleted event, if any.
			</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="named_delete_pattern"></a>4.17.2.1.&nbsp;Using Patterns in the <tt class="literal">On Delete</tt> Clause</h4></div></div><div></div></div><p>
					By means of patterns the <tt class="literal">on delete</tt> clause and <tt class="literal">on select</tt> clause (described below) can look for more complex conditions to occur, possibly involving multiple events or the passing of time. The syntax for <tt class="literal">on delete</tt> with a pattern expression is show next:
				</p><pre class="synopsis">on pattern [<span class="emphasis"><em>pattern_expression</em></span>] [as <span class="emphasis"><em>stream_name</em></span>]
delete from <span class="emphasis"><em>window_name</em></span> [as <span class="emphasis"><em>stream_name</em></span>]
[where <span class="emphasis"><em>criteria_expression</em></span>]</pre><p>
					The <span class="emphasis"><em>pattern_expression</em></span> is any pattern that matches zero or more arriving events. Tags can be used to name events in the pattern and can occur in the optional <tt class="literal">where</tt> clause to correlate to events to be removed from a named window.
				</p><p>
					In the next example the triggering pattern fires every 10 seconds. The effect is that every 10 seconds the statement removes from 'MyNamedWindow' all rows:
				</p><pre class="programlisting">on pattern [every timer:interval(10 sec)] delete from MyNamedWindow</pre><p>
					The following example shows the use of tags in a pattern: 
				</p><pre class="programlisting">on pattern [every ord=OrderEvent(volume&gt;0) or every flush=FlushOrderEvent] 
delete from OrderWindow as win
where ord.id = win.id or flush.id = win.id</pre><p>
					The pattern above looks for OrderEvent events with a volume value greater then zero and tags such events as 'ord'. 
					The pattern also looks for FlushOrderEvent events and tags such events as 'flush'. The <tt class="literal">where</tt> clause deletes from the 'OrderWindow' named window any events that match in the value of the 'id' property either of the arriving events.
				</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="named_inserting"></a>4.17.3.&nbsp;Inserting Into Named Windows</h3></div></div><div></div></div><a class="indexterm" name="d0e7292"></a><a class="indexterm" name="d0e7297"></a><p>
				The <tt class="literal">insert into</tt> clause inserts events into named windows. Your application must ensure that the column names and types match the declared column names and types of the named window to be inserted into.
			</p><p>
				In this example we first create a named window using some of the columns of an OrderEvent event type:
			</p><pre class="programlisting">create window OrdersWindow.win:keepall() as select symbol, volume, price from OrderEvent</pre><p>
				The insert into the named window selects individual columns to be inserted:
			</p><pre class="programlisting">insert into OrdersWindow(symbol, volume, price) select name, count, price from FXOrderEvent
// .. alternative form...
insert into OrdersWindow select name as symbol, vol as volume, price from FXOrderEvent</pre><p>
				Following above statement, the engine enters every FXOrderEvent arriving into the engine into the named window 'OrdersWindow'.
			</p><p>
				The following EPL creates a named window for an event type backed by a Java class, and inserts into the window any 'OrderEvent' where the symbol value is IBM:
			</p><pre class="programlisting">create window OrdersWindow as com.mycompany.OrderEvent
insert into OrdersWindow select * from com.mycompany.OrderEvent(symbol='IBM')</pre><p>
				The last example adds one column named 'derivedPrice' to the 'OrderEvent' type by specifying a wildcard, and uses a user-defined function to populate the column:
			</p><pre class="programlisting">create window OrdersWindow as select *, price as derivedPrice from OrderEvent
insert into OrdersWindow select *, MyFunc.func(price, percent) as derivedPrice from OrderEvent</pre><p>
				Event representations based on Java base classes or interfaces, and subclasses or implementing classes, are compatible as these statements show:
			</p><pre class="programlisting">// create a named window for the base class
create window OrdersWindow as select * from ProductBaseEvent

// The ServiceProductEvent class subclasses the ProductBaseEvent class
insert into OrdersWindow select * from ServiceProductEvent

// The MerchandiseProductEvent class subclasses the ProductBaseEvent class
insert into OrdersWindow select * from MerchandiseProductEvent</pre><p>
				To avoid duplicate events stored in a named window, use a subquery to test whether an event already exists in the named window:
			</p><pre class="programlisting">insert into OrdersWindow
select * from ServiceProductEvent as spe
where not exists (select * from OrdersWindow as win where win.id = spe.id)</pre><p>
				A statement that removes events from a named window via the <tt class="literal">on delete</tt> clause and a statement that inserts events into a named window via the <tt class="literal">insert into</tt> can be combined to replace events in the named window, by creating the two statements in the order as indicated by the sample:
			</p><pre class="programlisting">// create in this order
on ServiceProductEvent as spe delete from OrdersWindow as win where win.id = spe.id
insert into OrdersWindow select * from ServiceProductEvent</pre><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="named-insertinto-decorated"></a>4.17.3.1.&nbsp;Named Windows Holding Decorated Events</h4></div></div><div></div></div><p>
					Decorated events hold an underlying event and add additional properties to the underlying event, as described further in <a href="#insert-into-decorated" title="4.10.4.&nbsp;Decorated Events">Section&nbsp;4.10.4, &#8220;Decorated Events&#8221;</a>.
				</p><p>
					Here we create a named window that decorates OrderEvent events by adding an additional property named <tt class="literal">priceTotal</tt> to each OrderEvent. A matching <tt class="literal">insert into</tt> statement is also part of the sample:
				</p><pre class="programlisting">create window OrdersWindow as select *, price as priceTotal from OrderEvent

insert into OrdersWindow select *, price * unit as priceTotal from ServiceOrderEvent</pre><p>
					The property type of the additional <tt class="literal">priceTotal</tt> column is the property type of the existing <tt class="literal">price</tt> property of OrderEvent.
				</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="named-insertinto-eventasproperty"></a>4.17.3.2.&nbsp;Named Windows Holding Events As Property</h4></div></div><div></div></div><p>
					Columns in a named window may also hold an event itself. More information on the <tt class="literal">insert into</tt> clause providing event columns is in <a href="#insert-into-eventasproperty" title="4.10.5.&nbsp;Event as a Property">Section&nbsp;4.10.5, &#8220;Event as a Property&#8221;</a>.
				</p><p>
					The next sample creates a named window that specifies two columns: A column that holds an OrderEvent, and a column by name <tt class="literal">priceTotal</tt>. A matching <tt class="literal">insert into</tt> statement is also part of the sample:
				</p><pre class="programlisting">create window OrdersWindow as select this, price as priceTotal from OrderEvent

insert into OrdersWindow select order, price * unit as priceTotal  
from ServiceOrderEvent as order</pre><p>
					Note that the <tt class="literal">this</tt> proprerty must exist on the event and must return the event class itself (JavaBean events only). The property type of the additional <tt class="literal">priceTotal</tt> column is the property type of the existing <tt class="literal">price</tt> property.
				</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="named_selecting"></a>4.17.4.&nbsp;Selecting From Named Windows</h3></div></div><div></div></div><a class="indexterm" name="d0e7404"></a><a class="indexterm" name="d0e7409"></a><p>
				A named window can be referred to by any statement in the <tt class="literal">from</tt> clause of the statement. Filter criteria can also be specified. Additional views may be used onto named windows however such views cannot include data window views.
			</p><p>
				A statement selecting all events from a named window 'AllOrdersNamedWindow' is shown next. The named window must first be created via the <tt class="literal">create window</tt> clause before use.
			</p><pre class="programlisting">select * from AllOrdersNamedWindow</pre><p>
				The statement as above simply receives the unfiltered insert and remove stream of the named window and reports that stream to its listeners. The <tt class="literal">iterator</tt> method returns returns all events in the named window, if any.
			</p><p>
				The next statement derives an average price per symbol from all events posted by a named window: 
			</p><pre class="programlisting">select symbol, avg(price) from AllOrdersNamedWindow group by symbol</pre><p>
				Your application may create a consuming statement such as above on an empty named window, or your application may create the above statement on an already filled named window. The engine provides correct results in either case: 
				At the time of statement creation the Esper engine internally initializes the consuming statement from the current named window, also taking your declared filters into consideration. Thus, your statement deriving data from a named window does not start empty if the named window already holds one or more events. A consuming statement also sees the remove stream of an already populated named window, if any.
			</p><p>
				If you require a subset of the data in the named window, you can specify one or more filter expressions onto the named window as shown here:
			</p><pre class="programlisting">select symbol, avg(price) from AllOrdersNamedWindow(sector='energy') group by symbol</pre><p>
				By adding a filter to the named window, the aggregation and grouping as well as any views that may be declared onto to the named window receive a filtered insert and remove stream. The above statement thus outputs, continuously, the average price per symbol for all orders in the named window that belong to a certain sector.
			</p><p>
				A side note on variables in filters filtering events from named windows: The engine initializes consuming statements at statement creation time and changes aggregation state continuously as events arrive. If the filter criteria contain variables and variable values changes, then the engine does not re-evaluate or re-build aggregation state. In such a case you may want to place variables in the <tt class="literal">having</tt> clause which evaluates on already-built aggregation state.
			</p><p>
				The following example further declares a view into the named window. Such a view can be a plug-in view or one of the built-in views, but cannot be a data window view (with the exception of the group-by view which is allowed).
			</p><pre class="programlisting">select * from AllOrdersNamedWindow(volume&gt;0, price&gt;0).mycompany:mypluginview()</pre><p>
				Data window views cannot be used onto named windows since named windows post insert and remove streams for the events entering and leaving the named window, thus the expiry policy and batch behavior are well defined by the data window declared for the named window. For example, the following is not allowed and fails at time of statement creation:
			</p><pre class="programlisting">// not a valid statement
select * from AllOrdersNamedWindow.win:time(30 sec)</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="named_querying"></a>4.17.5.&nbsp;Triggered Select on Named Windows: the <tt class="literal">On Select</tt> clause</h3></div></div><div></div></div><a class="indexterm" name="d0e7464"></a><a class="indexterm" name="d0e7467"></a><a class="indexterm" name="d0e7472"></a><p>
				The <tt class="literal">on select</tt> clause performs a one-time, non-continuous query on a named window every time a triggering event arrives or a triggering pattern matches. The query can consider all events in the named window, or only events that match certain criteria, or events that correlate with an arriving event or a pattern of arriving events.
			</p><p>
				The syntax for the <tt class="literal">on select</tt> clause is as follows: 
			</p><pre class="synopsis">on <span class="emphasis"><em>event_type</em></span>[<span class="emphasis"><em>(filter_criteria)</em></span>] [as <span class="emphasis"><em>stream_name</em></span>]
[insert into <span class="emphasis"><em>insert_into_def</em></span>]
select <span class="emphasis"><em>select_list</em></span>
from <span class="emphasis"><em>window_name</em></span> [as <span class="emphasis"><em>stream_name</em></span>]
[where <span class="emphasis"><em>criteria_expression</em></span>]
[group by <span class="emphasis"><em>grouping_expression_list</em></span>]
[having <span class="emphasis"><em>grouping_search_conditions</em></span>]
[order by <span class="emphasis"><em>order_by_expression_list</em></span>]
</pre><p>
				The <span class="emphasis"><em>event_type</em></span> is the name of the type of events that trigger the query against the named window. It is optionally followed by <span class="emphasis"><em>filter_criteria</em></span> which are filter expressions to apply to arriving events. The optional <tt class="literal">as</tt> keyword can be used to assign an stream name. Patterns or named windows can also be specified in the <tt class="literal">on</tt> clause, see the samples in <a href="#named_delete_pattern" title="4.17.2.1.&nbsp;Using Patterns in the On Delete Clause">Section&nbsp;4.17.2.1, &#8220;Using Patterns in the On Delete Clause&#8221;</a>.
			</p><p>
				The <span class="emphasis"><em>insert into</em></span> clause works as described in <a href="#epl-insert-into" title="4.10.&nbsp;Merging Streams and Continuous Insertion: the Insert Into Clause">Section&nbsp;4.10, &#8220;Merging Streams and Continuous Insertion: the Insert Into Clause&#8221;</a>. The <span class="emphasis"><em>select</em></span> clause is described in <a href="#epl-select-list" title="4.3.&nbsp;Choosing Event Properties And Events: the Select Clause">Section&nbsp;4.3, &#8220;Choosing Event Properties And Events: the Select Clause&#8221;</a>. For all clauses the semantics are equivalent to a join operation: The properties of the triggering event or events are available in the <tt class="literal">select</tt> clause and all other clauses.
			</p><p>
				The <span class="emphasis"><em>window_name</em></span> in the <tt class="literal">from</tt> clause is the name of the named window to select events from. The <tt class="literal">as</tt> keyword is also available to assign a stream name to the named window. The <tt class="literal">as</tt> keyword is helpful in conjunction with wildcard in the <tt class="literal">select</tt> clause to select named window events via the syntax <tt class="literal">select streamname.* </tt>.
			</p><p>
				The optional <tt class="literal">where</tt> clause contains a <span class="emphasis"><em>criteria_expression</em></span> that correlates the arriving (triggering) event to the events to be considered from the named window. The <span class="emphasis"><em>criteria_expression</em></span> may also simply filter for events in the named window to be considered by the query.
			</p><p>
				The <tt class="literal">group by</tt> clause, the <tt class="literal">having</tt> clause and the <tt class="literal">order by</tt> clause are all optional and work as described in earlier chapters.
			</p><p>
				The similarities and differences between an <tt class="literal">on select</tt> clause and a regular or outer join are as follows: 
			</p><div class="orderedlist"><ol type="1"><li><p>
                    A join is evaluated when any of the streams participating in the join have new events (insert stream) or events leaving data windows (remove stream).  A join is therefore bi-directional or multi-directional. However, the <tt class="literal">on select</tt> statement has one triggering event or pattern that causes the query to be evaluated and is thus uni-directional.
                </p></li><li><p>
					The query within the <tt class="literal">on select</tt> statement is not continuous: It executes only when a triggering event or pattern occurs. Aggregation and groups are computed anew considering the contents of the named window at the time the triggering event arrives.
                </p></li></ol></div><p>
				The <tt class="literal">iterator</tt> of the <tt class="literal">EPStatement</tt> object representing the <tt class="literal">on select</tt> clause returns the last batch of selected events in response to the last triggering event, or null if the last triggering event did not select any rows.
			</p><p>
				For correlated queries that correlate triggering events with events held by a named window, Esper internally creates efficient indexes to enable high performance querying of events. It analyzes the <tt class="literal">where</tt> clause to build one or more indexes for fast lookup in the named window based on the properties of the triggering event.
			</p><p>				
				The next statement demonstrates the concept. Upon arrival of a QueryEvent event the statement selects all events in the 'OrdersNamedWindow' named window:
			</p><pre class="programlisting">on QueryEvent select win.* from OrdersNamedWindow as win</pre><p>
				 The engine executes the query on arrival of a triggering event, in this case a QueryEvent. It posts the query results to any listeners to the statement, in a single invocation, as the new data array. By prefixing the wildcard (*) selector with the stream name, the <tt class="literal">select</tt> clause returns only events of the named window and does not also return triggering events.
			 </p><p>
				The <tt class="literal">where</tt> clause filters and correlates events in the named window with the triggering event, as shown next: 
			</p><pre class="programlisting">on QueryEvent(volume&gt;0) as query
select query.symbol, query.volume, win.symbol  from OrdersNamedWindow as win
where win.symbol = query.symbol</pre><p>
				 Upon arrival of a QueryEvent, if that event has a value for the volume property that is greater then zero, the engine executes the query. The query considers all events currently held by the 'OrdersNamedWindow' that match the symbol property value of the triggering QueryEvent event. The engine then posts query results to the statement's listeners.
			 </p><p>
				Aggregation, grouping and ordering of results are possible as this example shows:
			</p><pre class="programlisting">on QueryEvent as queryEvent
select symbol, sum(volume) from OrdersNamedWindow as win
group by symbol
having volume &gt; 0
order by symbol</pre><p>
				 The above statement outputs the total volume per symbol for those groups where the sum of the volume is greater then zero, ordered by symbol ascending. The engine computes and posts the output based on the current contents of the 'OrdersNamedWindow' named window considering all events in the named window, since the query does not have a <tt class="literal">where</tt> clause.
			 </p><p>
				 When using wildcard (*) to select from streams in an on-select clause, each stream, that is the the triggering stream and the selected-upon named window, are selected, similar to a join. Therefore your wildcard select
				 returns two columns: the triggering event and the selection result event, for each row.
			</p><pre class="programlisting">on QueryEvent as queryEvent
select * from OrdersNamedWindow as win</pre><p>
				 The query above returns a <tt class="literal">queryEvent</tt> column and a <tt class="literal">win</tt> column for each event. If only a single stream's event is desired in the result, use <tt class="literal">select win.*</tt> instead.
			 </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="named_playback"></a>4.17.6.&nbsp;Triggered Playback from Named Windows: the <tt class="literal">On Insert</tt> clause</h3></div></div><div></div></div><a class="indexterm" name="d0e7679"></a><a class="indexterm" name="d0e7682"></a><a class="indexterm" name="d0e7687"></a><p>
				The <tt class="literal">on insert</tt> clause is an <tt class="literal">on select</tt> clause as described in the prior chapter with the addition of an <tt class="literal">insert into</tt> clause. 
			</p><p>
				Similar to the <tt class="literal">on select</tt> clause, the engine executes the query when a triggering event arrives. It then provides the query results as an event stream to further statements. It populates the event stream that is named in the <tt class="literal">insert into</tt> clause.
			</p><p>
				The statement below provides the query results to any consumers of the MyOrderStream, upon arrival of a QueryEvent event:
			</p><pre class="programlisting">on QueryEvent as query
insert into MyOrderStream
select win.* from OrdersNamedWindow as win</pre><p>
				Here is a sample consuming statement of the MyOrderStream. The statement further filters the events provided by the <tt class="literal">on insert</tt> statement by user id and reports a total of volume per symbol:
			</p><pre class="programlisting">select symbol, sum(volume) from MyOrderStream(userId='user1') group by symbol</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="named_populate_named"></a>4.17.7.&nbsp;Populating a Named Window from an Existing Named Window</h3></div></div><div></div></div><a class="indexterm" name="d0e7727"></a><a class="indexterm" name="d0e7730"></a><a class="indexterm" name="d0e7735"></a><p>
				Your EPL statement may specify the name of an existing named window when creating a new named window, and may use the <tt class="literal">insert</tt> keyword to indicate that the new named window is to be populated from 
				the events currently held by the existing named window.
			</p><p>
				For example, and assuming the named window <tt class="literal">OrdersNamedWindow</tt> already exists, this statement creates a new named window <tt class="literal">ScratchOrders</tt> and populates all orders in <tt class="literal">OrdersNamedWindow</tt> into the new named window:
			</p><pre class="programlisting">create window ScratchOrders as OrdersNamedWindow insert</pre><p>
				The <tt class="literal">where</tt> keyword is also available to perform filtering, for example:
			</p><pre class="programlisting">create window ScratchBuyOrders as OrdersNamedWindow insert where side = 'buy'</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="named_update"></a>4.17.8.&nbsp;Updating and Versioning Events in Named Windows</h3></div></div><div></div></div><a class="indexterm" name="d0e7770"></a><a class="indexterm" name="d0e7773"></a><p>
				As outlined in <a href="#eventrep-update" title="2.9.&nbsp;Updating and Versioning Events">Section&nbsp;2.9, &#8220;Updating and Versioning Events&#8221;</a>, revision event types process updates or new versions of events held by a named window.
			</p><p>
			    A revision event type is simply one or more existing event types whose events are related by event properties that provide same key values. The purpose of key values is to 
			    indicate that arriving events are related: An event amends, updates or adds properties to an earlier event that shares the same key values.
			</p><p>
			    Revision event types can be useful in these situations:
			</p><div class="orderedlist"><ol type="1" compact><li><p>
						Some of your events carry only partial information that is related to a prior event.
					</p></li><li><p>
						Events arrive that add additional properties or change existing properties of prior events.
					</p></li><li><p>
						Events may carry properties that have null values or properties that do no exist (for example events backed by Map or XML), and for such properties the earlier value must be used instead.
					</p></li></ol></div><p>
			    To better illustrate, consider a revision event type that represents events for creation and updates to user profiles. Lets assume the user profile creation events carry the user id and a full profile. The profile update events indicate only the user id and the individual properties that actually changed. The user id property shall serve as a key value relating profile creation events and update events.
			</p><p>
			    A revision event type must be configured to instruct the engine which event types participate and what their key properties are. Configuration is described in <a href="#config-revisionevent" title="10.4.20.&nbsp;Revision Event Type">Section&nbsp;10.4.20, &#8220;Revision Event Type&#8221;</a> and is not shown here.
			</p><p>				
				Assume that an event type <tt class="literal">UserProfileRevisions</tt> has been configured to hold profile events, i.e. creation and update events related by user id. This statement creates a named window to hold the last 1 hour of current profiles per user id:
			</p><pre class="programlisting">create window UserProfileWindow.win:time(1 hour) select * from UserProfileRevisions
insert into UserProfileWindow select * from UserProfileCreation
insert into UserProfileWindow select * from UserProfileUpdate</pre><p>				
			    In revision event types, the term <span class="emphasis"><em>base</em></span> event is used to describe events that are subject to update. Events that update, amend or add additional properties to base events are termed <span class="emphasis"><em>delta</em></span> events. 
			    In the example, base events are profile creation events and delta events are profile update events. 
			</p><p>				
			    Base events are expected to arrive before delta events. In the case where a delta event arrives and is not related by key value to a base event or a revision of the base event currently held by the named window the engine ignores the delta event. Thus, considering the example, profile update events for a user id that does not have an existing profile in the named window are not applied.
			</p><p>
			    When a base or delta event arrives, the insert and remove stream output by the named window are the current and the prior version of the event. Let's come back to the example. As creation events arrive that are followed by update events or more creation events for the same user id, the engine posts the current version of the profile as insert stream (new data) and the prior version of the profile as remove stream (old data).
			</p><p>				
			    Base events are also implicitly delta events. That is, if multiple base events of the same key property values arrive, then each base event provides a new version. In the example, if multiple profile creation events arrive for the same user id then new versions of the current profile for that user id are output by the engine for each base event, as it does for delta events.
			</p><p>				
			    The expiry policy as specified by view definitions applies to each distinct key value, or multiple distinct key values for composite keys. An expiry policy re-evaluates when new versions arrive. In the example, user profile events expire from the time window when no creation or update event for a given user id has been received for 1 hour.
			</p><p>				
			    Several strategies are available for merging or overlaying events as the configuration chapter describes in greater detail.
			</p><p>				
			    Any of the Map, XML and JavaBean event representations as well as plug-in event representations may participate in a revision event type. For example, profile creation events could be JavaBean events, while profile update events could be <tt class="literal">java.util.Map</tt> events.
			</p><p>				
			    Delta events may also add properties to the revision event type. For example, one could add a new event type with security information to the revision event type and such security-related properties become available on the resulting revision event type.
			</p><p>
				The following restrictions apply to revision event types:
			</p><div class="itemizedlist"><ul type="disc" compact><li><p>
						Nested properties are only supported for the JavaBean event representation. Nested properties are not individually versioned; they are instead versioned by the containing property.
					</p></li><li><p>
						Dynamic, indexed and mapped properties are only supported for nested properties and not as properties of the revision event type itself.
					</p></li></ul></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="split_overview"></a>4.18.&nbsp;Splitting and Duplicating Streams</h2></div></div><div></div></div><p>
			EPL offers a convenient syntax to splitting and duplicating events into multiple streams, and for receiving unmatched events among a set of filter criteria.
		</p><p>
			You may define a triggering event or pattern in the <tt class="literal">on</tt>-part of the statement followed by multiple <tt class="literal">insert into</tt>, <tt class="literal">select</tt> and <tt class="literal">where</tt> clauses.
		</p><p>
			The synopsis is:
		</p><pre class="synopsis">on <span class="emphasis"><em>event_type</em></span>[(<span class="emphasis"><em>filter_criteria</em></span>)] [as <span class="emphasis"><em>stream_name</em></span>]
insert into <span class="emphasis"><em>insert_into_def</em></span> select <span class="emphasis"><em>select_list</em></span> [where <span class="emphasis"><em>condition</em></span>]
[insert into <span class="emphasis"><em>insert_into_def</em></span> select <span class="emphasis"><em>select_list</em></span> [where <span class="emphasis"><em>condition</em></span>]]
[insert into...]
[output first | all]</pre><p>
			The <span class="emphasis"><em>event_type</em></span> is the name of the type of events that trigger the split stream. It is optionally
followed by <span class="emphasis"><em>filter_criteria</em></span> which are filter expressions to apply to arriving events. The optional <tt class="literal">as</tt> keyword
can be used to assign a stream name. Patterns and named windows can also be specified in the <tt class="literal">on</tt> clause.
		</p><p>
			Following the <tt class="literal">on</tt>-clause is one or more <span class="emphasis"><em>insert into</em></span> clauses as described in <a href="#epl-insert-into" title="4.10.&nbsp;Merging Streams and Continuous Insertion: the Insert Into Clause">Section&nbsp;4.10, &#8220;Merging Streams and Continuous Insertion: the Insert Into Clause&#8221;</a> and <span class="emphasis"><em>select</em></span> clauses as described in <a href="#epl-select-list" title="4.3.&nbsp;Choosing Event Properties And Events: the Select Clause">Section&nbsp;4.3, &#8220;Choosing Event Properties And Events: the Select Clause&#8221;</a>. 
		</p><p>
			Each <tt class="literal">select</tt> clause may be followed by a <tt class="literal">where</tt> clause containing a condition. If the condition is true for the event, the engine transforms the event according to the <tt class="literal">select</tt> clause and inserts it into the corresponding stream.
		</p><p>
			At the end of the statement can be an optional <tt class="literal">output</tt> clause. By default the engine inserts into the first stream for which the <tt class="literal">where</tt> clause condition matches if one was specified, starting from the top. If you specify the <tt class="literal">output all</tt> keywords, then the engine inserts into each stream (not only the first stream) for which the <tt class="literal">where</tt> clause condition matches or that do not have a <tt class="literal">where</tt> clause.
		</p><p>
			If, for a given event, none of the <tt class="literal">where</tt> clause conditions match, the statement listener receives the unmatched event. The statement listener only receives unmatched events and does not receive any transformed or inserted events. The <tt class="literal">iterator</tt> method to the statement returns no events.
		</p><p>
			In the below sample statement, the engine inserts each <tt class="literal">OrderEvent</tt> into the <tt class="literal">LargeOrders</tt> stream if the order quantity is 100 or larger, or into the <tt class="literal">SmallOrders</tt> stream if the order quantity is smaller then 100:
		</p><pre class="programlisting">on OrderEvent 
  insert into LargeOrders select * where orderQty &gt;= 100
  insert into SmallOrders select *</pre><p>
			The next example statement adds a new stream for medium-sized orders. The new stream receives orders that have an order quantity between 20 and 100:
		</p><pre class="programlisting">on OrderEvent 
  insert into LargeOrders select orderId, customer where orderQty &gt;= 100
  insert into MediumOrders select orderId, customer where orderQty between 20 and 100
  insert into SmallOrders select orderId, customer where orderQty &gt; 0</pre><p>
			As you may have noticed in the above statement, orders that have an order quantity of zero don't match any of the conditions. The engine does not insert such order events into any stream and the listener to the statement receives these unmatched events.
		</p><p>
			By default the engine inserts into the first <tt class="literal">insert into</tt> stream without a <tt class="literal">where</tt> clause or for which the <tt class="literal">where</tt> clause condition matches. To change the default behavior and insert into all matching streams instead (including those without a <tt class="literal">where</tt> clause), the <tt class="literal">output all</tt> keywords may be added to the statement.
		</p><p>
			The sample statement below shows the use of the <tt class="literal">output all</tt> keywords. The statement populates both the <tt class="literal">LargeOrders</tt> stream with large orders as well as the <tt class="literal">VIPCustomerOrders</tt> stream with orders for certain customers based on customer id:
		</p><pre class="programlisting">on OrderEvent 
  insert into LargeOrders select * where orderQty &gt;= 100
  insert into VIPCustomerOrders select * where customerId in (1001, 1002)
  output all</pre><p>
		  Since the <tt class="literal">output all</tt> keywords are present, the above statement inserts each order event into either both streams or only one stream or none of the streams, depending on order quantity and customer id of the order event. The statement delivers order events not inserted into any of the streams to the listeners and/or subscriber to the statement.
	  </p><p>
		  The following limitations apply to split-stream statements:
	  </p><div class="orderedlist"><ol type="1" compact><li><p>
					Sub-selects, aggregation functions and the <tt class="literal">prev</tt> and <tt class="literal">prior</tt> operators are not available in conditions and the <tt class="literal">select</tt>-clause.
				</p></li></ol></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="variables_overview"></a>4.19.&nbsp;Variables</h2></div></div><div></div></div><a class="indexterm" name="d0e8030"></a><a class="indexterm" name="d0e8033"></a><p>
			A <span class="emphasis"><em>variable</em></span> is a scalar value that is available for use in all statements including patterns. Variables can be used in an expression anywhere in a statement as well as in the <tt class="literal">output</tt> clause for output rate limiting.
		</p><p>
			Variables must first be declared or configured before use, by defining each variable's type and name. Variables can be created via the <tt class="literal">create variable</tt> syntax or declared by configuration. Variables can be assigned new values by using the <tt class="literal">on set</tt> syntax or via the <tt class="literal">setVariableValue</tt> methods on <tt class="literal">EPRuntime</tt>. The <tt class="literal">EPRuntime</tt> also provides method to read variable values.
		</p><p>
			 The engine guarantees consistency and atomicity of variable reads and writes on a statement-level (this is a soft guarantee, see below). Variables are optimized for fast read access and are also multithread-safe.
		</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="variable_create"></a>4.19.1.&nbsp;Creating Variables: the <tt class="literal">Create Variable</tt> clause</h3></div></div><div></div></div><p>
				The <tt class="literal">create variable</tt> syntax creates a new variable by defining the variable type and name. In alternative to the syntax, variables can also be declared in the runtime and engine configuration options.
			</p><p>
				The synopsis for creating a variable is as follows: 
			</p><pre class="synopsis">create variable <span class="emphasis"><em>variable_type</em></span> <span class="emphasis"><em>variable_name</em></span> [ = <span class="emphasis"><em>assignment_expression</em></span> ]</pre><p>
				The <span class="emphasis"><em>variable_type</em></span> can be any of the following:
			</p><pre class="synopsis">variable_type
	:  string
	|  char 
	|  character
	|  bool 
	|  boolean
	|  byte
	|  short 
	|  int 
	|  integer 
	|  long 
	|  double
	|  float</pre><p>
				The <span class="emphasis"><em>variable_name</em></span> is an identifier that names the variable. The variable name should not already be in use by another variable.
			</p><p>				
				The <tt class="literal">assignment_expression</tt> is optional. Without an assignment expression the initial value for the variable is <tt class="literal">null</tt>. If present, it supplies the initial value for the variable.
			</p><p>
				The <tt class="literal">EPStatement</tt> object of the <tt class="literal">create variable</tt> statement provides access to variable values. The pull API methods <tt class="literal">iterator</tt> and <tt class="literal">safeIterator</tt> return the current variable value. Listeners to the 
				<tt class="literal">create variable</tt> statement subscribe to changes in variable value: the engine posts new and old value of the variable to all listeners when the variable value is updated by an <tt class="literal">on set</tt> statement.
			</p><p>
				The example below creates a variable that provides a threshold value. The name of the variable is <tt class="literal">var_threshold</tt> and its type is <tt class="literal">long</tt>. The variable's initial value is <tt class="literal">null</tt> as no other value has been assigned:
			</p><pre class="programlisting">create variable long var_threshold</pre><p>
				This statement creates an integer-type variable named <tt class="literal">var_output_rate</tt> and initializes it to the value ten (10):
			</p><pre class="programlisting">create variable integer var_output_rate = 10</pre><p>
				In addition to creating a variable via the <tt class="literal">create variable</tt> syntax, the runtime and engine configuration API also allows adding variables. The next code snippet illustrates the
				use of the runtime configuration API to create a string-typed variable:
			</p><pre class="programlisting">epService.getEPAdministrator().getConfiguration()
  .addVariable("myVar", String.class, "init value");</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="variable_set"></a>4.19.2.&nbsp;Setting Variable Values: the <tt class="literal">On Set</tt> clause</h3></div></div><div></div></div><p>
				The <tt class="literal">on set</tt> statement assigns a new value to one or more variables when a triggering event arrives or a triggering pattern occurs. Use the <tt class="literal">setVariableValue</tt> methods on <tt class="literal">EPRuntime</tt> to assign variable values programmatically.
			</p><p>
				The synopsis for setting variable values is: 
			</p><pre class="synopsis">on <span class="emphasis"><em>event_type</em></span>[<span class="emphasis"><em>(filter_criteria)</em></span>] [as <span class="emphasis"><em>stream_name</em></span>]
  set <span class="emphasis"><em>variable_name</em></span> = <span class="emphasis"><em>expression</em></span> [, <span class="emphasis"><em>variable_name</em></span> = <span class="emphasis"><em>expression</em></span> [,...]]
</pre><p>
				The <span class="emphasis"><em>event_type</em></span> is the name of the type of events that trigger the variable assignments. It is optionally followed by <span class="emphasis"><em>filter_criteria</em></span> which are filter expressions to apply to arriving events. The optional <tt class="literal">as</tt> keyword can be used to assign an stream name. Patterns and named windows can also be specified in the <tt class="literal">on</tt> clause.
			</p><p>
				The comma-separated list of variable names and expressions set the value of one or more variables. All new variable values are applied atomically: the changes to variable values by the <tt class="literal">on set</tt> statement 
				become visible to other statements all at the same time. No changes are visible to other processing threads until the <tt class="literal">on set</tt> statement completed processing, and at that time all changes become visible at once.
			</p><p>
				The <tt class="literal">EPStatement</tt> object provides access to variable values. The pull API methods <tt class="literal">iterator</tt> and <tt class="literal">safeIterator</tt> return the current variable values for each of the variables set by the statement. 
				Listeners to the statement subscribe to changes in variable values: the engine posts new variable values of all variables to any listeners.
			</p><p>
				In the following example, a variable by name <tt class="literal">var_output_rate</tt> has been declared previously. When a NewOutputRateEvent event arrives, the variable is updated to a new value supplied by the event property 'rate':
			</p><pre class="programlisting">on NewOutputRateEvent set var_output_rate = rate</pre><p>
				The next example shows two variables that are updated when a ThresholdUpdateEvent arrives:
			</p><pre class="programlisting">on ThresholdUpdateEvent as t 
  set var_threshold_lower = t.lower,
      var_threshold_higher = t.higher</pre><p>
				The sample statement shown next counts the number of pattern matches using a variable. The pattern looks for OrderEvent events that are followed by CancelEvent events for the same order id within 10 seconds of the OrderEvent:
			</p><pre class="programlisting">on pattern[every a=OrderEvent -&gt; (CancelEvent(orderId=a.orderId) where timer:within(10 sec))]
  set var_counter = var_counter + 1</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="variable_using"></a>4.19.3.&nbsp;Using Variables</h3></div></div><div></div></div><p>
				A variable name can be used in any expression and can also occur in an output rate limiting clause. This section presents examples and discusses performance, consistency and atomicity attributes of variables.
			</p><p>
				The next statement assumes that a variable named 'var_threshold' was created to hold a total price threshold value. 
				The statement outputs an event when the total price for a symbol is greater then the current threshold value:
			</p><pre class="programlisting">select symbol, sum(price) from TickEvent 
group by symbol 
having sum(price) &gt; var_threshold</pre><p>
				In this example we use a variable to dynamically change the output rate on-the-fly. The variable 'var_output_rate' holds the current rate at which the statement posts a current count to listeners:
			</p><pre class="programlisting">select count(*) from TickEvent output every var_output_rate seconds</pre><p>
				Variables are optimized towards high read frequency and lower write frequency. Variable reads do not incur locking overhead (99% of the time) while variable writes do incur locking overhead. 
			</p><p>
				The engine softly guarantees consistency and atomicity of variables when your statement executes in response to an event or timer invocation. Variables acquire a stable value (implemented by versioning) when your statement starts executing in response to an event or timer invocation, and variables do not change value during execution. When one or more variable values are updated via <tt class="literal">on set</tt> statements, the changes to all updated variables become visible to statements as one unit and only when the <tt class="literal">on set</tt> statement completes successfully.
			</p><p>
				The atomicity and consistency guarantee is a soft guarantee. If any of your application statements, in response to an event or timer invocation, execute for a time interval longer then 15 seconds (default interval length), then the engine may use current variable values after 15 seconds passed, rather then then-current variable values at the time the statement started executing in response to an event or timer invocation.				
			</p><p>
				The length of the time interval that variable values are held stable for the duration of execution of a given statement is by default 15 seconds, but can be configured via engine default settings.
			</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="epl-containedeventselect"></a>4.20.&nbsp;Contained-Event Selection</h2></div></div><div></div></div><p>
			Contained-event selection is for use when an event contains properties that are themselves events. For example when application events are coarse-grained structures and you need to perform bulk operations on the rows of the property graph in an event.
		</p><p>
			Use the contained-event selection syntax in a filter expression such as in a pattern, <tt class="literal">from</tt> clause, subselect, on-select and on-delete. This section provides the synopsis and examples.
		</p><p>
			To review, in the <tt class="literal">from</tt> clause a <span class="emphasis"><em>contained_selection</em></span> may appear after the event stream name and filter criteria, and before any view specifications.
		</p><p>
			The synopsis for <span class="emphasis"><em>contained_selection</em></span> is as follows:
		</p><pre class="synopsis">[select <span class="emphasis"><em>select_expressions</em></span> from] <span class="emphasis"><em>property_expression</em></span> [as <span class="emphasis"><em>property_alias</em></span>] [where <span class="emphasis"><em>filter_expression</em></span>]</pre><p>
			The <tt class="literal">select</tt> clause and <span class="emphasis"><em>select_expressions</em></span> are optional and may be used to select specific properties.
		</p><p>
			The <span class="emphasis"><em>property_expression</em></span> is required and must be a valid property name that returns an event fragment, i.e. a property that can itself be represented as an event by the underlying event representation. Simple values such as integer or string are not fragments.
		</p><p>
			The <span class="emphasis"><em>property_alias</em></span> can be provided to assign a name to the property expression.
		</p><p>
			The <tt class="literal">where</tt> clause and <span class="emphasis"><em>filter_expression</em></span> is optional and may be used to filter out properties.
		</p><p>
			As an example event, consider a media order. A media order consists of order items as well as product descriptions. A media order event can be represented as an object graph (POJO event representation), or a structure of nested Maps (Map event representation) or a XML document (XML DOM or Axiom event representation) or other custom plug-in event representation.
		</p><p>
			To illustrate, a sample media order event in XML event representation is shown below. Also, a XML event type can optionally be strongly-typed with an explicit XML XSD schema that we don't show here. Note that Map and POJO representation can be considered equivalent for the purpose of this example.
		</p><p>
			Let us now assume that we have declared the event type <tt class="literal">MediaOrder</tt> as being represented by the root node <tt class="literal">&lt;mediaorder&gt;</tt> of such XML snip:
		</p><pre class="programlisting">&lt;mediaorder&gt;
  &lt;orderId&gt;PO200901&lt;/orderId&gt;
  &lt;items&gt;
    &lt;item&gt;
      &lt;itemId&gt;100001&lt;/itemId&gt;
      &lt;productId&gt;B001&lt;/productId&gt;
      &lt;amount&gt;10&lt;/amount&gt;
      &lt;price&gt;11.95&lt;/price&gt;
    &lt;/item&gt;
  &lt;/items&gt;
  &lt;books&gt;
    &lt;book&gt;
      &lt;bookId&gt;B001&lt;/bookId&gt;
      &lt;author&gt;Heinlein&lt;/author&gt;
      &lt;review&gt;
        &lt;reviewId&gt;1&lt;/reviewId&gt;
        &lt;comment&gt;best book ever&lt;/comment&gt;
      &lt;/review&gt;
    &lt;/book&gt;
    &lt;book&gt;
      &lt;bookId&gt;B002&lt;/bookId&gt;
      &lt;author&gt;Isaac Asimov&lt;/author&gt;
    &lt;/book&gt;
  &lt;/books&gt;
&lt;/mediaorder&gt;</pre><p>
			The next query utilizes the contained-event selection syntax to return each book:
		</p><pre class="programlisting">select * from MediaOrder[books.book]</pre><p>
			The result of the above query is one event per book. Output events contain only the book properties and not any of the mediaorder-level properties.
		</p><p>
			Note that, when using listeners, the engine delivers multiple results in one invocation of each listener. Therefore listeners to the above statement can expect a single invocation passing all book events within one media order event as an array.
		</p><p>
			 To better illustrate the position of the contained-event selection syntax in a statement, consider the next two queries:
		</p><pre class="programlisting">select * from MediaOrder(orderId='PO200901')[books.book]</pre><p>
			The above query the returns each book only for media orders with a given order id. This query illustrates a contained-event selection and a view: 
		</p><pre class="programlisting">select count(*) from MediaOrder[books.book].std:unique(bookId)</pre><p>
			The sample above counts each book unique by book id.
		</p><p>
			Contained-event selection can be staggered. When staggering multiple contained-event selections the staggered contained-event selection is relative to its parent.
		</p><p>
			This example demonstrates staggering contained-event selections by selecting each review of each book:
		</p><pre class="programlisting">select * from MediaOrder[books.book][review]</pre><p>
			Listeners to the query above receive a row for each review of each book. Output events contain only the review properties and not the book or media order properties.
		</p><p>
			The following is not valid:
		</p><pre class="programlisting">// not valid
select * from MediaOrder[books.book.review]</pre><p>
			The <tt class="literal">book</tt> property in an indexed property (an array or collection) and thereby requires an index in order to determine which book to use. The expression <tt class="literal">books.book[1].review</tt> is valid and means all reviews of the second (index 1) book.
		</p><p>
			The contained-event selection syntax is part of the filter expression and may therefore occur in patterns and anywhere a filter expression is valid. 
		</p><p>
			A pattern example is below. The example assumes that a <tt class="literal">Cancel</tt> event type has been defined that also has an <tt class="literal">orderId</tt> property:
		</p><pre class="programlisting">select * from pattern [c=Cancel -&gt; books=MediaOrder(orderId = c.orderId)[books.book] ]</pre><p>
			When used in a pattern, a filter with a contained-event selection returns an array of events, similar to the match-until clause in patterns. The above statement returns, in the <tt class="literal">books</tt> property, an
			array of book events.
		</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="epl-containedeventselect-select"></a>4.20.1.&nbsp;Select Clause in a Contained-Event Selection</h3></div></div><div></div></div><p>
				 The optional <tt class="literal">select</tt> clause provides control over which fields are available in output events. The expressions in the select clause apply only to the properties available underneath the property in the <tt class="literal">from</tt> clause, and the properties of the enclosing event.
			</p><p>
				 When no <tt class="literal">select</tt> is specified, only the properties underneath the selected property are available in output events.
			</p><p>
				 In summary, the <tt class="literal">select</tt> clause may contain:
			</p><div class="orderedlist"><ol type="1" compact><li><p>
						Any expressions, wherein properties are resolved relative to the property in the <tt class="literal">from</tt> clause.
					</p></li><li><p>
						Use the wildcard (<tt class="literal">*</tt>) to provide all properties that exist under the property in the <tt class="literal">from</tt> clause.
					</p></li><li><p>
						Use the <span class="emphasis"><em>property_alias</em></span><tt class="literal">.*</tt> syntax to provide all properties that exist under a property in the <tt class="literal">from</tt> clause.
					</p></li></ol></div><p>
				The next query's <tt class="literal">select</tt> clause selects each review for each book, and the order id as well as the book id of each book:
			</p><pre class="programlisting">select * from MediaOrder[select orderId, bookId from books.book][select * from review]
// ... equivalent to ...
select * from MediaOrder[select orderId, bookId from books.book][review]]</pre><p>
				Listeners to the statement above receive an event for each review of each book. Each output event has all properties of the review row, and in addition the <tt class="literal">bookId</tt> of each book and the <tt class="literal">orderId</tt> of the order.
				Thus <tt class="literal">bookId</tt> and <tt class="literal">orderId</tt> are found in each result event, duplicated when there are multiple reviews per book and order.
			</p><p>
				 The above query uses wildcard <tt class="literal">(*)</tt> to select all properties from reviews. As has been discussed as part of the <tt class="literal">select</tt> clause, the wildcard (<tt class="literal">*</tt>) and <span class="emphasis"><em>property_alias</em></span><tt class="literal">.*</tt> do not copy properties for performance reasons. The wildcard syntax instead specifies the underlying type, and additional properties are added onto that underlying type if required. Only one wildcard (<tt class="literal">*</tt>) and <span class="emphasis"><em>property_alias</em></span><tt class="literal">.*</tt> (unless used with a column rename) may therefore occur in the <tt class="literal">select</tt> clause list of expressions.
			</p><p>
				All the following queries produce an output event for each review of each book. The next sample queries illustrate the options available to control the fields of output events.
			</p><p>
				The output events produced by the next query have all properties of each review and no other properties available:
			</p><pre class="programlisting">select * from MediaOrder[books.book][review]</pre><p>
				The following query is not a valid query, since the order id and book id are not part of the contained-event selection:
			</p><pre class="programlisting">// Invalid select clause: orderId and bookId not produced.
select orderId, bookId from MediaOrder[books.book][review]</pre><p>
				This query is valid. Note that output events carry only the <tt class="literal">orderId</tt> and <tt class="literal">bookId</tt> properties and no other data:
			</p><pre class="programlisting">select orderId, bookId from MediaOrder[books.book][select orderId, bookId from review]
//... equivalent to ...
select * from MediaOrder[select orderId, bookId from books.book][review]</pre><p>
				This variation produces output events that have all properties of each book and only <tt class="literal">reviewId</tt> and <tt class="literal">comment</tt> for each review:
			</p><pre class="programlisting">select * from MediaOrder[select * from books.book][select reviewId, comment from review]
// ... equivalent to ...
select * from MediaOrder[books.book as book][select book.*, reviewId, comment from review]</pre><p>
				The output events of the next EPL have all properties of the order and only <tt class="literal">bookId</tt> and <tt class="literal">reviewId</tt> for each review:
			</p><pre class="programlisting">select * from MediaOrder[books.book as book]
    [select mediaOrder.*, bookId, reviewId from review] as mediaOrder</pre><p>
				This EPL produces output events with 3 columns: a column named <tt class="literal">mediaOrder</tt> that is the order itself, a column named <tt class="literal">book</tt> for each book and a column named <tt class="literal">review</tt> that holds each review:
			</p><pre class="programlisting">insert into ReviewStream select * from MediaOrder[books.book as book]
  [select mo.* as mediaOrder, book.* as book, review.* as review from review as review] as mo
// .. and a sample consumer of ReviewStream...
select mediaOrder.orderId, book.bookId, review.reviewId from ReviewStream</pre><p>
				Please note these limitations:
			</p><div class="orderedlist"><ol type="1" compact><li><p>
						Sub-selects, aggregation functions and the <tt class="literal">prev</tt> and <tt class="literal">prior</tt> operators are not available in contained-event selection.
					</p></li><li><p>
						Expressions in the <tt class="literal">select</tt> and <tt class="literal">where</tt> clause of a contained-event selection can only reference properties relative to the current event and property.
					</p></li></ol></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="epl-containedeventselect-where"></a>4.20.2.&nbsp;Where Clause in a Contained-Event Selection</h3></div></div><div></div></div><p>
				The optional <tt class="literal">where</tt> clause may be used to filter out properties at the same level that the where-clause occurs.
			</p><p>
				The properties in the filter expression must be relative to the property in the <tt class="literal">from</tt> clause or the enclosing event.
			</p><p>
				This query outputs all books with a given author:
			</p><pre class="programlisting">select * from MediaOrder[books.book where author = 'Heinlein']</pre><p>
				This query outputs each review of each book where a review comment contains the word 'good':
			</p><pre class="programlisting">select * from MediaOrder[books.book][review where comment like 'good']</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="epl-containedeventselect-join"></a>4.20.3.&nbsp;Contained-Event Selection and Joins</h3></div></div><div></div></div><p>
				This section discusses contained-event selection in joins.
			</p><p>
				When joining within the same event it is not required that views are specified. Recall, in a join or outer join there must be views specified that hold the data to be joined. For self-joins, no views are required and the join
				executes against the data returned by the same event.
			</p><p>
				This query inner-joins items to books where book id matches the product id:
			</p><pre class="programlisting">select book.bookId, item.itemId 
from MediaOrder[books.book] as book, 
      MediaOrder[items.item] as item 
where productId = bookId</pre><p>
				Query results for the above query when sending the media order event as shown earlier are:
			</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><thead><tr><th>book.bookId</th><th>item.itemId</th></tr></thead><tbody><tr><td>B001</td><td>100001</td></tr></tbody></table></div><p>
				The next example query is a left outer join. It returns all books and their items, and for books without item it returns the book and a <tt class="literal">null</tt> value:
			</p><pre class="programlisting">select book.bookId, item.itemId 
from MediaOrder[books.book] as book 
  left outer join 
    MediaOrder[items.item] as item 
  on productId = bookId</pre><p>
				Query results for the above query when sending the media order event as shown earlier are:
			</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><thead><tr><th>book.bookId</th><th>item.itemId</th></tr></thead><tbody><tr><td>B001</td><td>100001</td></tr><tr><td>B002</td><td>null</td></tr></tbody></table></div><p>
				A full outer join combines the results of both left and right outer joins. The joined table will contain all records from both tables, and fill in <tt class="literal">null</tt> values for missing matches on either side.
			</p><p>
				This example query is a full outer join, returning all books as well as all items, and filling in <tt class="literal">null</tt> values for book id or item id if no match is found:
			</p><pre class="programlisting">select orderId, book.bookId,item.itemId 
from MediaOrder[books.book] as book 
  full outer join 
     MediaOrder[select orderId, * from items.item] as item 
  on productId = bookId 
order by bookId, item.itemId asc
</pre><p>
				As in all other continuous queries, aggregation results are cumulative from the time the statement was created.
			</p><p>
				The following query counts the cumulative number of items in which the product id matches a book id:
			</p><pre class="programlisting">select count(*) 
from MediaOrder[books.book] as book, 
      MediaOrder[items.item] as item 
where productId = bookId</pre><p>
				The <tt class="literal">unidirectional</tt> keyword in a join indicates to the query engine that aggregation state is not cumulative. The next query counts the number of items in which the product id matches a book id for each event:
			</p><pre class="programlisting">select count(*) 
from MediaOrder[books.book] as book unidirectional, 
      MediaOrder[items.item] as item 
where productId = bookId</pre></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="event_patterns"></a>Chapter&nbsp;5.&nbsp;EPL Reference: Patterns</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="event-pattern-intro"></a>5.1.&nbsp;Event Pattern Overview</h2></div></div><div></div></div><a class="indexterm" name="d0e8686"></a><p>
			Event patterns match when an event or multiple events occur that match the pattern's definition. Patterns can also be time-based.
         </p><p>
			Pattern expressions consist of pattern atoms and pattern operators:
         </p><div class="orderedlist"><ol type="1"><li><p>
					Pattern <span class="emphasis"><em>atoms</em></span> are the basic building blocks of patterns. Atoms are filter expressions, observers for time-based events and plug-in custom observers that observe external events not under the control of the engine.
                </p></li><li><p>
					Pattern <span class="emphasis"><em>operators</em></span> control expression lifecycle and combine atoms logically or temporally.  
                </p></li></ol></div><p>
			The below table outlines the different pattern atoms available:
		</p><div class="table"><a name="d0e8710"></a><p class="title"><b>Table&nbsp;5.1.&nbsp;Pattern Atoms</b></p><table summary="Pattern Atoms" border="1"><colgroup><col><col></colgroup><thead><tr><th>Pattern Atom</th><th>Example</th></tr></thead><tbody><tr><td>Filter expressions specify an event to look for.</td><td><pre class="programlisting">StockTick(symbol='ABC', price &gt; 100)</pre></td></tr><tr><td>Time-based event observers specify time intervals or time schedules.</td><td><pre class="programlisting">timer:interval(10 seconds)</pre><pre class="programlisting">timer:at(*, 16, *, *, *)</pre></td></tr><tr><td>Custom plug-in observers can add pattern language syntax for observing application-specific events.</td><td><pre class="programlisting">myapplication:myobserver("http://someResource")</pre></td></tr></tbody></table></div><p>
			There are 4 types of pattern operators:
         </p><div class="orderedlist"><ol type="1" compact><li><p>
					Operators that control pattern subexpression repetition: <tt class="literal">every</tt>, <tt class="literal">every-distinct</tt>, <tt class="literal">[num]</tt> and <tt class="literal">until</tt>
				</p></li><li><p>
					Logical operators: <tt class="literal">and</tt>, <tt class="literal">or</tt>, <tt class="literal">not</tt>
				</p></li><li><p>
					Temporal operators that operate on event order: <tt class="literal">-&gt;</tt> (followed-by)
				</p></li><li><p>
					Guards are where-conditions that control the lifecycle of subexpressions. Examples are <tt class="literal">timer:within</tt>. Custom plug-in guards may also be used.
				</p></li></ol></div><p>
			Pattern expressions can be nested arbitrarily deep by including the nested expression(s) in <tt class="literal">()</tt> round parenthesis.
         </p><p>
			Underlying the pattern matching is a state machine that transitions between states based on arriving events and based on time advancing. A single event or advancing time may 
			cause a reaction in multiple parts of your active pattern state.
         </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="pattern-how-to-use"></a>5.2.&nbsp;How to use Patterns</h2></div></div><div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="pattern-howto-syntax"></a>5.2.1.&nbsp;Pattern Syntax</h3></div></div><div></div></div><p>
				This is an example pattern expression that matches on every <tt class="literal">ServiceMeasurement</tt> events in which the
				value of the <tt class="literal">latency</tt> event property is over 20 seconds, and on every <tt class="literal">ServiceMeasurement</tt> event in which the
				<tt class="literal">success</tt> property is false. Either one or the other condition must be true for this pattern to match.
			</p><pre class="programlisting">every (spike=ServiceMeasurement(latency&gt;20000) or error=ServiceMeasurement(success=false))</pre><p>
				In the example above, the pattern expression starts with an <tt class="literal">every</tt> operator to indicate that the pattern should fire for every matching events and not just the first
				matching event. Within the <tt class="literal">every</tt> operator in round brackets is a nested pattern expression using the <tt class="literal">or</tt> operator. 
				The left hand of the <tt class="literal">or</tt> operator is a filter expression that filters for events with a high latency value. The right hand of the operator 
				contains a filter expression that filters for events with error status. Filter expressions are explained in <a href="#pattern-filter" title="5.4.&nbsp;Filter Expressions In Patterns">Section&nbsp;5.4, &#8220;Filter Expressions In Patterns&#8221;</a>.
			</p><p>
				The example above assigned the tags <tt class="literal">spike</tt> and <tt class="literal">error</tt> to the events in the pattern. The tags are important since the
				engine only places tagged events into the output event(s) that a pattern generates, and that the engine supplies to listeners of the pattern statement. The tags can
				further be selected in the select-clause of an EPL statement as discussed in <a href="#epl-from-clause-patterns" title="4.4.2.&nbsp;Pattern-based Event Streams">Section&nbsp;4.4.2, &#8220;Pattern-based Event Streams&#8221;</a>.
			</p><p>
				Patterns can also contain comments within the pattern as outlined in <a href="#epl-syntax-comments" title="4.2.2.&nbsp;Using Comments">Section&nbsp;4.2.2, &#8220;Using Comments&#8221;</a>.
			</p><p>
				Pattern statements are created via the <tt class="literal">EPAdministrator</tt> interface. The <tt class="literal">EPAdministrator</tt> interface allows to create pattern statements in two ways:
				Pattern statements that want to make use of the EPL <tt class="literal">select</tt> clause or any other EPL constructs use the <tt class="literal">createEPL</tt> method to create a statement that specifies one or more pattern expressions. EPL statements that use patterns are described in more detail in <a href="#epl-from-clause-patterns" title="4.4.2.&nbsp;Pattern-based Event Streams">Section&nbsp;4.4.2, &#8220;Pattern-based Event Streams&#8221;</a>. Use the syntax as shown in below example.
			</p><pre class="programlisting">EPAdministrator admin = EPServiceProviderManager.getDefaultProvider().getEPAdministrator();

String eventName = ServiceMeasurement.class.getName();

EPStatement myTrigger = admin.createEPL("select * from pattern [" +
  "every (spike=" + eventName + "(latency&gt;20000) or error=" + eventName + "(success=false))]");
</pre><p>
				Pattern statements that do not need to make use of the EPL <tt class="literal">select</tt> clause or any other EPL constructs can use the <tt class="literal">createPattern</tt> method, as in below example.
			</p><pre class="programlisting">EPStatement myTrigger = admin.createPattern(
  "every (spike=" + eventName + "(latency&gt;20000) or error=" + eventName + "(success=false))");
</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="pattern-in-eql"></a>5.2.2.&nbsp;Patterns in EPL</h3></div></div><div></div></div><p>
				A pattern may appear anywhere in the <tt class="literal">from</tt> clause of an EPL statement including joins and subqueries. Patterns may therefore be used in combination with the <tt class="literal">where</tt> clause, <tt class="literal">group by</tt> clause, <tt class="literal">having</tt> clause as well as output rate limiting and <tt class="literal">insert into</tt>. In addition, a data window view can be declared onto a pattern.
			</p><p>
				This example statement demonstrates the idea by selecting a total price per customer over pairs of events (ServiceOrder followed by a ProductOrder event for the same customer id within 1 minute), occuring in the last 2 hours, in which the sum of price is greater then 100, and using a <tt class="literal">where</tt> clause to filter on name:
			</p><pre class="programlisting">select a.custId, sum(a.price + b.price)
from pattern [every a=ServiceOrder -&gt; 
    b=ProductOrder(custId = a.custId) where timer:within(1 min)].win:time(2 hour) 
where a.name in ('Repair', b.name)
group by a.custId
having sum(a.price + b.price) &gt; 100</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="patterns-howto-subscribe"></a>5.2.3.&nbsp;Subscribing to Pattern Events</h3></div></div><div></div></div><p>			
				When a pattern fires it publishes one or more events to any listeners to the pattern statement. 
				The listener interface is the <tt class="literal">com.espertech.esper.client.UpdateListener</tt> interface.
			</p><p>            
				The example below shows an anonymous implementation of the <tt class="literal">com.espertech.esper.client.UpdateListener</tt> interface.
				We add the anonymous listener implementation to the <tt class="literal">myPattern</tt> statement created earlier. 
				The listener code simply extracts the underlying event class.
			</p><pre class="programlisting">myPattern.addListener(new UpdateListener() {
  public void update(EventBean[] newEvents, EventBean[] oldEvents) {
    ServiceMeasurement spike = (ServiceMeasurement) newEvents[0].get("spike");
    ServiceMeasurement error = (ServiceMeasurement) newEvents[0].get("error");
    ... // either spike or error can be null, depending on which occurred
    ... // add more logic here
  }
});</pre><p>            
				Listeners receive an array of <tt class="literal">EventBean</tt> instances in the <tt class="literal">newEvents</tt> parameter.
				There is one <tt class="literal">EventBean</tt> instance passed to the listener for each combination of events that matches
				the pattern expression. At least one <tt class="literal">EventBean</tt> instance is always passed to the listener.
			</p><p>
				The properties of each <tt class="literal">EventBean</tt> instance contain the underlying events that caused the
				pattern to fire, if events have been named in the filter expression via the <tt class="literal">name=eventType</tt> syntax.
				The property name is thus the name supplied in the pattern expression, while the property type is the type of the underlying class, 
				in this example <tt class="literal">ServiceMeasurement</tt>.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="pattern-howto-pull-data"></a>5.2.4.&nbsp;Pulling Data from Patterns</h3></div></div><div></div></div><p>
				Data can also be obtained from pattern statements via the <tt class="literal">safeIterator()</tt> and <tt class="literal">iterator()</tt> methods on <tt class="literal">EPStatement</tt> (the pull API). 
				If the pattern had fired at least once, then the iterator returns the last event for which it fired.
				The <tt class="literal">hasNext()</tt> method can be used to determine if the pattern had fired.				 				
			</p><pre class="programlisting">if (myPattern.iterator().hasNext()) {
	ServiceMeasurement event = (ServiceMeasurement) view.iterator().next().get("alert");
    ... // some more code here to process the event
}
else {
    ... // no matching events at this time
}</pre><p>
				Further, if a data window is defined onto a pattern, the iterator returns the pattern matches according to the data window expiry policy.
			</p><p>
				This pattern specifies a length window of 10 elements that retains the last 10 matches of A and B events, for use via iterator or for use in a join or subquery:
			</p><pre class="programlisting">select * from pattern [every (A or B).win:length(10)</pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="pattern-op-precedence"></a>5.3.&nbsp;Operator Precedence</h2></div></div><div></div></div><a class="indexterm" name="d0e8970"></a><p>
			The operators at the top of this table take precedence over operators lower on the table. 
		</p><div class="table"><a name="d0e8977"></a><p class="title"><b>Table&nbsp;5.2.&nbsp;Pattern Operator Precedence</b></p><table summary="Pattern Operator Precedence" border="1"><colgroup><col><col><col><col></colgroup><thead><tr><th>Precedence</th><th>Operator</th><th>Description</th><th>Example</th></tr></thead><tbody><tr><td>1</td><td>unary</td><td><tt class="literal">every, not, every-distinct</tt></td><td><pre class="programlisting">every MyEvent
timer:interval(5 min) and not MyEvent</pre></td></tr><tr><td>2</td><td>guard postfix</td><td><tt class="literal">where timer:within</tt> (or plug-in pattern guard)</td><td><pre class="programlisting">MyEvent where timer:within(1 sec)</pre></td></tr><tr><td>3</td><td>repeat</td><td><tt class="literal">[num]</tt>, <tt class="literal">until</tt></td><td><pre class="programlisting">[5] MyEvent</pre><pre class="programlisting">[1..3] MyEvent until MyOtherEvent</pre></td></tr><tr><td>4</td><td>and</td><td><tt class="literal">and</tt></td><td><pre class="programlisting">every (MyEvent and MyOtherEvent)</pre></td></tr><tr><td>5</td><td>or</td><td><tt class="literal">or</tt></td><td><pre class="programlisting">every (MyEvent or MyOtherEvent)</pre></td></tr><tr><td>6</td><td>followed-by</td><td><tt class="literal">-&gt;</tt></td><td><pre class="programlisting">every (MyEvent -&gt; MyOtherEvent)</pre></td></tr></tbody></table></div><p>
			If you are not sure about the precedence, please consider placing parenthesis <tt class="literal">()</tt> around your subexpressions. Parenthesis can also help make
			expressions easier to read and understand.
		</p><p>
			Note that we are also providing the EPL grammar as a HTML file as part of the documentation set on the project website.
		</p><p>
			The following table outlines sample equivalent expressions, with and without the use of parenthesis for subexpressions.
		</p><div class="table"><a name="d0e9077"></a><p class="title"><b>Table&nbsp;5.3.&nbsp;Equivalent Pattern Expressions</b></p><table summary="Equivalent Pattern Expressions" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>Expression</th><th>Equivalent</th><th>Reason</th></tr></thead><tbody><tr><td>every A or B</td><td>(every A) or B</td><td>The <tt class="literal">every</tt> operator has higher precedence then the <tt class="literal">or</tt> operator.</td></tr><tr><td>every A -&gt; B or C</td><td>(every A) -&gt; (B or C)</td><td>The <tt class="literal">or</tt> operator has higher precedence then the <tt class="literal">followed-by</tt> operator.</td></tr><tr><td>A and B or C</td><td>(A and B) or C</td><td>The <tt class="literal">and</tt> operator has higher precedence then the <tt class="literal">or</tt> operator.</td></tr><tr><td>every A where timer:within(5)</td><td>every (A where timer:within(5))</td><td>The <tt class="literal">every</tt> operator has higher precedence then the <tt class="literal">timer:within</tt> guard postfix.</td></tr><tr><td>A -&gt; B until C -&gt; D</td><td>A -&gt; (B until C) -&gt; D</td><td>The <tt class="literal">until</tt> operator has higher precedence then the <tt class="literal">followed-by</tt> operator.</td></tr><tr><td>[5] A or B </td><td>([5] A) or B</td><td>The <tt class="literal">[num]</tt> repeat operator has higher precedence then the <tt class="literal">or</tt> operator.</td></tr></tbody></table></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="pattern-filter"></a>5.4.&nbsp;Filter Expressions In Patterns</h2></div></div><div></div></div><a class="indexterm" name="d0e9174"></a><p>
			The simplest form of filter is a filter for events of a given type without any conditions on the event property values. This filter matches any event of that type regardless of the event's properties. The example below is such a filter. Note that this event pattern would stop firing as soon as the first RfidEvent is encountered.
		 </p><pre class="programlisting">com.mypackage.myevents.RfidEvent</pre><p>
			 To make the event pattern fire for every RfidEvent and not just the first event, use the <tt class="literal">every</tt> keyword.
		 </p><pre class="programlisting">every com.mypackage.myevents.RfidEvent</pre><p>
			 The example above specifies the fully-qualified Java class name as the event type. Via configuration, the event pattern above can be simplified by using the name
			 that has been defined for the event type.
		 </p><pre class="programlisting">every RfidEvent</pre><p>
			 Interfaces and superclasses are also supported as event types. In the below example <tt class="literal">IRfidReadable</tt> is an interface class, and the statement matches any event that implements this interface:
		 </p><pre class="programlisting">every org.myorg.rfid.IRfidReadable</pre><p>
			The filtering criteria to filter for events with certain event property values are placed within parenthesis after the event type name:
		 </p><pre class="programlisting">RfidEvent(category="Perishable")</pre><p>
			All expressions can be used in filters, including static method invocations that return a boolean value:
		 </p><pre class="programlisting">RfidEvent(com.mycompany.MyRFIDLib.isInRange(x, y) or (x&lt;0 and y &lt; 0))</pre><p>
			Filter expressions can be separated via a single comma '<tt class="literal">,</tt>'. The comma represents a logical AND between expressions:
		 </p><pre class="programlisting">RfidEvent(zone=1, category=10)
...is equivalent to...
RfidEvent(zone=1 and category=10)</pre><p>
			The following set of operators are highly optimized through indexing and are the preferred means of filtering high-volume event streams:
		</p><div class="itemizedlist"><ul type="disc" compact><li><p>
					equals <tt class="literal">=</tt>
				</p></li><li><p>
					not equals <tt class="literal">!=</tt>
				</p></li><li><p>
					comparison operators <tt class="literal">&lt; , &gt; , &gt;=, &lt;=</tt>
				</p></li><li><p>
					ranges 
				</p><div class="itemizedlist"><ul type="circle" compact><li><p>
							use the <tt class="literal">between</tt> keyword for a closed range where both endpoints are included
						</p></li><li><p>
							use the <tt class="literal">in </tt> keyword and round <tt class="literal">()</tt> or square brackets <tt class="literal">[]</tt> to control how endpoints are included
						</p></li><li><p>
							for inverted ranges use the <tt class="literal">not</tt> keyword and the <tt class="literal">between</tt> or <tt class="literal">in</tt> keywords
						</p></li></ul></div></li><li><p>
					list-of-values checks using the <tt class="literal">in</tt> keyword or the <tt class="literal">not in </tt> keywords followed by a comma-separated list of values
				</p></li></ul></div><p>
			At compile time as well as at run time, the engine scans new filter expressions for subexpressions that can be indexed. Indexing filter values to match event properties of incoming events enables the engine to match incoming events faster. The above list of operators represents the set of operators that the engine can best convert into indexes. The use of comma or logical <tt class="literal">and</tt> in filter expressions does not impact optimizations by the engine. 
		</p><p>
			For more information on filters please see <a href="#epl-from-clause-filter" title="4.4.1.&nbsp;Filter-based Event Streams">Section&nbsp;4.4.1, &#8220;Filter-based Event Streams&#8221;</a>. Contained-event selection on filters in patterns is further described in <a href="#epl-containedeventselect" title="4.20.&nbsp;Contained-Event Selection">Section&nbsp;4.20, &#8220;Contained-Event Selection&#8221;</a>.
		</p><p>
			Filter criteria can also refer to events matching prior named events in the same expression. Below pattern is an example in which the pattern
			matches once for every RfidEvent that is preceded by an RfidEvent with the same asset id.
		 </p><pre class="programlisting">every e1=RfidEvent -&gt; e2=RfidEvent(assetId=e1.assetId)</pre><p>
			The syntax shown above allows filter criteria to reference prior results by specifying the event name tag of the prior event, and the event property name. The tag names in the above example were <tt class="literal">e1</tt> and <tt class="literal">e2</tt>. This syntax can be used in all filter operators or expressions including ranges and the <tt class="literal">in</tt> set-of-values check:
		 </p><pre class="programlisting">every e1=RfidEvent -&gt; 
  e2=RfidEvent(MyLib.isInRadius(e1.x, e1.y, x, y) and zone in (1, e1.zone))</pre><p>
			An arriving event changes the truth value of all expressions that look for the event. Consider the pattern as follows:
		 </p><pre class="programlisting">every (RfidEvent(zone &gt; 1) and RfidEvent(zone &lt; 10))</pre><p>
			The pattern above is satisfied as soon as only one event with zone in the interval [2, 9] is received.
		 </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="pattern-operators"></a>5.5.&nbsp;Pattern Operators</h2></div></div><div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="pattern-logical-every"></a>5.5.1.&nbsp;Every</h3></div></div><div></div></div><a class="indexterm" name="d0e9320"></a><a class="indexterm" name="d0e9325"></a><p>				
				The <tt class="literal">every</tt> operator indicates that the pattern subexpression should restart when the subexpression qualified by the <tt class="literal">every</tt> keyword evaluates to true or false.
				Without the <tt class="literal">every</tt> operator the pattern subexpression stops when the pattern subexpression evaluates to true or false.
            </p><p>				
				As a side note, please be aware that a single invocation to the <tt class="literal">UpdateListener</tt> interface may deliver multiple events in one invocation, since the interface accepts an array of values.
            </p><p>
				Thus the <tt class="literal">every</tt> operator works like a factory for the pattern subexpression contained within. When the pattern subexpression within it fires and thus quits checking for events, the <tt class="literal">every</tt> causes the start of a new pattern subexpression listening for more occurrences of the same
				event or set of events.
            </p><p>
				Every time a pattern subexpression within an <tt class="literal">every</tt> operator turns true the engine starts a new active subexpression looking 
				for more event(s) or timing conditions that match the pattern subexpression. If the <tt class="literal">every</tt> operator is not specified for a subexpression, 
				the subexpression stops after the first match was found.
            </p><p>
				This pattern fires when encountering an A event and then stops looking.
            </p><pre class="programlisting">A</pre><p>
				This pattern keeps firing when encountering A events, and doesn't stop looking.
            </p><pre class="programlisting">every A</pre><p>
				When using <tt class="literal">every</tt> operator with the <tt class="literal">-&gt;</tt> followed-by operator, each time the <tt class="literal">every</tt> operator restarts it also starts a new subexpression instance looking for events in the followed-by subexpression.
            </p><p>
				Let's consider an example event sequence as follows.
            </p><p>
				A<sub>1</sub> &nbsp;
				B<sub>1</sub> &nbsp;  
				C<sub>1</sub> &nbsp;
				B<sub>2</sub>  &nbsp;
				A<sub>2</sub>  &nbsp;
				D<sub>1</sub>  &nbsp;
				A<sub>3</sub>  &nbsp;
				B<sub>3</sub>  &nbsp;
				E<sub>1</sub>  &nbsp;
				A<sub>4</sub>  &nbsp;
				F<sub>1</sub>  &nbsp;
				B<sub>4</sub> 
            </p><div class="table"><a name="pattern-every-samples"></a><p class="title"><b>Table&nbsp;5.4.&nbsp;'Every' operator examples</b></p><table summary="'Every' operator examples" border="1"><colgroup><col><col></colgroup><thead><tr><th>Example</th><th>Description</th></tr></thead><tbody><tr><td><pre class="programlisting">every ( A -&gt; B )</pre></td><td><p>
									Detect an A event followed by a B event. 
									At the time when B occurs the pattern matches, then the pattern matcher restarts and looks for the next A event.
								</p><div class="orderedlist"><ol type="1" compact><li><p>
											Matches on B<sub>1</sub> for combination {A<sub>1</sub>, B<sub>1</sub>}
										</p></li><li><p>
											Matches on B<sub>3</sub> for combination {A<sub>2</sub>, B<sub>3</sub>}
										</p></li><li><p>
											Matches on B<sub>4</sub> for combination {A<sub>4</sub>, B<sub>4</sub>}
										</p></li></ol></div></td></tr><tr><td><pre class="programlisting">every A -&gt; B</pre></td><td><p>
									The pattern fires for every A event followed by a B event.
								</p><div class="orderedlist"><ol type="1" compact><li><p>
											Matches on B<sub>1</sub> for combination {A<sub>1</sub>, B<sub>1</sub>}
										</p></li><li><p>
											Matches on B<sub>3</sub> for combination {A<sub>2</sub>, B<sub>3</sub>}
											and {A<sub>3</sub>, B<sub>3</sub>}
										</p></li><li><p>
											Matches on B<sub>4</sub> for combination {A<sub>4</sub>, B<sub>4</sub>}
										</p></li></ol></div></td></tr><tr><td><pre class="programlisting">A -&gt; every B</pre></td><td><p>
									The pattern fires for an A event followed by every B event.
								</p><div class="orderedlist"><ol type="1" compact><li><p>
											Matches on B<sub>1</sub> for combination {A<sub>1</sub>, B<sub>1</sub>}.
										</p></li><li><p>
											Matches on B<sub>2</sub> for combination {A<sub>1</sub>, B<sub>2</sub>}.
										</p></li><li><p>
											Matches on B<sub>3</sub> for combination {A<sub>1</sub>, B<sub>3</sub>}
										</p></li><li><p>
											Matches on B<sub>4</sub> for combination {A<sub>1</sub>, B<sub>4</sub>}
										</p></li></ol></div></td></tr><tr><td><pre class="programlisting">every A -&gt; every B</pre></td><td><p>
									The pattern fires for every A event followed by every B event.
								</p><div class="orderedlist"><ol type="1" compact><li><p>
											Matches on B<sub>1</sub> for combination {A<sub>1</sub>, B<sub>1</sub>}.
										</p></li><li><p>
											Matches on B<sub>2</sub> for combination {A<sub>1</sub>, B<sub>2</sub>}.
										</p></li><li><p>
											Matches on B<sub>3</sub> for combination {A<sub>1</sub>, B<sub>3</sub>}
											and {A<sub>2</sub>, B<sub>3</sub>} and {A<sub>3</sub>, B<sub>3</sub>}
										</p></li><li><p>
											Matches on B<sub>4</sub> for combination {A<sub>1</sub>, B<sub>4</sub>}
											and {A<sub>2</sub>, B<sub>4</sub>} and {A<sub>3</sub>, B<sub>4</sub>}
											and {A<sub>4</sub>, B<sub>4</sub>}
										</p></li></ol></div></td></tr></tbody></table></div><p>
				The examples show that it is possible that a pattern fires for multiple combinations of events that match a pattern expression.
				Each combination is posted as an <tt class="literal">EventBean</tt> instance to the <tt class="literal">update</tt> method in the <tt class="literal">UpdateListener</tt> implementation.
            </p><p>
				Let's consider the <tt class="literal">every</tt> operator in conjunction with a subexpression that matches 3 events that follow each other:
            </p><pre class="programlisting">every (A -&gt; B -&gt; C)</pre><p>
				The pattern first looks for A events. When an A event arrives, it looks for a B event. After the B event arrives, the pattern looks for a C event. Finally, when the C event arrives the pattern fires. The engine then starts looking for an A event again.
            </p><p>
				Assume that between the B event and the C event a second A<sub>2</sub> event arrives. The pattern would ignore the A<sub>2</sub> event entirely since it's then looking for a C event.
				As observed in the prior example, the <tt class="literal">every</tt> operator restarts the subexpression <tt class="literal">A -&gt; B -&gt; C</tt> only when the subexpression fires.
            </p><p>
				In the next statement the <tt class="literal">every</tt> operator applies only to the A event, not the whole subexpression:
            </p><pre class="programlisting">every A -&gt; B -&gt; C</pre><p>
				This pattern now matches for each A event that is followed by a B event and then a C event, regardless of when the A event arrives. Note that for each A event that arrives the pattern engine starts a new subexpression looking for a B event and then a C event, outputting each combination of matching events.
            </p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="pattern-every-ending-subexp"></a>5.5.1.1.&nbsp;Limiting Subexpression Lifetime</h4></div></div><div></div></div><p>
					As the introduction of the <tt class="literal">every</tt> operator states, the operator starts new subexpression instances and can cause multiple matches to occur for a single arriving event.
				</p><p>
					New subexpressions also take a very small amount of system resources and thereby your application should carefully consider when subexpressions must end when designing patterns. Use the <tt class="literal">timer:within</tt> construct and the <tt class="literal">and not</tt> constructs to end active subexpressions. The data window onto a pattern stream does not serve to limit pattern subexpression lifetime.
				</p><p>
					Lets look at a concrete example. Consider the following sequence of events arriving:
				</p><p>
					A<sub>1</sub> &nbsp;
					A<sub>2</sub> &nbsp;  
					B<sub>1</sub> &nbsp;
				</p><p>
					This pattern matches on arrival of B<sub>1</sub> and outputs two events (an array of length 2 if using a listener). The two events are the combinations {A<sub>1</sub>, B<sub>1</sub>} and {A<sub>2</sub>, B<sub>1</sub>}:
				</p><pre class="programlisting">every a=A -&gt; b=B</pre><p>
					The <tt class="literal">and not</tt> operators are used to end an active subexpression.
				</p><p>
					The next pattern matches on arrival of B<sub>1</sub> and outputs only the last A event which is the combination {A<sub>2</sub>, B<sub>1</sub>}:
				</p><pre class="programlisting">every a=A -&gt; (b=B and not A)</pre><p>
					The <tt class="literal">and not</tt> operators cause the subexpression looking for {A<sub>1</sub>, B?} to end when A<sub>2</sub> arrives.
				</p><p>
					Similarly, in the pattern below the engine starts a new subexpression looking for a B event every 1 second. After 5 seconds there are 5 subexpressions active looking for a B event and 5 matches occur at once if a B event arrives after 5 seconds.
				</p><pre class="programlisting">every timer:interval(1 sec) -&gt; b=B</pre><p>
					Again the <tt class="literal">and not</tt> operators can end subexpressions that are not intended to match any longer:
				</p><pre class="programlisting">every timer:interval(1 sec) -&gt; (b=B and not timer:interval(1 sec))
// equivalent to
every timer:interval(1 sec) -&gt; (b=B where timer:within(1 sec))</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="pattern-every-sample1"></a>5.5.1.2.&nbsp;<tt class="literal">Every</tt> Operator Example</h4></div></div><div></div></div><p>
					In this example we consider a generic pattern in which the pattern must match for each A event followed by a B event and followed by a C event, in which both the B event and the C event must arrive within 1 hour of the A event. The first approach to the pattern is as follows:
				</p><pre class="programlisting">every A  -&gt; (B -&gt; C) where timer:within(1 hour)</pre><p>
					Consider the following sequence of events arriving:
				</p><p>
					A<sub>1</sub> &nbsp;
					A<sub>2</sub> &nbsp;  
					B<sub>1</sub> &nbsp;
					C<sub>1</sub> &nbsp;  
					B<sub>2</sub> &nbsp;
					C<sub>2</sub>
				</p><p>
					First, the pattern as above never stops looking for A events since the <tt class="literal">every</tt> operator instructs the pattern to keep looking for A events.
				</p><p>
					When A<sub>1</sub> arrives, the pattern starts a new subexpression that keeps A<sub>1</sub> in memory and looks for any B event. At the same time, it also keeps looking for more A events. 
				</p><p>
					When A<sub>2</sub> arrives, the pattern starts a new subexpression that keeps A<sub>2</sub> in memory and looks for any B event. At the same time, it also keeps looking for more A events. 
				</p><p>
					After the arrival of A<sub>2</sub>, there are 3 subexpressions active:
				</p><div class="orderedlist"><ol type="1" compact><li><p>
							The first active subexpression with A<sub>1</sub> in memory, looking for any B event.
						</p></li><li><p>
							The second active subexpression with A<sub>2</sub> in memory, looking for any B event.
						</p></li><li><p>
							A third active subexpression, looking for the next A event.
						</p></li></ol></div><p>
					In the pattern above, we have specified a 1-hour lifetime for subexpressions looking for B and C events. Thus, if no B and no C event arrive within 1 hour after A<sub>1</sub>, the first subexpression goes away. If no B and no C event arrive within 1 hour after A<sub>2</sub>, the second subexpression goes away. The third subexpression however stays around looking for more A events.
				</p><p>
					The pattern as shown above thus matches on arrival of C<sub>1</sub> for combination {A<sub>1</sub>, B<sub>1</sub>, C<sub>1</sub>} and
					for combination {A<sub>2</sub>, B<sub>1</sub>, C<sub>1</sub>}, provided that B<sub>1</sub> and C<sub>1</sub> arrive within an hour of A<sub>1</sub> and A<sub>2</sub>.
				</p><p>
					You may now ask how to match on {A<sub>1</sub>, B<sub>1</sub>, C<sub>1</sub>} and {A<sub>2</sub>, B<sub>2</sub>, C<sub>2</sub>} instead, since 
					you may need to correlate on a given property.					
				</p><p>
					The pattern as discussed above matches every A event followed by the first B event followed by the next C event, and doesn't specifically qualify the B or C events to look for based on the A event.  To look for specific B and C events in relation to a given A event, the correlation must use one or more of the properties of the A event, such as the "id" property:
				</p><pre class="programlisting">every a=A -&gt; (B(id=a.id -&gt; C(id=a.id)) where timer:within(1 hour)</pre><p>
					The pattern as shown above thus matches on arrival of C<sub>1</sub> for combination {A<sub>1</sub>, B<sub>1</sub>, C<sub>1</sub>} and
					on arrival of C<sub>2</sub> for combination {A<sub>2</sub>, B<sub>2</sub>, C<sub>2</sub>}.
				</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="pattern-every-sample2"></a>5.5.1.3.&nbsp;Sensor Example</h4></div></div><div></div></div><p>
					This example looks at temperature sensor events named Sample. The pattern detects when 3 sensor events indicate a temperature of more then 50 degrees uninterrupted within 90 seconds of the first event, considering events for the same sensor only.
				</p><pre class="programlisting">every sample=Sample(temp &gt; 50) -&gt;
( (Sample(sensor=sample.sensor, temp &gt; 50) and not Sample(sensor=sample.sensor, temp &lt;= 50))   
  -&gt;
  (Sample(sensor=sample.sensor, temp &gt; 50) and not Sample(sensor=sample.sensor, temp &lt;= 50))   
 ) where timer:within(90 seconds))</pre><p>
					The pattern starts a new subexpression in the round braces after the first followed-by operator for each time a sensor indicated more then 50 degrees. Each subexpression then lives a maximum of 90 seconds. Each subexpression ends if a temperature of 50 degress or less is encountered for the same sensor. Only if 3 temperature events in a row indicate more then 50 degrees, and within 90 seconds of the first event, and for the same sensor, does this pattern fire.
				</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="pattern-logical-everydistinct"></a>5.5.2.&nbsp;Every-Distinct</h3></div></div><div></div></div><a class="indexterm" name="d0e9979"></a><a class="indexterm" name="d0e9984"></a><p>				
				Similar to the <tt class="literal">every</tt> operator in most aspects, the <tt class="literal">every-distinct</tt> operator indicates that the pattern subexpression should restart when the subexpression qualified by the <tt class="literal">every-distinct</tt> keyword evaluates to true or false. In addition, the <tt class="literal">every-distinct</tt> eliminates duplicate results received from an active subexpression according to its distinct-value expressions.
            </p><p>
				The synopsis for the <tt class="literal">every-distinct</tt> pattern operator is:
            </p><pre class="synopsis">every-distinct(<span class="emphasis"><em>distinct_value_expr </em></span>[, <span class="emphasis"><em>distinct_value_exp</em></span>[...]])</pre><p>
				Within parenthesis are one or more <span class="emphasis"><em>distinct_value_expr</em></span> expressions that return the values by which to remove duplicates.
            </p><p>
				When specifying properties in the distinct-value expression list, you must ensure that the event types providing properties are tagged. Only properties of event types within filter expressions that are sub-expressions to the <tt class="literal">every-distinct</tt> may be specified.
            </p><p>
				For example, this pattern keeps firing for every A event with a distinct value for its <tt class="literal">aprop</tt> property:
            </p><pre class="programlisting">every-distinct(a.aprop) a=A</pre><p>
				Note that the pattern above assigns the <tt class="literal">a</tt> tag to the A event and uses <tt class="literal">a.prop</tt> to identify the <tt class="literal">prop</tt> property as a value of the <tt class="literal">a</tt> event  A.
            </p><p>
				A pattern that returns the first Sample event for each sensor, assuming sensor is a field that returns a unique id identifying the sensor that originated the Sample event, is:
            </p><pre class="programlisting">every-distinct(s.sensor) s=Sample</pre><p>
				The next pattern looks for pairs of A and B events and returns only the first pair for each combination of <tt class="literal">aprop</tt> of an A event and <tt class="literal">bprop</tt> of a B event:
            </p><pre class="programlisting">every-distinct(a.aprop, b.bprop) (a=A and b=B)</pre><p>
				The following pattern looks for A events followed by B events for which the value of the <tt class="literal">aprop</tt> of an A event is the same value of the <tt class="literal">bprop</tt> of a B event but only for each distinct value of <tt class="literal">aprop</tt> of an A event:
            </p><pre class="programlisting">every-distinct(a.aprop) a=A -&gt; b=B(bprop = a.aprop)</pre><p>
				When specifying properties as part of distinct-value expressions, properties must be available from tagged event types in sub-expressions to the <tt class="literal">every-distinct</tt>.
            </p><p>
				The following patterns are not valid:
            </p><pre class="programlisting">// Invalid: event type in filter not tagged
every-distinct(aprop) A
			
// Invalid: property not from a sub-expression of every-distinct
a=A -&gt; every-distinct(a.aprop) b=B</pre><p>
				When an active subexpression to <tt class="literal">every-distinct</tt> becomes permanently false, the distinct-values seen from the active subexpression are removed.
            </p><p>
				For example, the below pattern detects each A event distinct by the value of <tt class="literal">aprop</tt>.
            </p><pre class="programlisting">every-distinct(a.aprop) (a=A  and not B)</pre><p>
				In the pattern above, when a B event arrives, the subexpression becomes permanently false and is restarted anew, detecting each A event distinct by the value of <tt class="literal">aprop</tt> without considering prior values.
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="pattern-repeat"></a>5.5.3.&nbsp;Repeat</h3></div></div><div></div></div><p>
			   The repeat operator fires when a pattern subexpression evaluates to true a given number of times. The synopsis is as follows:
		   </p><pre class="synopsis">[<span class="emphasis"><em>match_count</em></span>] <span class="emphasis"><em>repeating_subexpr</em></span></pre><p>
			   The repeat operator is very similar to the <tt class="literal">every</tt> operator in that it restarts the <span class="emphasis"><em>repeating_subexpr</em></span> pattern subexpression up to a given number of times.
		   </p><p>
			   <span class="emphasis"><em>match_count</em></span> is a positive number that specifies how often the <span class="emphasis"><em>repeating_subexpr</em></span> pattern subexpression must evaluate to true before the repeat expression itself evaluates to true.
		   </p><p>
			   For example, this pattern fires when the last of five A events arrives:
		   </p><pre class="programlisting">[5] A</pre><p>
			   Parenthesis must be used for nested pattern subexpressions. This pattern fires when the last of a total of any five A or B events arrives:
		   </p><pre class="programlisting">[5] (A or B)</pre><p>
			   Without parenthesis the pattern semantics change, according to the operator precedence described earlier. This pattern fires when the last of a total of five A events arrives or a single B event arrives, whichever happens first:
		   </p><pre class="programlisting">[5] A or B</pre><p>
			   Tags can be used to name events in filter expression of pattern subexpressions. The next pattern looks for an A event followed by a B event, and a second A event followed by a second B event. The output event provides indexed and array properties of the same name:
		   </p><pre class="programlisting">[2] (a=A -&gt; b=B)</pre><p>
			   Using tags with repeat is further described in <a href="#pattern-repeat-tags" title="5.5.4.6.&nbsp;Tags and the Repeat Operator">Section&nbsp;5.5.4.6, &#8220;Tags and the Repeat Operator&#8221;</a>.
		   </p><p>
			   Consider the following pattern that demonstrates the behavior when a pattern subexpression becomes permanently false:
		   </p><pre class="programlisting">[2] (A and not C)</pre><p>
			   In the case where a C event arrives before 2 A events arrive, the pattern above becomes permanently false.
		   </p><p>
			   Lets add an <tt class="literal">every</tt> operator to restart the pattern and thus keep matching for all pairs of A events that arrive without a C event in between each pair:
		   </p><pre class="programlisting">every [2] (A and not C)</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="pattern-repeatuntil"></a>5.5.4.&nbsp;Repeat-Until</h3></div></div><div></div></div><p>
			   The repeat <tt class="literal">until</tt> operator provides additional control over repeated matching.
		   </p><p>
			   The repeat until operator takes an optional range, a pattern subexpression to repeat, the <tt class="literal">until</tt> keyword and a second pattern subexpression that ends the repetition. The synopsis is as follows:
		   </p><pre class="synopsis">[<span class="emphasis"><em>range</em></span>] <span class="emphasis"><em>repeated_pattern_expr</em></span> until <span class="emphasis"><em>end_pattern_expr</em></span></pre><p>
				Without a <span class="emphasis"><em>range</em></span>, the engine matches the <span class="emphasis"><em>repeated_pattern_expr</em></span> pattern subexpression until the <span class="emphasis"><em>end_pattern_expr</em></span> evaluates to true, at which time the expression turns true.
			</p><p>
				An optional <span class="emphasis"><em>range</em></span> can be used to indicate the minimum number of times that the <span class="emphasis"><em>repeated_pattern_expr</em></span> pattern subexpression must become true.
			</p><p>
				The optional <span class="emphasis"><em>range</em></span> can also specify a maximum number of times that <span class="emphasis"><em>repeated_pattern_expr</em></span> pattern subexpression evaluates to true and retains tagged events. When this number is reached, the engine stops the <span class="emphasis"><em>repeated_pattern_expr</em></span> pattern subexpression.
			</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="pattern-repeatuntil-norange"></a>5.5.4.1.&nbsp;Unbound Repeat</h4></div></div><div></div></div><p>
				In the unbound repeat, without a <span class="emphasis"><em>range</em></span>, the engine matches the <span class="emphasis"><em>repeated_pattern_expr</em></span> pattern subexpression until the <span class="emphasis"><em>end_pattern_expr</em></span> evaluates to true, at which time the expression turns true. The synopsis is:
			</p><pre class="synopsis"><span class="emphasis"><em>repeated_pattern_expr</em></span> until <span class="emphasis"><em>end_pattern_expr</em></span></pre><p>
				   This is a pattern that keeps looking for A events until a B event arrives:
			   </p><pre class="programlisting">A until B</pre><p>
				   Nested pattern subexpressions must be placed in parenthesis since the <tt class="literal">until</tt> operator has precedence over most operators. This example collects all A or B events for 10 seconds and places events received in indexed properties 'a' and 'b':
			   </p><pre class="programlisting">(a=A or b=B) until timer:interval(10 sec)</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="pattern-repeatuntil-range"></a>5.5.4.2.&nbsp;Bound Repeat Overview</h4></div></div><div></div></div><p>
				   The synopsis for the optional <span class="emphasis"><em>range</em></span> qualifier is:
			   </p><pre class="synopsis">[ [<span class="emphasis"><em>low_endpoint</em></span>] .. [<span class="emphasis"><em>high_endpoint</em></span>] ]</pre><p>
				   <span class="emphasis"><em>low_endpoint</em></span> is an optional number that appears on the left of two dots (..), after which follows an optional <span class="emphasis"><em>high_endpoint</em></span> number.
			   </p><p>
				   A range thus consists of a <span class="emphasis"><em>low_endpoint</em></span> and a <span class="emphasis"><em>high_endpoint</em></span> in square brackets and separated by dot (.) characters. Both endpoint values are optional but either one or both must be supplied. The <span class="emphasis"><em>low_endpoint</em></span> can be omitted to denote a range that starts at zero. The <span class="emphasis"><em>high_endpoint</em></span> can be omitted to denote an open-ended range.
			   </p><p>
				   Some examples for valid ranges might be:
			   </p><pre class="programlisting">[3..10]
[..3]    // range starts at zero
[2..]    // open-ended range</pre><p>
				   The <span class="emphasis"><em>low_endpoint</em></span>, if specified, defines the minimum number of times that the <span class="emphasis"><em>repeated_pattern_expr</em></span> pattern subexpression must become true in order for the expression to become true.
			   </p><p>
				   The <span class="emphasis"><em>high_endpoint</em></span>, if specified, is the maximum number of times that the <span class="emphasis"><em>repeated_pattern_expr</em></span> pattern subexpression becomes true. If the number is reached, the engine stops the <span class="emphasis"><em>repeated_pattern_expr</em></span> pattern subexpression.
			   </p><p>
				   In all cases, only at the time that the <span class="emphasis"><em>end_pattern_expr</em></span> pattern subexpression evaluates to true does the expression become true. If <span class="emphasis"><em>end_pattern_expr</em></span> pattern subexpression evaluates to false, then the expression evaluates to false.
			   </p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="pattern-repeatuntil-range-openended"></a>5.5.4.3.&nbsp;Bound Repeat - Open Ended Range</h4></div></div><div></div></div><p>
				   An open-ended range specifies only a low endpoint and not a high endpoint.
			   </p><p>
				   Consider the following pattern which requires at least three A events to match:
			   </p><pre class="programlisting">[3..] A until B</pre><p>
				   In the pattern above, if a B event arrives before 3 A events occurred, the expression ends and evaluates to false. 
			   </p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="pattern-repeatuntil-range-nolow"></a>5.5.4.4.&nbsp;Bound Repeat - High Endpoint Range</h4></div></div><div></div></div><p>
				   A high-endpoint range specifies only a high endpoint and not a low endpoint.
			   </p><p>
				   In this sample pattern the engine will be looking for a maximum of 3 A events. The expression turns true as soon as a single B event arrives regardless of the number of A events received:
			   </p><pre class="programlisting">[..3] A until B</pre><p>
				   The next pattern matches when a C or D event arrives, regardless of the number of A or B events that occurred:
			   </p><pre class="programlisting">[..3] (a=A or b=B) until (c=C or d=D)</pre><p>
				   In the pattern above, if more then 3 A or B events arrive, the pattern stops looking for additional A or B events. The 'a' and 'b' tags retain only the first 3 (combined) matches among A and B events. The output event contains these tagged events as indexed properties.
			   </p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="pattern-repeatuntil-range-bounded"></a>5.5.4.5.&nbsp;Bound Repeat - Bounded Range</h4></div></div><div></div></div><p>
				   A bounded range specifies a low endpoint and a high endpoint.
			   </p><p>
				   The next pattern matches after at least one A event arrives upon the arrival of a single B event:
			   </p><pre class="programlisting">[1..3] a=A until B</pre><p>
				   If a B event arrives before the first A event, then the pattern does not match. Only the first 3 A events are returned by the pattern.
			   </p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="pattern-repeat-tags"></a>5.5.4.6.&nbsp;Tags and the Repeat Operator</h4></div></div><div></div></div><p>
				   The tags assigned to events in filter subexpressions within a repeat operator are available for use in filter expressions and also in any EPL clause.
			   </p><p>
					This sample pattern matches 2 A events followed by a B event. Note the filter on B events: only a B event that has a value for the "beta" property that equals any of the "id" property values of the two A events is considered:
			   </p><pre class="programlisting">[2] A -&gt; B(beta in (a[0].id, a[1].id))</pre><p>
					The next EPL statement returns pairs of A events:
			   </p><pre class="programlisting">select a, a[0], a[0].id, a[1], a[1].id
from pattern [ every [2] a=A ] </pre><p>
					The <tt class="literal">select</tt> clause of the statement above showcases different ways of accessing tagged events:
			   </p><div class="itemizedlist"><ul type="disc"><li><p>
							The tag itself can be used to select an array of underlying events. For example, the 'a' expression above returns an array of underlying events of event type A.
						</p></li><li><p>
							The tag as an indexed property returns the underlying event at that index. For instance, the 'a[0]' expression returns the first underlying A event, or null if no such A event was matched by the repeat operator.
						</p></li><li><p>
							The tag as a nested, indexed property returns a property of the underlying event at that index. For example, the 'a[1].id' expression returns the 'id' property value of the second A event, or null if no such second A event was matched by the repeat operator.
						</p></li></ul></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="pattern-logical-and"></a>5.5.5.&nbsp;And</h3></div></div><div></div></div><a class="indexterm" name="d0e10382"></a><a class="indexterm" name="d0e10387"></a><p>
				Similar to the Java &amp;&amp; operator the <tt class="literal">and</tt> operator requires both nested pattern expressions to turn 
				true before the whole expression turns true (a join pattern).
            </p><p>
				This pattern matches when both an A event and a B event arrive, at the time the last of the two events arrive:
            </p><pre class="programlisting">A and B</pre><p>
				This pattern matches on any sequence of an A event followed by a B event and then a C event followed by a D event, or a C event followed by a D and an A event followed by a B event:
            </p><pre class="programlisting">(A -&gt; B) and (C -&gt; D)</pre><p>
				Note that in an <tt class="literal">and</tt> pattern expression it is not possible to correlate events based on event property values. For example, this is an invalid pattern:
            </p><pre class="programlisting">// This is NOT valid
a=A and B(id = a.id)</pre><p>
				The above expression is invalid as it relies on the order of arrival of events, however in an <tt class="literal">and</tt> expression the order of events is not specified and events fulfill an <tt class="literal">and</tt> condition in any order. The above expression can be changed to use the followed-by operator: 
            </p><pre class="programlisting">// This is valid
a=A -&gt; B(id = a.id)
// another example using 'and'...
a=A -&gt; (B(id = a.id) and C(id = a.id))</pre><p>
				Consider a pattern that looks for the same event:
            </p><pre class="programlisting">A and A</pre><p>
				The pattern above fires when a single A event arrives. The first arriving A event triggers a state transition in both the left and the right hand side expression.
            </p><p>
				In order to match after two A events arrive in any order, there are two options to express this pattern. The followed-by operator is one option and the repeat operator is the second option, as the next two patterns show:
            </p><pre class="programlisting">A -&gt; A
// ... or ...
[2] A</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="pattern-logical-or"></a>5.5.6.&nbsp;Or</h3></div></div><div></div></div><a class="indexterm" name="d0e10435"></a><a class="indexterm" name="d0e10440"></a><p>
				Similar to the Java &#8220;||&#8221; operator the <tt class="literal">or</tt> operator requires either one of the expressions 
				to turn true before the whole expression turns true.
            </p><p>
			   Look for either an A event or a B event. As always, A and B can itself be nested expressions as well.
            </p><pre class="programlisting">A or B</pre><p>
				Detect all stock ticks that are either above or below a threshold.
            </p><pre class="programlisting">every (StockTick(symbol='IBM', price &lt; 100) or StockTick(symbol='IBM', price &gt; 105)</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="pattern-logical-not"></a>5.5.7.&nbsp;Not</h3></div></div><div></div></div><a class="indexterm" name="d0e10461"></a><a class="indexterm" name="d0e10466"></a><p>
				The <tt class="literal">not</tt> operator negates the truth value of an expression. Pattern expressions prefixed with <tt class="literal">not</tt> are automatically 
				defaulted to true upon start, and turn permanently false when the expression within turns true.
            </p><p>
				The <tt class="literal">not</tt> operator is generally used in conjunction with the <tt class="literal">and</tt> operator or subexpressions as the below examples show.
            </p><p>
				This pattern matches only when an A event is encountered followed by a B event but only if no C event was encountered before either an A event and a B event, counting from the time the pattern is started:
            </p><pre class="programlisting">(A -&gt; B) and not C</pre><p>
				Assume we'd like to detect when an A event is followed by a D event, without any B or C events between the A and D events:
            </p><pre class="programlisting">A -&gt; (D and not (B or C))</pre><p>
				It may help your understanding to discuss a pattern that uses the <tt class="literal">or</tt> operator and the <tt class="literal">not</tt> operator together:				
            </p><pre class="programlisting">a=A -&gt; (b=B or not C)</pre><p>
				In the pattern above, when an A event arrives then the engine starts the subexpression <tt class="literal">B or not C</tt>. As soon as the subexpression starts, the <tt class="literal">not</tt> operator turns to true. The <tt class="literal">or</tt> expression turns true and thus your listener receives an invocation providing the A event in the property 'a'. The subexpression does not end and continues listening for B and C events. Upon arrival of a B event your listener receives a second invocation. If instead a C event arrives, the <tt class="literal">not</tt> turns permanently false however that does not affect the <tt class="literal">or</tt> operator (but would end an <tt class="literal">and</tt> operator).
            </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="pattern-temporal-followed-by"></a>5.5.8.&nbsp;Followed-by</h3></div></div><div></div></div><a class="indexterm" name="d0e10528"></a><a class="indexterm" name="d0e10533"></a><a class="indexterm" name="d0e10538"></a><p>
				The followed by <tt class="literal">-&gt;</tt> operator specifies that first the left hand expression must turn true and only 
				then is the right hand expression evaluated for matching events.
            </p><p>
				Look for an A event and if encountered, look for a B event. As always, A and B can itself be nested event pattern expressions.
            </p><pre class="programlisting">A -&gt; B</pre><p>
				This is a pattern that fires when 2 status events indicating an error occur one after the other.
            </p><pre class="programlisting">StatusEvent(status='ERROR') -&gt; StatusEvent(status='ERROR')</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="pattern-guards"></a>5.5.9.&nbsp;Pattern Guards</h3></div></div><div></div></div><a class="indexterm" name="d0e10559"></a><p>
				Guards are where-conditions that control the lifecycle of subexpressions. Custom guard functions can also be used. The section <a href="#extension" title="Chapter&nbsp;11.&nbsp;Extension and Plug-in">Chapter&nbsp;11, <i>Extension and Plug-in</i></a> outlines guard plug-in development in greater detail.
			</p><p>
				The pattern guard where-condition has no relationship to the EPL <tt class="literal">where</tt> clause that filters sets of events.
			</p><p>
				Take as an example the following pattern expression:
			</p><pre class="programlisting">MyEvent where timer.within(10 sec)</pre><p>
				In this pattern the <tt class="literal">timer:within</tt> guard controls the subexpression that is looking for MyEvent events. The guard terminates the subexpression looking for MyEvent events after 10 seconds after start of the pattern. Thus the pattern alerts only once when the first MyEvent event arrives within 10 seconds after start of the pattern.
			</p><p>
				The <tt class="literal">every</tt> keyword requires additional discussion since it also controls subexpression lifecycle. Let's add the <tt class="literal">every</tt> keyword to the example pattern:
			</p><pre class="programlisting">every MyEvent where timer.within(10 sec)</pre><p>
				The difference to the pattern without <tt class="literal">every</tt> is that each MyEvent event that arrives now starts a new subexpression, including a new guard, looking for a further MyEvent event. The result is that, when a MyEvent arrives within 10 seconds after pattern start, the pattern execution will look for the next MyEvent event to arrive within 10 seconds after the previous one.
			</p><p>
				By placing parentheses around the <tt class="literal">every</tt> keyword and its subexpression, we can have the <tt class="literal">every</tt> under the control of the guard:
			</p><pre class="programlisting">(every MyEvent) where timer.within(10 sec)</pre><p>
				In the pattern above, the guard terminates the subexpression looking for all MyEvent events after 10 seconds after start of the pattern. This pattern alerts for all MyEvent events arriving within 10 seconds after pattern start, and then stops.
			</p><p>
				Guards do not change the truth value of the subexpression of which the guard controls the lifecycle, and therefore do not cause a restart of the subexpression when used with the <tt class="literal">every</tt> operator. For example, the next pattern stops returning matches after 10 seconds unless a match occurred within 10 seconds after pattern start:
			</p><pre class="programlisting">every ( (A and B) where timer.within(10 sec) )</pre><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="pattern-timer-within"></a>5.5.9.1.&nbsp;timer:within</h4></div></div><div></div></div><a class="indexterm" name="d0e10617"></a><a class="indexterm" name="d0e10622"></a><p>
					The <tt class="literal">timer:within</tt> guard acts like a stopwatch. 
					If the associated pattern expression does not turn true within the specified time period it is stopped and permanently false.					
				</p><p>
					The <tt class="literal">timer:within</tt> guard takes a time period (see <a href="#epl-syntax-time-periods" title="4.2.1.&nbsp;Specifying Time Periods">Section&nbsp;4.2.1, &#8220;Specifying Time Periods&#8221;</a>) or an expression providing a number of seconds as a parameter. The seconds interval expression may
					contain references to properties of prior events in the same pattern as well as variables and substitution parameters.
				</p><p>
					This pattern fires if an A event arrives within 5 seconds after statement creation.
				</p><pre class="programlisting">A where timer:within (5 seconds)</pre><p>
					This pattern fires for all A events that arrive within 5 seconds. After 5 seconds, this pattern stops matching even if more A events arrive.
				</p><pre class="programlisting">(every A) where timer:within (5 seconds)</pre><p>
					This pattern is similar to the first pattern but here every time A arrives within 5 seconds, the pattern begins looking for A for another 5 seconds. As long
					as A events arrive within 5 seconds after the last A, the pattern does not stop matching.
				</p><pre class="programlisting">every (A where timer:within (5 sec))</pre><p>
					This pattern matches for any one A or B event in the next 5 seconds.
				</p><pre class="programlisting">( A or B ) where timer:within (5 sec)</pre><p>
					This pattern matches for any 2 errors that happen 10 seconds within each other.
				</p><pre class="programlisting">every (StatusEvent(status='ERROR') -&gt; StatusEvent(status='ERROR') where timer:within (10 sec))</pre><p>
					The following guards are equivalent:
				</p><pre class="programlisting">timer:within(2 minutes 5 seconds)
timer:within(125 sec)
timer:within(125)</pre><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="pattern-timer-within-parameterized"></a>5.5.9.1.1.&nbsp;Time interval expressions</h5></div></div><div></div></div><p>
						The <tt class="literal">timer:within</tt> guard may be parameterized by an expression that contains one or more references to properties of prior events in the same pattern.
					</p><p>
						As a simple example, this pattern matches every A event followed by a B event that arrives within <tt class="literal">delta</tt> seconds after the A event: 
					</p><pre class="programlisting">every a=A -&gt; b=B where timer:within (a.delta seconds)</pre><p>
						Herein A event is assumed to have a <tt class="literal">delta</tt> property that provides the number of seconds to wait for B events. Each arriving A event may have a different value for <tt class="literal">delta</tt>
						and the guard is therefore parameterized dynamically based on the prior A event received.
					</p><p>
						When multiple events accumulate, for example when using the match-until or repeat pattern elements, an index must be provided:
					</p><pre class="programlisting">[2] a=A -&gt; b=B where timer:within (a[0].delta + a[1].delta)</pre><p>
						The above pattern matches after 2 A events arrive followed by a B event within a time interval after the A event that is defined by the sum of the <tt class="literal">delta</tt> properties of both A events.
					</p></div></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="pattern-atoms"></a>5.6.&nbsp;Pattern Atoms</h2></div></div><div></div></div><a class="indexterm" name="d0e10698"></a><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="pattern-atom-filter"></a>5.6.1.&nbsp;Filter Atoms</h3></div></div><div></div></div><p>
				Filter atoms have been described in section <a href="#pattern-filter" title="5.4.&nbsp;Filter Expressions In Patterns">Section&nbsp;5.4, &#8220;Filter Expressions In Patterns&#8221;</a>.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="pattern-atom-time"></a>5.6.2.&nbsp;Time-based Observer Atoms</h3></div></div><div></div></div><p>
				Observers observe time-based events for which the thread-of-control originates by the engine timer or external timer event. Custom observers can also be developed that observe timer events or other engine-external application events such as a file-exists check. The section <a href="#extension" title="Chapter&nbsp;11.&nbsp;Extension and Plug-in">Chapter&nbsp;11, <i>Extension and Plug-in</i></a> outlines observer plug-in development in greater detail.
			</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="pattern-timer-interval"></a>5.6.2.1.&nbsp;timer:interval</h4></div></div><div></div></div><a class="indexterm" name="d0e10718"></a><a class="indexterm" name="d0e10723"></a><p>
					The <tt class="literal">timer:interval</tt> observer waits for the defined time before the truth value of the observer turns true.
					The observer takes a time period (see <a href="#epl-syntax-time-periods" title="4.2.1.&nbsp;Specifying Time Periods">Section&nbsp;4.2.1, &#8220;Specifying Time Periods&#8221;</a>) as a parameter, or an expression that returns the number of seconds.
				</p><p>
					The observer may be parameterized by an expression that contains one or more references to properties of prior events in the same pattern, or may also reference variables, substitution parameters or any other expression returning 
					a numeric value.
				</p><p>
					After an A event arrived wait 10 seconds then indicate that the pattern matches.
				</p><pre class="programlisting">A -&gt; timer:interval(10 seconds) </pre><p>
					The pattern below fires every 20 seconds.
				</p><pre class="programlisting">every timer:interval(20 sec)</pre><p>
					The next example pattern fires for every A event that is not followed by a B event within 60 seconds after the A event arrived. The B event must have the same "id" property
					value as the A event.
				</p><pre class="programlisting">every a=A -&gt; (timer:interval(60 sec) and not B(id=a.id)) </pre><p>
					Consider the next example, which assumes that the A event has a property <tt class="literal">waittime</tt>:
				</p><pre class="programlisting">every a=A -&gt; (timer:interval(a.waittime + 2) and not B(id=a.id))</pre><p>
					In the above pattern the logic waits for 2 seconds plus the number of seconds provided by the value of the <tt class="literal">waittime</tt> property of the A event.
				</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="pattern-timer-at"></a>5.6.2.2.&nbsp;timer:at</h4></div></div><div></div></div><a class="indexterm" name="d0e10764"></a><a class="indexterm" name="d0e10769"></a><p>
					The <tt class="literal">timer:at</tt> observer is similar in function to the Unix &#8220;crontab&#8221; command. At a specified time the 
					expression turns true. The <tt class="literal">at</tt> operator can also be made to pattern match at regular intervals by using an <tt class="literal">every</tt> operator 
					in front of the <tt class="literal">timer:at</tt> operator. 
				</p><p>
					The syntax is: <tt class="literal">timer:at (minutes, hours, days of month, months, days of week [, seconds]).</tt>
				</p><p>
					The value for seconds is optional. Each element allows wildcard <tt class="literal">*</tt> values. Ranges can be specified 
					by means of lower bounds then a colon &#8216;:&#8217; then the upper bound. The division operator <tt class="literal">*/x</tt> can be used to 
					specify that every x<sub>th</sub> value is valid. Combinations of these operators can be used by placing these into square brackets([]).
				</p><p>
					The <tt class="literal">timer:at</tt> observer may also be parameterized by an expression that contains one or more references to properties of prior events in the same pattern, or may also reference variables, substitution parameters or any other expression returning a numeric value. The frequency division operator <tt class="literal">*/x</tt> and parameters lists within brackets([]) are an exception: they may only contain variables, substitution parameters or numeric values.
				</p><p>
					This expression pattern matches every 5 minutes past the hour.
				</p><pre class="programlisting">every timer:at(5, *, *, *, *)</pre><p>
					The below <tt class="literal">timer:at</tt> pattern matches every 15 minutes from 8am to 5:45pm (hours 8 to 17 at 0, 15, 30 and 45 minutes past the hour) on even numbered days of the month as well as on the 
					first day of the month.
				</p><pre class="programlisting">timer:at (*/15, 8:17, [*/2, 1], *, *)</pre><p>
					The below table outlines the fields, valid values and keywords available for each field:
				</p><div class="table"><a name="d0e10825"></a><p class="title"><b>Table&nbsp;5.5.&nbsp;Properties offered by sample statement aggregating price</b></p><table summary="Properties offered by sample statement aggregating price" border="1"><colgroup><col><col><col><col></colgroup><thead><tr><th>Field Name</th><th>Mandatory?</th><th>Allowed Values</th><th>Additional Keywords</th></tr></thead><tbody><tr><td>Minutes</td><td>yes</td><td>0 - 59</td><td>&nbsp;</td></tr><tr><td>Hours</td><td>yes</td><td>0 - 23</td><td>&nbsp;</td></tr><tr><td>Days Of Month</td><td>yes</td><td>1 - 31</td><td>last, weekday, lastweekday</td></tr><tr><td>Months</td><td>yes</td><td>1 - 12</td><td>&nbsp;</td></tr><tr><td>Days Of Week</td><td>yes</td><td>0 (Sunday) - 6 (Saturday)</td><td>last</td></tr><tr><td>Seconds</td><td>no</td><td>0 - 59</td><td>&nbsp;</td></tr></tbody></table></div><p>
					The keyword <tt class="literal">last</tt> used in the days-of-month field means the last day of the month (current month). To specify the last day of another month, a value for the month field has to be provided. For example: <tt class="literal">timer:at(*, *, last,2,*)</tt> is the last day of February. 
				</p><p>
					The <tt class="literal">last</tt> keyword in the day-of-week field by itself simply means Saturday. If used in the day-of-week field after another value, it means "the last xxx day of the month" - for example "5 last" means "the last friday of the month". 
					So the last Friday of the current month will be: <tt class="literal">timer:at(*, *, *, *, 5 last)</tt>. And the last Friday of June: <tt class="literal">timer:at(*, *, *, 6, 5 last)</tt>.
				</p><p>
					The keyword <tt class="literal">weekday</tt> is used to specify the weekday (Monday-Friday) nearest the given day. Variant could include month like in: <tt class="literal">timer:at(*, *, 30 weekday, 9, *)</tt> which is Friday September 28th (no jump over month).
				</p><p>
					The keyword <tt class="literal">lastweekday</tt> is a combination of two parameters, the <tt class="literal">last</tt> and the <tt class="literal">weekday</tt> keywords. A typical example could be: <tt class="literal">timer:at(*, *, *, lastweekday, 9, *)</tt> which will define Friday September 28th (example year is 2007).
				</p><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="pattern-timer-at-every"></a>5.6.2.2.1.&nbsp;timer:at and the <tt class="literal">every</tt> Operator</h5></div></div><div></div></div><p>
						When using <tt class="literal">timer:at</tt> with the <tt class="literal">every</tt> operator the crontab-like timer computes the next time at which the timer should fire based on the specification and the current time. When using <tt class="literal">every</tt>, the current time is the time the timer fired or the statement start time if the timer has not fired once.
					</p><p>
						For example, this pattern fires every 1 minute starting at 1:00pm and ending at 1:59pm, every day:
					</p><pre class="programlisting">every timer:at(*, 13, *, *, *)</pre><p>
						Assume the above statement gets started at 1:05pm and 20 seconds. In such case the above pattern fires every 1 minute starting at 1:06pm and ending at 1:59pm for that day and 1:00pm to 1:59pm every following day.
					</p><p>
						To get the pattern to fire only once at 1pm every day, explicitly specify the minute to start. The pattern below fires every day at 1:00pm:
					</p><pre class="programlisting">every timer:at(0, 13, *, *, *)</pre><p>
						By specifying a second resolution the timer can be made to fire every second, for instance:
					</p><pre class="programlisting">every timer:at(*, *, *, *, *, *)</pre></div></div></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="epl-operator"></a>Chapter&nbsp;6.&nbsp;EPL Reference: Operators</h2></div></div><div></div></div><p>
			Esper arithmetic and logical operator precedence follows Java standard arithmetic and logical operator precedence.
		</p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="epl-operator-ref-arithmetic"></a>6.1.&nbsp;Arithmetic Operators</h2></div></div><div></div></div><a class="indexterm" name="d0e10974"></a><a class="indexterm" name="d0e10977"></a><p>
				The below table outlines the arithmetic operators available.
			</p><div class="table"><a name="epl-arith-operators"></a><p class="title"><b>Table&nbsp;6.1.&nbsp;Syntax and results of arithmetic operators</b></p><table summary="Syntax and results of arithmetic operators" border="1"><colgroup><col><col></colgroup><thead><tr><th>Operator</th><th>Description</th></tr></thead><tbody><tr><td>+, -</td><td><p>As unary operators they denote a positive or negative expression. As binary operators they add or subtract.</p></td></tr><tr><td>*, /</td><td><p>Multiplication and division are binary operators.</p></td></tr><tr><td>%</td><td><p>Modulo binary operator.</p></td></tr></tbody></table></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="epl-operator-ref-logical"></a>6.2.&nbsp;Logical And Comparsion Operators</h2></div></div><div></div></div><a class="indexterm" name="d0e11018"></a><a class="indexterm" name="d0e11021"></a><p>
				The below table outlines the logical and comparison operators available.
			</p><div class="table"><a name="epl-log-operators"></a><p class="title"><b>Table&nbsp;6.2.&nbsp;Syntax and results of logical and comparison operators</b></p><table summary="Syntax and results of logical and comparison operators" border="1"><colgroup><col><col></colgroup><thead><tr><th>Operator</th><th>Description</th></tr></thead><tbody><tr><td>NOT</td><td><p>Returns true if the following condition is false, returns false if it is true.</p></td></tr><tr><td>OR</td><td><p>Returns true if either component condition is true, returns false if both are false.</p></td></tr><tr><td>AND</td><td><p>Returns true if both component conditions are true, returns false if either is false.</p></td></tr><tr><td>=, !=, &lt;, &gt; &lt;=, &gt;=,</td><td><p>Comparison.</p></td></tr></tbody></table></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="epl-operator-ref-string"></a>6.3.&nbsp;Concatenation Operators</h2></div></div><div></div></div><a class="indexterm" name="d0e11068"></a><a class="indexterm" name="d0e11071"></a><p>
				The below table outlines the concatenation operators available.
			</p><div class="table"><a name="epl-concat-operators"></a><p class="title"><b>Table&nbsp;6.3.&nbsp;Syntax and results of concatenation operators</b></p><table summary="Syntax and results of concatenation operators" border="1"><colgroup><col><col></colgroup><thead><tr><th>Operator</th><th>Description</th></tr></thead><tbody><tr><td>||</td><td><p>Concatenates character strings</p></td></tr></tbody></table></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="epl-operator-ref-binary"></a>6.4.&nbsp;Binary Operators</h2></div></div><div></div></div><a class="indexterm" name="d0e11100"></a><a class="indexterm" name="d0e11103"></a><p>
				The below table outlines the binary operators available.
			</p><div class="table"><a name="epl-binary-operators"></a><p class="title"><b>Table&nbsp;6.4.&nbsp;Syntax and results of binary operators</b></p><table summary="Syntax and results of binary operators" border="1"><colgroup><col><col></colgroup><thead><tr><th>Operator</th><th>Description</th></tr></thead><tbody><tr><td>&amp;</td><td><p>Bitwise AND if both operands are numbers; conditional AND if both operands are boolean</p></td></tr><tr><td>|</td><td><p>Bitwise OR if both operands are numbers; conditional OR if both operands are boolean</p></td></tr><tr><td>^</td><td><p>Bitwise exclusive OR (XOR)</p></td></tr></tbody></table></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="epl-operator-ref-array"></a>6.5.&nbsp;Array Definition Operator</h2></div></div><div></div></div><a class="indexterm" name="d0e11144"></a><a class="indexterm" name="d0e11147"></a><p>
				The <tt class="literal">{</tt> and <tt class="literal">}</tt> curly braces are array definition operators following the Java array initialization syntax. Arrays can be useful to pass to user-defined functions or to select array data in a select clause.
			</p><p>
				Array definitions consist of zero or more expressions within curly braces. Any type of expression is allowed within array definitions including constants, arithmetic expressions or event properties. This is the syntax of an array definition:
			</p><pre class="synopsis"><span class="emphasis"><em>{</em></span> [<span class="emphasis"><em>expression</em></span> [,<span class="emphasis"><em>expression</em></span>...]] }</pre><p>
				Consider the next statement that returns an event property named <tt class="literal">actions</tt>. The engine populates the <tt class="literal">actions</tt> property as an array of <tt class="literal">java.lang.String</tt> values with a length of 2 elements. The first element of the array contains the <tt class="literal">observation</tt> property value and the second element the <tt class="literal">command</tt> property value of <tt class="literal">RFIDEvent</tt> events.
			</p><pre class="programlisting">select {observation, command} as actions from RFIDEvent</pre><p>
				The engine determines the array type based on the types returned by the expressions in the array definiton. For example, if all expressions in the array definition return integer values then the type of the array is <tt class="literal">java.lang.Integer[]</tt>. If the types returned by all expressions are compatible number types, such as integer and double values, the engine coerces the array element values and returns a suitable type, <tt class="literal">java.lang.Double[]</tt> in this example.
				The type of the array returned is <tt class="literal">Object[]</tt> if the types of expressions cannot be coerced or return object values. Null values can also be used in an array definition.
			</p><p>
				Arrays can come in handy for use as parameters to user-defined functions:
			</p><pre class="programlisting">select * from RFIDEvent where Filter.myFilter(zone, {1,2,3})</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="epl-operator-ref-keyword-in"></a>6.6.&nbsp;The '<tt class="literal">in</tt>' Keyword</h2></div></div><div></div></div><a class="indexterm" name="d0e11215"></a><a class="indexterm" name="d0e11220"></a><p>
				The <tt class="literal">in</tt> keyword determines if a given value matches any value in a list. The syntax of the keyword is:	
			</p><pre class="synopsis"><span class="emphasis"><em>test_expression</em></span> [not] in (<span class="emphasis"><em>expression</em></span> [,<span class="emphasis"><em>expression</em></span>...] )</pre><p>
				The <span class="emphasis"><em>test_expression</em></span> is any valid expression. The keyword is followed by a list of expressions to test for a match. The optional <tt class="literal">not</tt> keyword specifies that the result of the predicate be negated.
			</p><p>
				The result of an <tt class="literal">in</tt> expression is of type <tt class="literal">Boolean</tt>. If the value of <span class="emphasis"><em>test_expression</em></span> is equal to any expression from the comma-separated list, the result value is <tt class="literal">true</tt>. Otherwise, the result value is <tt class="literal">false</tt>. 
			</p><p>
				The next example shows how the <tt class="literal">in</tt> keyword can be applied to select certain command types of RFID events:
			</p><pre class="programlisting">select * from RFIDEvent where command in ('OBSERVATION', 'SIGNAL')</pre><p>
				The statement is equivalent to:
			</p><pre class="programlisting">select * from RFIDEvent where command = 'OBSERVATION' or command = 'SIGNAL'</pre><p>
				<span class="emphasis"><em>Expression</em></span> may also return an array, a <tt class="literal">java.util.Collection</tt> or a <tt class="literal">java.util.Map</tt>. Thus event properties that are lists, sets or maps may provide values to compare against <span class="emphasis"><em>test_expression</em></span>.
			</p><p>
				All expressions must be of the same type or a compatible type to <span class="emphasis"><em>test_expression</em></span>. The <tt class="literal">in</tt> keyword may coerce number values to compatible types. If <span class="emphasis"><em>expression</em></span> returns an array, then the component type of the array must be compatible, unless the component type of the array is <tt class="literal">Object</tt>.
			</p><p>
				If <span class="emphasis"><em>expression</em></span> returns an array of component type <tt class="literal">Object</tt>, the operation compares each element of the array, applying <tt class="literal">equals</tt> semantics.
			</p><p>
				If <span class="emphasis"><em>expression</em></span> returns a <tt class="literal">Collection</tt>, the operation determines if the collection contains the value returned by <span class="emphasis"><em>test_expression</em></span>,  applying <tt class="literal">contains</tt> semantics. 
			</p><p>
				If <span class="emphasis"><em>expression</em></span> returns a <tt class="literal">Map</tt>, the operation determines if the map contains the key value returned by <span class="emphasis"><em>test_expression</em></span>, applying <tt class="literal">containsKey</tt> semantics.
			</p><p>
				 Constants, arrays, <tt class="literal">Collection</tt> and <tt class="literal">Map</tt> expressions or event properties can be used combined.
			</p><p>
				 For example, and assuming a property named 'mySpecialCmdList'  exists that contains a list of command strings:
			</p><pre class="programlisting">select * from RFIDEvent where command in ( 'OBSERVATION', 'SIGNAL', mySpecialCmdList)</pre><p>
				 When using prepared statements and substitution parameters with the <tt class="literal">in</tt> keyword, make sure to retain the parenthesis. Substitution values may also be arrays, <tt class="literal">Collection</tt> and <tt class="literal">Map</tt> values:
			</p><pre class="synopsis"><span class="emphasis"><em>test_expression</em></span> [not] in (? [,?...] )</pre><p>
				Note that if there are no successes and at least one right-hand row yields null for the operator's result, the result of the any construct will be null, not false. This is in accordance with SQL's normal rules for Boolean combinations of null values.
			</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="epl-operator-ref-keyword-between"></a>6.7.&nbsp;The '<tt class="literal">between</tt>' Keyword</h2></div></div><div></div></div><a class="indexterm" name="d0e11379"></a><a class="indexterm" name="d0e11384"></a><p>
				The <tt class="literal">between</tt> keyword specifies a range to test. The syntax of the keyword is:	
			</p><pre class="synopsis"><span class="emphasis"><em>test_expression</em></span> [not] between <span class="emphasis"><em>begin_expression</em></span> and <span class="emphasis"><em>end_expression</em></span></pre><p>
				The <span class="emphasis"><em>test_expression</em></span> is any valid expression and is the expression to test for in the range defined by <span class="emphasis"><em>begin_expression</em></span> and <span class="emphasis"><em>end_expression</em></span>. The <tt class="literal">not</tt> keyword specifies that the result of the predicate be negated. 
			</p><p>
				The result of a <tt class="literal">between</tt> expression is of type <tt class="literal">Boolean</tt>. If the value of <span class="emphasis"><em>test_expression</em></span> is greater then or equal to the value of <span class="emphasis"><em>begin_expression</em></span> and less than or equal to the value of <span class="emphasis"><em>end_expression</em></span>, the result is <tt class="literal">true</tt>. 
			</p><p>
				The next example shows how the <tt class="literal">between</tt> keyword can be used to select events with a price between 55 and 60 (inclusive).
			</p><pre class="programlisting">select * from StockTickEvent where price between 55 and 60</pre><p>
				The equivalent expression without <tt class="literal">between</tt> is:
			</p><pre class="programlisting">select * from StockTickEvent where price &gt;= 55 and price &lt;= 60</pre><p>
				And also equivalent to:
			</p><pre class="programlisting">select * from StockTickEvent where price between 60 and 55</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="epl-operator-ref-keyword-like"></a>6.8.&nbsp;The '<tt class="literal">like</tt>' Keyword</h2></div></div><div></div></div><a class="indexterm" name="d0e11462"></a><a class="indexterm" name="d0e11467"></a><p>
				The <tt class="literal">like</tt> keyword provides standard SQL pattern matching. SQL pattern matching allows you to use <tt class="literal">'_'</tt> to match any single character and <tt class="literal">'%'</tt> to match an arbitrary number of characters (including zero characters). In Esper, SQL patterns are case-sensitive by default. The syntax of <tt class="literal">like</tt> is:	
			</p><pre class="synopsis"><span class="emphasis"><em>test_expression</em></span> [not] like <span class="emphasis"><em>pattern_expression</em></span> [escape <span class="emphasis"><em>string_literal</em></span>]</pre><p>
				The <span class="emphasis"><em>test_expression</em></span> is any valid expression yielding a String-type or a numeric result. The optional <tt class="literal">not</tt> keyword specifies that the result of the predicate be negated. The <tt class="literal">like</tt> keyword is followed by any valid standard SQL <span class="emphasis"><em>pattern_expression</em></span> yielding a String-typed result. The optional <tt class="literal">escape</tt> keyword signals the escape character to escape <tt class="literal">'_'</tt> and <tt class="literal">'%'</tt> values in the pattern.
			</p><p>
				The result of a <tt class="literal">like</tt> expression is of type <tt class="literal">Boolean</tt>. If the value of <span class="emphasis"><em>test_expression</em></span> matches the <span class="emphasis"><em>pattern_expression</em></span>, the result value is <tt class="literal">true</tt>. Otherwise, the result value is <tt class="literal">false</tt>.
			</p><p>
				An example for the <tt class="literal">like</tt> keyword is below.
			</p><pre class="programlisting">select * from PersonLocationEvent where name like '%Jack%'</pre><p>
				The escape character can be defined as follows. In this example the where-clause matches events where the suffix property is a single <tt class="literal">'_'</tt> character.
			</p><pre class="programlisting">select * from PersonLocationEvent where suffix like '!_' escape '!'</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="epl-operator-ref-keyword-regexp"></a>6.9.&nbsp;The '<tt class="literal">regexp</tt>' Keyword</h2></div></div><div></div></div><a class="indexterm" name="d0e11560"></a><a class="indexterm" name="d0e11565"></a><p>
				The <tt class="literal">regexp</tt> keyword is a form of pattern matching based on regular expressions implemented through the Java <tt class="literal">java.util.regex</tt> package. The syntax of <tt class="literal">regexp</tt> is:	
			</p><pre class="synopsis"><span class="emphasis"><em>test_expression</em></span> [not] regexp <span class="emphasis"><em>pattern_expression</em></span></pre><p>
				The <span class="emphasis"><em>test_expression</em></span> is any valid expression yielding a String-type or a numeric result. The optional <tt class="literal">not</tt> keyword specifies that the result of the predicate be negated. The <tt class="literal">regexp</tt> keyword is followed by any valid regular expression <span class="emphasis"><em>pattern_expression</em></span> yielding a String-typed result.
			</p><p>
				The result of a <tt class="literal">regexp</tt> expression is of type <tt class="literal">Boolean</tt>. If the value of <span class="emphasis"><em>test_expression</em></span> matches the regular expression <span class="emphasis"><em>pattern_expression</em></span>, the result value is <tt class="literal">true</tt>. Otherwise, the result value is <tt class="literal">false</tt>.
			</p><p>
				An example for the <tt class="literal">regexp</tt> keyword is below.
			</p><pre class="programlisting">select * from PersonLocationEvent where name regexp '*Jack*'</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="epl-operator-anysome"></a>6.10.&nbsp;The '<tt class="literal">any</tt>' and '<tt class="literal">some</tt>' Keywords</h2></div></div><div></div></div><p>
				The <tt class="literal">any</tt> operator is true if the expression returns true for one or more of the values returned by a list of expressions including array, <tt class="literal">Collection</tt> and <tt class="literal">Map</tt> values.
			</p><p>
				The synopsis for the <tt class="literal">any</tt> keyword is as follows:
			</p><pre class="synopsis"><span class="emphasis"><em>expression</em></span> <span class="emphasis"><em>operator</em></span> any (<span class="emphasis"><em>expression</em></span> [,<span class="emphasis"><em>expression</em></span>...] )</pre><p>
				The left-hand expression is evaluated and compared to each expression result using the given operator, which must yield a Boolean result. The result of <tt class="literal">any</tt> is "true" if any true result is obtained. The result is "false" if no true result is found (including the special case where the expressions are collections that return no rows). 
			</p><p>
				The <span class="emphasis"><em>operator</em></span> can be any of the following values: <tt class="literal">=, !=, &lt;&gt;, &lt;, &lt;=, &gt;, &gt;=</tt>.
			</p><p>
				The <tt class="literal">some</tt> keyword is a synonym for <tt class="literal">any</tt>. The <tt class="literal">in</tt> construct is equivalent to <tt class="literal">= any</tt>.
			</p><p>
				<span class="emphasis"><em>Expression</em></span> may also return an array, a <tt class="literal">java.util.Collection</tt> or a <tt class="literal">java.util.Map</tt>. Thus event properties that are lists, sets or maps may provide values to compare against.
			</p><p>
				All expressions must be of the same type or a compatible type. The <tt class="literal">any</tt> keyword coerces number values to compatible types. If <span class="emphasis"><em>expression</em></span> returns an array, then the component type of the array must be compatible, unless the component type of the array is <tt class="literal">Object</tt>.
			</p><p>
				If <span class="emphasis"><em>expression</em></span> returns an array, the operation compares each element of the array.
			</p><p>
				If <span class="emphasis"><em>expression</em></span> returns a <tt class="literal">Collection</tt>, the operation determines if the collection contains the value returned by the left-hand expression,  applying <tt class="literal">contains</tt> semantics. 
				When using relationship operators <tt class="literal">&lt;, &lt;=, &gt;, &gt;=</tt> the operator applies to each element in the collection, and non-numeric elements are ignored.
			</p><p>
				If <span class="emphasis"><em>expression</em></span> returns a <tt class="literal">Map</tt>, the operation determines if the map contains the key value returned by the left-hand expression, applying <tt class="literal">containsKey</tt> semantics.
				When using relationship operators <tt class="literal">&lt;, &lt;=, &gt;, &gt;=</tt> the operator applies to each key in the map, and non-numeric map keys are ignored.
			</p><p>
				 Constants, arrays, <tt class="literal">Collection</tt> and <tt class="literal">Map</tt> expressions or event properties can be used combined.
			</p><p>
				The next statement demonstrates the use of the <tt class="literal">any</tt> operator: 
			</p><pre class="programlisting">select * from ProductOrder where category != any (categoryArray)</pre><p>
				The above query selects ProductOrder event that have a category field and a category array, and returns only those events in which the category value is not in the array.
			</p><p>
				Note that if there are no successes and at least one right-hand row yields null for the operator's result, the result of the <tt class="literal">any</tt> construct will be null, not false. This is in accordance with SQL's normal rules for Boolean combinations of null values. 
			</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="epl-operator-all"></a>6.11.&nbsp;The '<tt class="literal">all</tt>' Keyword</h2></div></div><div></div></div><p>
				The <tt class="literal">all</tt> operator is true if the expression returns true for all of the values returned by a list of expressions including array, <tt class="literal">Collection</tt> and <tt class="literal">Map</tt> values.
			</p><p>
				The synopsis for the <tt class="literal">all</tt> keyword is as follows:
			</p><pre class="synopsis"><span class="emphasis"><em>expression</em></span> <span class="emphasis"><em>operator</em></span> all (<span class="emphasis"><em>expression</em></span> [,<span class="emphasis"><em>expression</em></span>...] )</pre><p>
				The left-hand expression is evaluated and compared to each expression result using the given operator, which must yield a Boolean result. The result of <tt class="literal">all</tt> is "true" if all rows yield true (including the special case where the expressions are collections that returns no rows). The result is "false" if any false result is found. The result is <tt class="literal">null</tt> if the comparison does not return false for any row, and it returns <tt class="literal">null</tt> for at least one row.
			</p><p>
				The <span class="emphasis"><em>operator</em></span> can be any of the following values: <tt class="literal">=, !=, &lt;&gt;, &lt;, &lt;=, &gt;, &gt;=</tt>.
			</p><p>
				The <tt class="literal">not in</tt> construct is equivalent to <tt class="literal">!= all</tt>.
			</p><p>
				<span class="emphasis"><em>Expression</em></span> may also return an array, a <tt class="literal">java.util.Collection</tt> or a <tt class="literal">java.util.Map</tt>. Thus event properties that are lists, sets or maps may provide values to compare against.
			</p><p>
				All expressions must be of the same type or a compatible type. The <tt class="literal">all</tt> keyword coerces number values to compatible types. If <span class="emphasis"><em>expression</em></span> returns an array, then the component type of the array must be compatible, unless the component type of the array is <tt class="literal">Object</tt>.
			</p><p>
				If <span class="emphasis"><em>expression</em></span> returns an array, the operation compares each element of the array.
			</p><p>
				If <span class="emphasis"><em>expression</em></span> returns a <tt class="literal">Collection</tt>, the operation determines if the collection contains the value returned by the left-hand expression,  applying <tt class="literal">contains</tt> semantics. 
				When using relationship operators <tt class="literal">&lt;, &lt;=, &gt;, &gt;=</tt> the operator applies to each element in the collection, and non-numeric elements are ignored.
			</p><p>
				If <span class="emphasis"><em>expression</em></span> returns a <tt class="literal">Map</tt>, the operation determines if the map contains the key value returned by the left-hand expression, applying <tt class="literal">containsKey</tt> semantics.
				When using relationship operators <tt class="literal">&lt;, &lt;=, &gt;, &gt;=</tt> the operator applies to each key in the map, and non-numeric map keys are ignored.
			</p><p>
				 Constants, arrays, <tt class="literal">Collection</tt> and <tt class="literal">Map</tt> expressions or event properties can be used combined.
			</p><p>
				The next statement demonstrates the use of the <tt class="literal">all</tt> operator: 
			</p><pre class="programlisting">select * from ProductOrder where category = all (categoryArray)</pre><p>
				The above query selects ProductOrder event that have a category field and a category array, and returns only those events in which the category value matches all values in the array.
			</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="functionreference"></a>Chapter&nbsp;7.&nbsp;EPL Reference: Functions</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="epl-single-row-function-ref"></a>7.1.&nbsp;Single-row Function Reference</h2></div></div><div></div></div><p>
			Single-row functions return a single value for every single result row generated by your statement. These functions can appear anywhere where expressions are allowed.
		</p><a class="indexterm" name="d0e11913"></a><a class="indexterm" name="d0e11916"></a><a class="indexterm" name="d0e11921"></a><p>
			Esper allows static Java library methods as single-row functions, and also features built-in single-row functions. In addition, Esper allows instance method invocations on named streams.
		</p><p>
			Esper auto-imports the following Java library packages:
		</p><div class="itemizedlist"><ul type="disc" compact><li><p>
					java.lang.*
				</p></li><li><p>
					java.math.*
				</p></li><li><p>
					java.text.*
				</p></li><li><p>
					java.util.*
				</p></li></ul></div><p>
			Thus Java static library methods can be used in all expressions as shown in below example:
		</p><pre class="programlisting">select symbol, Math.round(volume/1000)
from StockTickEvent.win:time(30 sec)</pre><p>
			In general, arbitrary Java class names have to be fully qualified (e.g. java.lang.Math) but Esper provides a mechanism 
for user-controlled imports of classes and packages as outlined in <a href="#config-class--package-imports" title="10.4.5.&nbsp;Class and package imports">Section&nbsp;10.4.5, &#8220;Class and package imports&#8221;</a>.
		</p><p>
			The below table outlines the built-in single-row functions available.
		</p><div class="table"><a name="epl-single-row-func"></a><p class="title"><b>Table&nbsp;7.1.&nbsp;Syntax and results of single-row functions</b></p><table summary="Syntax and results of single-row functions" border="1"><colgroup><col><col></colgroup><thead><tr><th>Single-row Function</th><th>Result</th></tr></thead><tbody><tr><td><pre class="synopsis">case <span class="emphasis"><em>value</em></span> 
  when <span class="emphasis"><em>compare_value</em></span> then <span class="emphasis"><em>result</em></span>
  [when <span class="emphasis"><em>compare_value</em></span> then <span class="emphasis"><em>result</em></span> ...] 
  [else <span class="emphasis"><em>result</em></span>] 
  end </pre></td><td><p>
								Returns <tt class="literal">result</tt> where the first <tt class="literal">value</tt> equals <tt class="literal">compare_value</tt>. 
							</p></td></tr><tr><td><pre class="synopsis">case 
  when <span class="emphasis"><em>condition</em></span> then <span class="emphasis"><em>result</em></span>
  [when <span class="emphasis"><em>condition</em></span> then <span class="emphasis"><em>result</em></span> ...] 
  [else <span class="emphasis"><em>result</em></span>] 
  end</pre></td><td><p>
								Returns the <tt class="literal">result</tt> for the first condition that is true.
							</p></td></tr><tr><td><pre class="synopsis">cast(<span class="emphasis"><em>expression</em></span>, <span class="emphasis"><em>type_name</em></span>)</pre></td><td><p>
								Casts the result of an expression to the given type. 
							</p></td></tr><tr><td><pre class="synopsis">coalesce(<span class="emphasis"><em>expression</em></span>, <span class="emphasis"><em>expression</em></span> [, <span class="emphasis"><em>expression</em></span> ...])</pre></td><td><p>
								Returns the first non-<tt class="literal">null</tt> value in the list, or <tt class="literal">null</tt> if there are no non-<tt class="literal">null</tt> values.
							</p></td></tr><tr><td><pre class="synopsis">current_timestamp[()]</pre></td><td><p>
								Returns the current engine time as a <tt class="literal">long</tt> millisecond value. Reserved keyword with optional parenthesis.
							</p></td></tr><tr><td><pre class="synopsis">exists(<span class="emphasis"><em>dynamic_property_name</em></span>)</pre></td><td><p>
								Returns true if the dynamic property exists for the event, or false if the property does not exist.
							</p></td></tr><tr><td><pre class="synopsis">instanceof(<span class="emphasis"><em>expression</em></span>, <span class="emphasis"><em>type_name</em></span> [, <span class="emphasis"><em>type_name</em></span> ...])</pre></td><td><p>
								Returns true if the expression returns an object whose type is one of the types listed.
							</p></td></tr><tr><td><pre class="synopsis">max(<span class="emphasis"><em>expression</em></span>, <span class="emphasis"><em>expression</em></span> [, <span class="emphasis"><em>expression</em></span> ...])</pre></td><td><p>
								Returns the highest numeric value among the 2 or more comma-separated expressions.
							</p></td></tr><tr><td><pre class="synopsis">min(<span class="emphasis"><em>expression</em></span>, <span class="emphasis"><em>expression</em></span> [, <span class="emphasis"><em>expression</em></span> ...])</pre></td><td><p>
								Returns the lowest numeric value among the 2 or more comma-separated expressions.
							</p></td></tr><tr><td><pre class="synopsis">prev(<span class="emphasis"><em>expression</em></span>, <span class="emphasis"><em>event_property)</em></span></pre></td><td><p>
								Returns a property value of a previous event, relative to the event order within a data window 
							</p></td></tr><tr><td><pre class="synopsis">prior(<span class="emphasis"><em>integer</em></span>, <span class="emphasis"><em>event_property)</em></span></pre></td><td><p>
								Returns a property value of a prior event, relative to the natural order of arrival of events
							</p></td></tr></tbody></table></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="epl-single-row-function-ref-case"></a>7.1.1.&nbsp;The <tt class="literal">Case</tt> Control Flow Function</h3></div></div><div></div></div><a class="indexterm" name="d0e12159"></a><a class="indexterm" name="d0e12162"></a><p>
				The <tt class="literal">case</tt> control flow function has two versions. The first version takes a value and a list of compare values to compare against, and returns the result where the first value equals the compare value. The second version takes a list of conditions and returns the result for the first condition that is true.
			</p><p>
				The return type of a <tt class="literal">case</tt> expression is the compatible aggregated type of all return values.
			</p><p>
				The example below shows the first version of a <tt class="literal">case</tt> statement. It has a <tt class="literal">String</tt> return type and returns the value 'one'.
			</p><pre class="programlisting">select case 1 when 1 then 'one' when 2 then 'two' else 'more' end from ...</pre><p>
				The second version of the <tt class="literal">case</tt> function takes a list of conditions. The next example has a <tt class="literal">Boolean</tt> return type and returns the boolean value true.
			</p><pre class="programlisting">select case when 1&gt;0 then true else false end from ...</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="epl-single-row-function-cast"></a>7.1.2.&nbsp;The <tt class="literal">Cast</tt> Function</h3></div></div><div></div></div><a class="indexterm" name="d0e12203"></a><a class="indexterm" name="d0e12206"></a><p>
				The <tt class="literal">cast</tt> function casts the return type of an expression to a designated type. The function accepts two parameters: The first parameter is the property name or expression that returns the 
				value to be casted. The second parameter is the type to cast to.
			</p><p>
				Valid parameters for the second (type) parameter are:
			</p><div class="itemizedlist"><ul type="disc"><li><p>
						Any of the Java built-in types: <tt class="literal">int, long, byte, short, char, double, float, string, BigInteger, BigDecimal</tt>, where <tt class="literal">string</tt>  is a short notation for <tt class="literal">java.lang.String</tt> and <tt class="literal">BigInteger</tt> as well as <tt class="literal">BigDecimal</tt> are the classes in <tt class="literal">java.math</tt>. The type name is not case-sensitive. For example:
						</p><pre class="synopsis">cast(price, double)</pre><p>
					</p></li><li><p>
						The fully-qualified class name of the class to cast to, for example: </p><pre class="synopsis">cast(product, org.myproducer.Product)</pre><p>
					</p></li></ul></div><p>
				The <tt class="literal">cast</tt> function is often used to provide a type for dynamic (unchecked) properties. Dynamic properties are properties whose type is not known at compile type. 
				These properties are always of type <tt class="literal">java.lang.Object</tt>. 
			</p><p>
				The <tt class="literal">cast</tt> function as shown in the next statement casts the dynamic "price" property of an "item" in the OrderEvent to a double value.
			</p><pre class="programlisting">select cast(item.price?, double) from OrderEvent</pre><p>
				The <tt class="literal">cast</tt> function returns a <tt class="literal">null</tt> value if the expression result cannot be casted to the desired type, or if the expression result itself is <tt class="literal">null</tt>.
			</p><p>
				The <tt class="literal">cast</tt> function adheres to the following type conversion rules:
			</p><div class="itemizedlist"><ul type="disc"><li><p>
						For all numeric types, the <tt class="literal">cast</tt> function utilitzes <tt class="literal">java.lang.Number</tt> to convert numeric types, if required. 
					</p></li><li><p>
						For casts to <tt class="literal">string</tt> or <tt class="literal">java.lang.String</tt>, the function calls <tt class="literal">toString</tt> on the expression result.
					</p></li><li><p>
						For casts to other objects including application objects, the <tt class="literal">cast</tt> function considers a Java class's superclasses as well as all directly or indirectly-implemented interfaces by superclasses .
					</p></li></ul></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="epl-single-row-function-ref-coalesce"></a>7.1.3.&nbsp;The <tt class="literal">Coalesce</tt> Function</h3></div></div><div></div></div><a class="indexterm" name="d0e12314"></a><a class="indexterm" name="d0e12317"></a><p>
				The result of the <tt class="literal">coalesce</tt> function is the first expression in a list of expressions that returns a non-null value. The return type is the compatible aggregated type of all return values.
			</p><p>
				This example returns a String-typed result of value 'foo':
			</p><pre class="programlisting">select coalesce(null, 'foo') from ...</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="epl-single-row-function-ref-currenttime"></a>7.1.4.&nbsp;The <tt class="literal">Current_Timestamp</tt> Function</h3></div></div><div></div></div><a class="indexterm" name="d0e12337"></a><a class="indexterm" name="d0e12340"></a><p>
				The <tt class="literal">current_timestamp</tt> function is a reserved keyword and requires no parameters. The result of the <tt class="literal">current_timestamp</tt> function is the <tt class="literal">long</tt>-type millisecond value of the current engine system time.
			</p><p>
				The function returns the current engine timestamp at the time of expression evaluation. When using external-timer events, the function provides the last value of the externally-supplied time at the time of expression evaluation.
			</p><p>
				This example selects the current engine time:
			</p><pre class="programlisting">select current_timestamp from MyEvent
// equivalent to
select current_timestamp() from MyEvent</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="epl-single-row-function-exists"></a>7.1.5.&nbsp;The <tt class="literal">Exists</tt> Function</h3></div></div><div></div></div><a class="indexterm" name="d0e12368"></a><a class="indexterm" name="d0e12371"></a><p>
				The <tt class="literal">exists</tt> function returns a boolean value indicating whether the dynamic property, provided as a parameter to the function, exists on the event. The <tt class="literal">exists</tt> function accepts a single dynamic property name as its only parameter. 
			</p><p>
				The <tt class="literal">exists</tt> function is for use with dynamic (unchecked) properties. Dynamic properties are properties whose type is not known at compile type. Dynamic properties return a null value
				if the dynamic property does not exists on an event, or if the dynamic property exists but the value of the dynamic property is null. 
			</p><p>
				The <tt class="literal">exists</tt> function as shown next returns true if the "item" property contains an object that has a "serviceName" property. It returns false if the "item" property is null, or if the "item" property does not 
				contain an object that has a property named "serviceName" :
			</p><pre class="programlisting">select exists(item.serviceName?) from OrderEvent</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="epl-single-row-function-instanceof"></a>7.1.6.&nbsp;The <tt class="literal">Instance-Of</tt> Function</h3></div></div><div></div></div><a class="indexterm" name="d0e12402"></a><a class="indexterm" name="d0e12405"></a><p>
				The <tt class="literal">instanceof</tt> function returns a boolean value indicating whether the type of value returned by the expression is one of the given types. The first parameter to the <tt class="literal">instanceof</tt> function is an expression to evaluate. The second and subsequent parameters are Java type names.
			</p><p>
				The function determines the return type of the expression at runtime by evaluating the expression, and compares the type of object returned by the expression to the defined types. 
				If the type of object returned by the expression matches any of the given types, the function returns <tt class="literal">true</tt>. If the expression returned <tt class="literal">null</tt> or a type that does not
				match any of the given types, the function returns <tt class="literal">false</tt>.
			</p><p>
				The <tt class="literal">instanceof</tt> function is often used in conjunction with dynamic (unchecked) properties. Dynamic properties are properties whose type is not known at compile type. 
			</p><p>
				This example uses the <tt class="literal">instanceof</tt> function to select different properties based on the type:
			</p><pre class="programlisting">select case when instanceof(item, com.mycompany.Service) then serviceName?
  when instanceof(item, com.mycompany.Product) then productName? end 
  from OrderEvent</pre><p>
				The <tt class="literal">instanceof</tt> function returns <tt class="literal">false</tt> if the expression tested by instanceof returned null.
			</p><p>
				Valid parameters for the type parameter list are:
			</p><div class="itemizedlist"><ul type="disc"><li><p>
						Any of the Java built-in types: <tt class="literal">int, long, byte, short, char, double, float, string</tt>, where <tt class="literal">string</tt>  is a short notation for <tt class="literal">java.lang.String</tt>. The type name is not case-sensitive. For example, the next function tests if the dynamic "price" property is either of type float or type double:
						</p><pre class="synopsis">instanceof(price?, double, float)</pre><p>
					</p></li><li><p>
						The fully-qualified class name of the class to cast to, for example: </p><pre class="synopsis">instanceof(product, org.myproducer.Product)</pre><p>
					</p></li></ul></div><p>
				The function considers an event class's superclasses as well as all the directly or indirectly-implemented interfaces by superclasses.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="epl-single-row-function-ref-minmax"></a>7.1.7.&nbsp;The <tt class="literal">Min</tt> and <tt class="literal">Max</tt> Functions</h3></div></div><div></div></div><a class="indexterm" name="d0e12484"></a><a class="indexterm" name="d0e12487"></a><a class="indexterm" name="d0e12492"></a><a class="indexterm" name="d0e12495"></a><p>
				The <tt class="literal">min</tt> and <tt class="literal">max</tt> function take two or more parameters that itself can be expressions. The <tt class="literal">min</tt> function returns the lowest numeric value among the 2 or more comma-separated expressions, while the <tt class="literal">max</tt> function returns the highest numeric value.
				The return type is the compatible aggregated type of all return values.
			</p><p>
				The next example shows the <tt class="literal">max</tt> function that has a <tt class="literal">Double</tt> return type and returns the value 1.1.
			</p><pre class="programlisting">select max(1, 1.1, 2 * 0.5) from ...</pre><p>
				The <tt class="literal">min</tt> function returns the lowest value. The statement below uses the function to determine the smaller of two timestamp values.
			</p><pre class="programlisting">select symbol, min(ticks.timestamp, news.timestamp) as minT
	from StockTickEvent.win:time(30 sec) as ticks, NewsEvent.win:time(30 sec) as news
	where ticks.symbol = news.symbol</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="epl-single-row-function-ref-previous"></a>7.1.8.&nbsp;The <tt class="literal">Previous</tt> Function</h3></div></div><div></div></div><a class="indexterm" name="d0e12537"></a><a class="indexterm" name="d0e12540"></a><p>
				The <tt class="literal">prev</tt> function returns the property value of a previous event. The first parameter denotes the i-th previous event in the order established by the data window. 
				The second parameter is a property name for which the function returns the value for the previous event.
			</p><p>
				This example selects the value of the <tt class="literal">price</tt> property of the 2nd-previous event from the current Trade event.
			</p><pre class="programlisting">select prev(2, price) from Trade.win:length(10)</pre><p>
				Since the <tt class="literal">prev</tt> function takes the order established by the data window into account, the function works well with sorted windows. In the following example the statement
				selects the symbol of the 3 Trade events that had the largest, second-largest and third-largest volume.
			</p><pre class="programlisting">select prev(0, symbol), prev(1, symbol), prev(2, symbol)
  from Trade.ext:sort(volume, true, 10)</pre><p>
				The i-th previous event parameter can also be an expression returning an Integer-type value. The next statement joins the Trade data window with an <tt class="literal">RankSelectionEvent</tt> event that provides a <tt class="literal">rank</tt> property used to look up a certain position in the sorted Trade data window:
			</p><pre class="programlisting">select prev(rank, symbol) from Trade.ext:sort(volume, true, 10), RankSelectionEvent</pre><p>
				And the expression <tt class="literal">count(*) - 1</tt> allows us to select the oldest event in the length window:
			</p><pre class="programlisting">select prev(count(*) - 1, price) from Trade.win:length(100)</pre><p>
				The <tt class="literal">prev</tt> function returns a <tt class="literal">null</tt> value if the data window does not currently hold the i-th previous event. The example below illustrates this using a time batch window. Here the <tt class="literal">prev</tt>  
				function returns a null value for any events in which the previous event is not in the same batch of events. Note that the <tt class="literal">prior</tt> function as discussed below can be used if a null value is not the desired result.
			</p><pre class="programlisting">select prev(1, symbol) from Trade.win:time_batch(1 min)</pre><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="epl-single-row-function-ref-prev-group"></a>7.1.8.1.&nbsp;Previous Event per Group</h4></div></div><div></div></div><p>
					The combination of <tt class="literal">prev</tt> function and group-by view returns the property value for a previous event in the given group. 
				</p><p>
					Let's look at an example. Assume we want to obtain the price of the previous event of the same symbol as the current event.
				</p><p>
					The statement that follows solves this problem. It declares a group-by view grouping on the symbol property and a time window of 1 minute. As a result, when the engine encounters a new symbol value that it hasn't seen before, it creates a new time window specifically to hold events for that symbol. Consequently, the previous function returns the previous event within the respective time window for that event's symbol value. 
				</p><pre class="programlisting">select prev(1, price) as prevPrice from Trade.std:groupby(symbol).win:time(1 min)</pre><p>
					In a second example, assume we need to return, for each event, the current top price per symbol. We can use the <tt class="literal">prev</tt> to obtain the highest price from a sorted data window, and use the group-by view to group by symbol:
				</p><pre class="programlisting">select prev(0, price) as topPricePerSymbol 
from Trade.std:groupby(symbol).ext:sort(price, false, 1)</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="epl-single-row-function-ref-prev-restrictions"></a>7.1.8.2.&nbsp;Restrictions</h4></div></div><div></div></div><p>
						The following restrictions apply to the <tt class="literal">prev</tt> functions and its results:
				</p><div class="itemizedlist"><ul type="disc" compact><li><p>
							The function always returns a <tt class="literal">null</tt> value for remove stream (old data) events
						</p></li><li><p>
							The function requires a data window view, or a group-by and data window view, without any additional sub-views. See <a href="#epl-views" title="Chapter&nbsp;8.&nbsp;EPL Reference: Views">Chapter&nbsp;8, <i>EPL Reference: Views</i></a> for built-in data window views.
						</p></li></ul></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="epl-single-row-function-ref-prev-prior"></a>7.1.8.3.&nbsp;Comparison to the <tt class="literal">prior</tt> Function</h4></div></div><div></div></div><p>
					The <tt class="literal">prev</tt> function is similar to the <tt class="literal">prior</tt> function. The key differences between the two functions are as follows:				 
				</p><div class="itemizedlist"><ul type="disc" compact><li><p>
							The <tt class="literal">prev</tt> function returns previous events in the order provided by the data window, while the <tt class="literal">prior</tt> function returns prior events in the order of arrival as posted by a stream's declared views.
						</p></li><li><p>
							The <tt class="literal">prev</tt> function requires a data window view while the <tt class="literal">prior</tt> function does not have any view requirements.
						</p></li><li><p>
							The <tt class="literal">prev</tt> function returns the previous event grouped by a criteria by combining the <tt class="literal">std:groupby</tt> view and a data window. The <tt class="literal">prior</tt> function returns prior events posted by the last view regardless of data window grouping.
						</p></li><li><p>
							The <tt class="literal">prev</tt> function returns a <tt class="literal">null</tt> value for remove stream events, i.e. for events leaving a data window. 
							The <tt class="literal">prior</tt> function does not have this restriction.
						</p></li></ul></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="epl-single-row-function-ref-prior"></a>7.1.9.&nbsp;The <tt class="literal">Prior</tt> Function</h3></div></div><div></div></div><a class="indexterm" name="d0e12701"></a><a class="indexterm" name="d0e12704"></a><p>
				The <tt class="literal">prior</tt> function returns the property value of a prior event. The first parameter is an integer value that denotes the i-th prior event in the natural order of arrival. 
				The second parameter is a property name for which the function returns the value for the prior event.
			</p><p>
				This example selects the value of the <tt class="literal">price</tt> property of the 2nd-prior event to the current Trade event.
			</p><pre class="programlisting">select prior(2, price) from Trade</pre><p>
				The <tt class="literal">prior</tt> function can be used on any event stream or view and does not have any specific view requirements.  The function operates on the order of arrival of events by the event stream or view that provides the events.
			</p><p>
				The next statement uses a time batch window to compute an average volume for 1 minute of Trade events, posting results every minute. The select-clause 
				employs the <tt class="literal">prior</tt> function to select the current average and the average before the current average:
			</p><pre class="programlisting">select average, prior(1, average) 
    from TradeAverages.win:time_batch(1 min).stat:uni(volume)</pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="epl-function-aggregation"></a>7.2.&nbsp;Aggregate Functions</h2></div></div><div></div></div><a class="indexterm" name="d0e12736"></a><p>
			The syntax of the aggregation functions and the results they produce are shown in below table.
		</p><div class="table"><a name="epl-grouping-aggregate-func-table"></a><p class="title"><b>Table&nbsp;7.2.&nbsp;Syntax and results of aggregate functions</b></p><table summary="Syntax and results of aggregate functions" border="1"><colgroup><col><col></colgroup><thead><tr><th>Aggregate Function</th><th>Result</th></tr></thead><tbody><tr><td>sum([all|distinct] <span class="emphasis"><em>expression</em></span>)</td><td><p>
								Totals the (distinct) values in the expression, returning a value of <tt class="literal">long, double, float or integer</tt> type depending on the expression.
							</p></td></tr><tr><td>avg([all|distinct] <span class="emphasis"><em>expression</em></span>)</td><td><p>
								Average of the (distinct) values in the expression, returning a value of <tt class="literal">double</tt> type.
							</p></td></tr><tr><td>count([all|distinct] <span class="emphasis"><em>expression</em></span>)</td><td><p>
								Number of the (distinct) non-null values in the expression, returning a value of <tt class="literal">long</tt> type.
							</p></td></tr><tr><td>count(*)</td><td><p>
								Number of events, returning a value of <tt class="literal">long</tt> type.
							</p></td></tr><tr><td>max([all|distinct] <span class="emphasis"><em>expression</em></span>)</td><td><p>
								Highest (distinct) value in the expression, returning a value of the same type as the expression itself returns.
							</p></td></tr><tr><td>min([all|distinct] <span class="emphasis"><em>expression</em></span>)</td><td><p>
								Lowest (distinct) value in the expression, returning a value of the same type as the expression itself returns.
							</p></td></tr><tr><td>median([all|distinct] <span class="emphasis"><em>expression</em></span>)</td><td><p>
								Median (distinct) value in the expression, returning a value of <tt class="literal">double</tt> type. Double Not-a-Number (NaN) values are ignored in the median computation.
							</p></td></tr><tr><td>stddev([all|distinct] <span class="emphasis"><em>expression</em></span>)</td><td><p>
								Standard deviation of the (distinct) values in the expression, returning a value of <tt class="literal">double</tt> type.
							</p></td></tr><tr><td>avedev([all|distinct] <span class="emphasis"><em>expression</em></span>)</td><td><p>
								Mean deviation of the (distinct) values in the expression, returning a value of <tt class="literal">double</tt> type.
							</p></td></tr></tbody></table></div><p>
			Your application may also add its own aggregation function as <a href="#custom-aggregation-function" title="11.2.&nbsp;Custom Aggregation Functions">Section&nbsp;11.2, &#8220;Custom Aggregation Functions&#8221;</a> describes.
		</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="epl-function-user-defined"></a>7.3.&nbsp;User-Defined Functions</h2></div></div><div></div></div><a class="indexterm" name="d0e12862"></a><a class="indexterm" name="d0e12865"></a><a class="indexterm" name="d0e12870"></a><p>
			 A user-defined function (UDF) can be invoked anywhere as an expression itself or within an expresson. The function must simply be a public static method
			 that the classloader can resolve at statement creation time. The engine resolves the function reference at statement creation time and verifies parameter types.
		 </p><p>
			 User-defined functions can be also be invoked on instances of an event: Please see <a href="#epl-from-clause-stream-name" title="4.4.5.&nbsp;Using the Stream Name">Section&nbsp;4.4.5, &#8220;Using the Stream Name&#8221;</a> to invoke event instance methods on a named stream.
		 </p><p>
			 The example below assumes a class <tt class="literal">MyClass</tt> that exposes a public static method <tt class="literal">myFunction</tt> accepting 2 parameters, and
			 returing a numeric type such as <tt class="literal">double</tt>.
		 </p><pre class="programlisting">select 3 * com.mycompany.MyClass.myFunction(price, volume) as myValue 
from StockTick.win:time(30 sec)</pre><p>
			 User-defined functions also take array parameters as this example shows. The section on <a href="#epl-operator-ref-array" title="6.5.&nbsp;Array Definition Operator">Section&nbsp;6.5, &#8220;Array Definition Operator&#8221;</a> outlines in more detail the types of arrays produced.
		 </p><pre class="programlisting">select * from RFIDEvent where com.mycompany.rfid.MyChecker.isInZone(zone, {10, 20, 30})</pre><p>
			Java class names have to be fully qualified (e.g. java.lang.Math) but Esper provides a mechanism for user-controlled imports of classes and packages as outlined in <a href="#config-class--package-imports" title="10.4.5.&nbsp;Class and package imports">Section&nbsp;10.4.5, &#8220;Class and package imports&#8221;</a>.
		</p><p>
			 User-defined functions can return any value including <tt class="literal">null</tt>, Java objects or arrays. Therefore user-defined functions can serve to transform, convert or map events, or to extract information and assemble further events.
		 </p><p>
			 The following statement is a simple pattern that looks for events of type E1 that are followed by events of type E2. It assigns the tags "e1" and "e2" that the function can use to assemble a final event for output:
		 </p><pre class="programlisting">select MyLib.mapEvents(e1, e2) from pattern [every e1=E1 -&gt; e2=E2]</pre><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="epl-function-user-defined-converting"></a>7.3.1.&nbsp;Event Type Conversion via User-Defined Function</h4></div></div><div></div></div><p>
				 A function that converts from one event type to another event type is shown in the next example. The first statement declares a stream that consists of MyEvent events. The second statement employs a conversion function to convert MyOtherEvent events to events of type MyEvent:
			 </p><pre class="programlisting">insert into MyStream select * from MyEvent
	insert into MyStream select MyLib.convert(other) from MyOtherEvent as other</pre><p>
				 In the example above, assuming the event classes MyEvent and MyOtherEvent are Java classes, the static method should have the following footprint:
			 </p><pre class="programlisting">public static MyEvent convert(MyOtherEvent otherEvent)</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="epl-function-user-defined-cached"></a>7.3.2.&nbsp;User-Defined Function Result Cache</h4></div></div><div></div></div><p>
				 For user-defined functions that take no parameters or only constants as parameters the engine automatically caches the return result of the function, and invokes the function only once. This is beneficial to performance 
				 if your function indeed returns the same result for the same input parameters.
			</p><p>
				 You may disable caching of return values of user-defined functions via configuration as described in <a href="#config-engine-expression-udfcache" title="10.4.18.3.&nbsp;User-Defined Function or Static Method Cache">Section&nbsp;10.4.18.3, &#8220;User-Defined Function or Static Method Cache&#8221;</a>.
			</p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="epl-views"></a>Chapter&nbsp;8.&nbsp;EPL Reference: Views</h2></div></div><div></div></div><a class="indexterm" name="d0e12936"></a><a class="indexterm" name="d0e12941"></a><p>
            This chapter outlines the views that are built into Esper. All views can be arbitrarily combined as many of the examples below show. 
			The section on <a href="#processingmodel" title="Chapter&nbsp;3.&nbsp;Processing Model">Chapter&nbsp;3, <i>Processing Model</i></a> provides additional information on the relationship of views, filtering and aggregation. Please also see <a href="#epl-from-clause-view-spec" title="4.4.3.&nbsp;Specifying Views">Section&nbsp;4.4.3, &#8220;Specifying Views&#8221;</a> for the use of views in the <tt class="literal">from</tt> clause with streams, patterns and named windows.
        </p><p>
            Esper organizes built-in views in namespaces and names. Views that provide sliding or tumbling data windows are in the <tt class="literal">win</tt> namespace. Other most commonly used views are in the <tt class="literal">std</tt> namespace. The <tt class="literal">ext</tt> namespace are views that order events. The <tt class="literal">stat</tt> namespace is used for views that derive statistical data.
        </p><p>
            Esper distinguishes between data window views and derived-value views. Data windows, or data window views, are views that retain incoming events until an expiry policy indicates to release events. Derived-value views derive a new value from event streams and post the result as events of a new type.
        </p><p>
            Two or more data window views can be combined. This allows a sets of events retained by one data window to be placed into a union or an intersection with the set of events retained by one or more other data windows. Please see <a href="#epl-from-clause-view-multidatawindow" title="4.4.4.&nbsp;Multiple Data Window Views">Section&nbsp;4.4.4, &#8220;Multiple Data Window Views&#8221;</a> for more detail.
        </p><p>
			The keep-all data window counts as a data window but has no expiry policy: it retains all events received. The group-by data window allocates a new data window per group and thereby counts as a data window, but cannot appear alone.
        </p><p>
            The next table summarizes data window views:
        </p><div class="table"><a name="d0e12979"></a><p class="title"><b>Table&nbsp;8.1.&nbsp;Built-in Data Window Views</b></p><table summary="Built-in Data Window Views" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>View</th><th>Syntax</th><th>Description</th></tr></thead><tbody><tr><td>Length window</td><td>win:length(<span class="emphasis"><em>size</em></span>)</td><td>Sliding length window extending the specified number of elements into the past.</td></tr><tr><td>Length batch window</td><td>win:length_batch(<span class="emphasis"><em>size</em></span>)</td><td>Tumbling window that batches events and releases them when a given minimum number of events has been collected.</td></tr><tr><td>Time window</td><td>win:time(<span class="emphasis"><em>time period</em></span>)</td><td>Sliding time window extending the specified time interval into the past.</td></tr><tr><td>Externally-timed window</td><td>win:ext_timed(<span class="emphasis"><em>timestamp expression</em></span>, <span class="emphasis"><em>time period</em></span>)</td><td>Sliding time window, based on the millisecond time value supplied by an expression.</td></tr><tr><td>Time batch window</td><td>win:time_batch(<span class="emphasis"><em>time period</em></span>[,<span class="emphasis"><em>optional reference point</em></span>] [, <span class="emphasis"><em>flow control</em></span>])</td><td>Tumbling window that batches events and releases them every specified time interval, with flow control options.</td></tr><tr><td>Time-Length combination batch window</td><td>win:time_length_batch(<span class="emphasis"><em>time period, size [, flow control]</em></span>)</td><td>Tumbling multi-policy time and length batch window with flow control options.</td></tr><tr><td>Time-Accumulating window</td><td>win:time_accum(<span class="emphasis"><em>time period</em></span>)</td><td>Sliding time window accumulates events until no more events arrive within a given time interval.</td></tr><tr><td>Keep-All window</td><td>win:keepall()</td><td>The keep-all data window view simply retains all events.</td></tr><tr><td>Sorted window</td><td>ext:sort(<span class="emphasis"><em>size, sort criteria</em></span>)</td><td>Sorts by values returned by sort criteria expressions and keeps only the top events up to the given size.</td></tr><tr><td>Time-Order View</td><td>ext:time_order(<span class="emphasis"><em>timestamp expression, time period</em></span>)</td><td>Orders events that arrive out-of-order, using an expression providing timestamps to be ordered.</td></tr><tr><td>Unique</td><td>std:unique(<span class="emphasis"><em>unique criteria(s)</em></span>)</td><td>Retains only the most recent among events having the same value for the criteria expression(s). Acts as a length window of size 1 for each distinct expression value.</td></tr><tr><td>Group By</td><td>std:groupby(<span class="emphasis"><em>grouping criteria(s)</em></span>)</td><td>Groups events into sub-views by the value of the specified expression(s), generally used to provide a separate data window per group.</td></tr><tr><td>Last Event</td><td>std:lastevent()</td><td>Retains the last event, acts as a length window of size 1.</td></tr><tr><td>First Event</td><td>std:firstevent()</td><td>Retains the very first arriving event, disregarding all subsequent events.</td></tr><tr><td>First Unique</td><td>std:firstunique(<span class="emphasis"><em>unique criteria(s)</em></span>)</td><td>Retains only the very first among events having the same value for the criteria expression(s), disregarding all subsequent events for same value(s).</td></tr><tr><td>First Length</td><td>win:firstlength(<span class="emphasis"><em>size</em></span>)</td><td>Retains the first <span class="emphasis"><em>size</em></span> events, disregarding all subsequent events.</td></tr><tr><td>First Time</td><td>win:firsttime(<span class="emphasis"><em>time period</em></span>)</td><td>Retains the events arriving until the time interval has passed, disregarding all subsequent events.</td></tr></tbody></table></div><a class="indexterm" name="d0e13168"></a><p>
			The table below summarizes views that derive information from received events and present the derived information as an insert and remove stream of events that are typed specifically to carry the result of the computations: 
        </p><div class="table"><a name="d0e13175"></a><p class="title"><b>Table&nbsp;8.2.&nbsp;Built-in Derived-Value Views</b></p><table summary="Built-in Derived-Value Views" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>View</th><th>Syntax</th><th>Description</th></tr></thead><tbody><tr><td>Size</td><td>std:size()</td><td>Derives a count of the number of events in a data window, or in an insert stream if used without a data window.</td></tr><tr><td>Univariate statistics</td><td>stat:uni(<span class="emphasis"><em>value expression</em></span>)</td><td>Calculates univariate statistics on the values returned by the expression.</td></tr><tr><td>Regression</td><td>stat:linest(<span class="emphasis"><em>value expression, value expression</em></span>)</td><td>Calculates regression on the values returned by two expressions.</td></tr><tr><td>Correlation</td><td>stat:correl(<span class="emphasis"><em>value expression, value expression</em></span>)</td><td>Calculates the correlation value on the values returned by two expressions.</td></tr><tr><td>Weighted average</td><td>stat:weighted_avg(<span class="emphasis"><em>value expression, value expression</em></span>)</td><td>Calculates weighted average given a weight expression and an expression to compute the average for.</td></tr></tbody></table></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-parameters"></a>8.1.&nbsp;A Note on View Parameters</h4></div></div><div></div></div><p>
			   The syntax for view specifications starts with the namespace name and the name and is followed by optional view parameter expressions in parenthesis:
		   </p><pre class="synopsis"><span class="emphasis"><em>namespace</em></span>:<span class="emphasis"><em>name</em></span>(<span class="emphasis"><em>view_parameters</em></span>)</pre><p>
			   This example specifies a time window of 5 seconds:
		   </p><pre class="programlisting">select * from StockTickEvent.win:time(5 sec)</pre><p>
			   All expressions are allowed as parameters to views, including expressions that contain variables or substitution parameters for prepared statements.
		   </p><p>
			   For example, assuming a variable by name <tt class="literal">VAR_WINDOW_SIZE</tt> is defined:
		   </p><pre class="programlisting">select * from StockTickEvent.win:time(VAR_WINDOW_SIZE)</pre><p>
			   Expression parameters for views are evaluated at the time the view is first created. They are not continuously re-evaluated by built-in views. For applications that provide a custom plug-in view, such custom views may re-evaluate parameter expressions.
		   </p><p>
			   If a view takes no parameters, use empty parenthesis <tt class="literal">()</tt>.
		   </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="win-views"></a>8.1.&nbsp;Window views</h2></div></div><div></div></div><p>
				All the views explained below are data window views, as are <tt class="literal">std:unique</tt>, <tt class="literal">std:firstunique</tt>, <tt class="literal">std:lastevent</tt> and <tt class="literal">std:firstevent</tt>.
			</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="view-win-length"></a>8.1.1.&nbsp;Length window (<tt class="literal">win:length</tt>)</h3></div></div><div></div></div><a class="indexterm" name="d0e13296"></a><a class="indexterm" name="d0e13299"></a><a class="indexterm" name="d0e13304"></a><p>
					This view is a moving (sliding) length window extending the specified number of elements into the past. The view takes a single expression as a parameter providing a numeric size value that defines the window size:
				</p><pre class="synopsis">win:length(<span class="emphasis"><em>size_expression</em></span>)</pre><p>
					The below example sums the price for the last 5 stock ticks for symbol GE.
				</p><pre class="programlisting">select sum(price) from StockTickEvent(symbol='GE').win:length(5)</pre><p>
					The next example keeps a length window of 10 events of stock trade events, with a separate window for each symbol. The
					sum of price is calculated only for the last 10 events for each symbol.
				</p><pre class="programlisting">select sum(price) from StockTickEvent.std:groupby(symbol).win:length(10)</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="view-win-length-batch"></a>8.1.2.&nbsp;Length batch window (<tt class="literal">win:length_batch</tt>)</h3></div></div><div></div></div><a class="indexterm" name="d0e13330"></a><a class="indexterm" name="d0e13333"></a><a class="indexterm" name="d0e13338"></a><p>
					This window view buffers events (tumbling window) and releases them when a given minimum number of events has been collected. Provide an expression defining the number of events to batch as a parameter:
				</p><pre class="synopsis">win:length_batch(<span class="emphasis"><em>size_expression</em></span>)</pre><p>
					The next statement buffers events until a minimum of 10 events have collected. Listeners to updates posted by this view receive updated information only when 10 or more events have collected.
				</p><pre class="programlisting">select * from StockTickEvent.win:length_batch(10)</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="view-win-time"></a>8.1.3.&nbsp;Time window (<tt class="literal">win:time</tt>)</h3></div></div><div></div></div><a class="indexterm" name="d0e13360"></a><a class="indexterm" name="d0e13363"></a><a class="indexterm" name="d0e13368"></a><p>
					This view is a moving (sliding) time window extending the specified time interval into the past based on the system time.
					Provide a time period (see <a href="#epl-syntax-time-periods" title="4.2.1.&nbsp;Specifying Time Periods">Section&nbsp;4.2.1, &#8220;Specifying Time Periods&#8221;</a>) or an expression defining the number of seconds as a parameter:
				</p><pre class="synopsis">win:time(<span class="emphasis"><em>time period</em></span>)</pre><pre class="synopsis">win:time(<span class="emphasis"><em>seconds_interval_expression</em></span>)</pre><p>
					For the GE stock tick events in the last 1 second, calculate a sum of price.
				</p><pre class="programlisting">select sum(price) from StockTickEvent(symbol='GE').win:time(1 sec)</pre><p>
					The following time windows are equivalent specifications:
				</p><pre class="programlisting">win:time(2 minutes 5 seconds)
win:time(125 sec)
win:time(125)
win:time(MYINTERVAL)  // MYINTERVAL defined as a variable</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="view-win-ext_time"></a>8.1.4.&nbsp;Externally-timed window (<tt class="literal">win:ext_timed</tt>)</h3></div></div><div></div></div><a class="indexterm" name="d0e13401"></a><a class="indexterm" name="d0e13404"></a><a class="indexterm" name="d0e13409"></a><p>
					Similar to the time window, this view is a moving (sliding) time window extending the specified time interval into the past, but based on the millisecond
					time value supplied by a timestamp expression. The view takes two parameters: the expression to return long-typed timestamp values,
					and a time period or expression that provides a number of seconds:
				</p><pre class="synopsis">win:ext_timed(<span class="emphasis"><em>timestamp_expression</em></span>, <span class="emphasis"><em>time_period</em></span>)</pre><pre class="synopsis">win:ext_timed(<span class="emphasis"><em>timestamp_expression</em></span>, <span class="emphasis"><em>seconds_interval_expression</em></span>)</pre><p>
					The key difference comparing the externally-timed window to the regular time window is that the window slides not based on the engine time, 
					but strictly based on the result of the timestamp expression when evaluated against the events entering the window.
				</p><p>
					The algorithm underlying the view compares the timestamp value returned by the expression when the oldest event arrived with the timestamp value returned by the expression for the newest arriving event on event arrival. 
					If the time interval between the timestamp values is larger then the timer period parameter, 
					then the algorithm removes all oldest events tail-first until the difference between the oldest and newest event is within the time interval. The window
					therefore slides only when events arrive and only considers each event's timestamp property (or other expression value returned) and not engine time.
				</p><p>
					This view holds stock tick events of the last 10 seconds based on the timestamp property in <tt class="literal">StockTickEvent</tt>.
				</p><pre class="programlisting">select * from StockTickEvent.win:ext_timed(timestamp, 10 seconds)</pre><p>
					The externally-timed data window expects strict ordering of the timestamp values returned by the timestamp expression. The view is not useful for ordering events in time order, please us the time-order view instead.
				</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="view-win-time-batch"></a>8.1.5.&nbsp;Time batch window (<tt class="literal">win:time_batch</tt>)</h3></div></div><div></div></div><a class="indexterm" name="d0e13451"></a><a class="indexterm" name="d0e13454"></a><a class="indexterm" name="d0e13459"></a><p>
					This window view buffers events (tumbling window) and releases them every specified time interval in one update. The view takes a time period or an expression providing a number of seconds as a parameter, plus optional parameters described next.
				</p><pre class="synopsis">win:time_batch(<span class="emphasis"><em>time_period</em></span> [,<span class="emphasis"><em>optional_reference_point</em></span>] [,<span class="emphasis"><em>flow_control</em></span>])</pre><pre class="synopsis">win:time_batch(<span class="emphasis"><em>seconds_interval_expression</em></span> [,<span class="emphasis"><em>optional_reference_point</em></span>] [,<span class="emphasis"><em>flow_control</em></span>])</pre><p>
					The time batch window takes a second, optional parameter that serves as a reference point to batch flush times. If not specified, the arrival of the first event into the batch window sets the 
					reference point. Therefore if the reference point is not specified and the first event arrives at time t<sub>1</sub>, then the batch flushes at time t<sub>1</sub> plus <span class="emphasis"><em>time_period</em></span> and every <span class="emphasis"><em>time_period</em></span> thereafter.
				</p><p>
					The below example batches events into a 5 second window releasing new batches every 5 seconds. Listeners to updates
					posted by this view receive updated information only every 5 seconds.
				</p><pre class="programlisting">select * from StockTickEvent.win:time_batch(5 sec)</pre><p>
					By default, if there are no events arriving in the current interval (insert stream), and no events remain from the prior batch (remove stream), then the view does not post results to listeners. The view allows overriding this
					default behavior via flow control keywords.
				</p><p>
					The synopsis with flow control parameters is:
				</p><pre class="synopsis">win:time_batch(<span class="emphasis"><em>time_period or seconds_interval_expr</em></span> [,<span class="emphasis"><em>optional_reference_point</em></span>] 
    [, "flow-control-keyword [, keyword...]"] )</pre><p>
					The FORCE_UPDATE flow control keyword instructs the view to post an empty result set to listeners if there is no
					data to post for an interval. When using this keyword the <tt class="literal">irstream</tt> keyword should be used in the <tt class="literal">select</tt> clause to ensure the remove stream is also output. 
				</p><p>
					The START_EAGER flow control keyword instructs the view to post empty result sets even before the first event
					arrives, starting a time interval at statement creation time. As when using FORCE_UPDATE, the view also posts an
					empty result set to listeners if there is no data to post for an interval, however it starts doing so at time of statement
					creation rather then at the time of arrival of the first event.
				</p><p>
					Taking the two flow control keywords in one sample statement, this example presents a view that waits for 10
					seconds. It posts empty result sets after one interval after the statement is created, and keeps posting an empty result set as no events arrive during intervals:					
				</p><pre class="programlisting">select * from MyEvent.win:time_batch(10 sec, "FORCE_UPDATE, START_EAGER")</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="view-win-time-length-batch"></a>8.1.6.&nbsp;Time-Length combination batch window (<tt class="literal">win:time_length_batch</tt>)</h3></div></div><div></div></div><a class="indexterm" name="d0e13538"></a><a class="indexterm" name="d0e13541"></a><a class="indexterm" name="d0e13546"></a><p>
					This data window view is a combination of time and length batch (tumbling) windows. Similar to the time and length batch windows, this view batches events and releases the batched events when either one of the 
following conditions occurs, whichever occurs first: the data window has collected a given number of events, or a given time interval has passed.
				</p><p>
					The view parameters take 2 forms. The first form accepts a time period or an expression providing a number of seconds, and an expression for the number of events:
				</p><pre class="synopsis">win:time_length_batch(<span class="emphasis"><em>time_period</em></span>, <span class="emphasis"><em>number_of_events_expression</em></span>)</pre><pre class="synopsis">win:time_length_batch(<span class="emphasis"><em>seconds_interval_expression</em></span>, <span class="emphasis"><em>number_of_events_expression</em></span>)</pre><p>
					The next example shows a time-length combination batch window that batches up to 100 events or all events arriving within a 1-second time interval, whichever condition occurs first:
				</p><pre class="programlisting"> select * from MyEvent.win:time_length_batch(1 sec, 100)</pre><p>
					In this example, if 100 events arrive into the window before a 1-second time interval passes, the view posts the batch of 100 events. If less then 100 events arrive within a 1-second interval,
					the view posts all events that arrived within the 1-second interval at the end of the interval.
				</p><p>
					By default, if there are no events arriving in the current interval (insert stream), and no events remain from the prior batch (remove stream), then the view does not post results to listeners. This
					view allows overriding this default behavior via flow control keywords.
				</p><p>
					The synopsis of the view with flow control parameters is:
				</p><pre class="synopsis">win:time_length_batch(<span class="emphasis"><em>time_period or seconds_interval_expression</em></span>, <span class="emphasis"><em>number_of_events_expression</em></span>, 
    "<span class="emphasis"><em>flow control keyword [, keyword...]</em></span>")</pre><p>
					The <tt class="literal">FORCE_UPDATE</tt> flow control keyword instructs the view to post an empty result set to listeners if there is no data to post for an interval. The view begins posting no later then after one time interval passed after the first event arrives. When using this keyword the <tt class="literal">irstream</tt> keyword should be used in the <tt class="literal">select</tt> clause to ensure the remove stream is also output. 
				</p><p>
					The <tt class="literal">START_EAGER</tt> flow control keyword instructs the view to post empty result sets even before the first event arrives, starting a time interval at statement creation time. As when using <tt class="literal">FORCE_UPDATE</tt>, the view also posts an empty result set to listeners if there is no data to post for an interval, however it starts doing so at time of statement creation rather then at the time of arrival of the first event.
				</p><p>
					Taking the two flow control keywords in one sample statement, this example presents a view that waits for 10 seconds or reacts when the 5th event arrives, whichever comes first. It posts empty result sets after one interval after the statement is created, and keeps posting an empty result set as no events arrive during intervals: 
				</p><pre class="programlisting"> select * from MyEvent.win:time_length_batch(10 sec, 5, "FORCE_UPDATE, START_EAGER")</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="view-win-time-accumulating"></a>8.1.7.&nbsp;Time-Accumulating window (<tt class="literal">win:time_accum</tt>)</h3></div></div><div></div></div><a class="indexterm" name="d0e13621"></a><a class="indexterm" name="d0e13624"></a><a class="indexterm" name="d0e13629"></a><p>
					This data window view is a specialized moving (sliding) time window that differs from the regular time window in that it accumulates events until no more events arrive within a given time interval, and only then releases the accumulated events as a remove stream.
				</p><p>
					The view accepts a single parameter: the time period or seconds-expression specifying the length of the time interval during which no events must arrive until the view releases accumulated events. The synopsis is as follows:
				</p><pre class="synopsis">win:time_accum(<span class="emphasis"><em>time_period</em></span>)</pre><pre class="synopsis">win:time_accum(<span class="emphasis"><em>seconds_interval_expression</em></span>)</pre><p>
					The next example shows a time-accumulating window that accumulates events, and then releases events if within the time interval no more events arrive:
				</p><pre class="programlisting"> select * from MyEvent.win:time_accum(10 sec)</pre><p>
					This example accumulates events, until when for a period of 10 seconds no more MyEvent events arrive, at which time it posts all accumulated MyEvent events.
				</p><p>
					Your application may only be interested in the batches of events as events leave the data window. This can be done simply by selecting the remove stream of this data window, populated by the engine as accumulated events leave the data window all-at-once when no events arrive during the time interval following the time the last event arrived:
				</p><pre class="programlisting"> select rstream * from MyEvent.win:time_accum(10 sec)</pre><p>
					If there are no events arriving, then the view does not post results to listeners. 
				</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="view-win-keepall"></a>8.1.8.&nbsp;Keep-All window (<tt class="literal">win:keepall</tt>)</h3></div></div><div></div></div><a class="indexterm" name="d0e13666"></a><a class="indexterm" name="d0e13669"></a><a class="indexterm" name="d0e13674"></a><p>
					This keep-all data window view simply retains all events. The view does not remove events from the data window, unless used with a named window and the <tt class="literal">on delete</tt> clause.
				</p><p>
					The view accepts no parameters. The synopsis is as follows:
				</p><pre class="synopsis">win:keepall()</pre><p>
					The next example shows a keep-all window that accumulates all events received into the window:
				</p><pre class="programlisting"> select * from MyEvent.win:keepall()</pre><p>
					Note that since the view does not release events, care must be taken to prevent retained events from using all available memory.
				</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="view-win-firstlength"></a>8.1.9.&nbsp;First Length (<tt class="literal">win:firstlength</tt>)</h3></div></div><div></div></div><a class="indexterm" name="d0e13700"></a><a class="indexterm" name="d0e13703"></a><p>
					The <tt class="literal">firstlength</tt> view retains the very first <span class="emphasis"><em>size_expression</em></span> events.
				</p><p>
					The synopsis is:
				</p><pre class="synopsis">win:firstlength(<span class="emphasis"><em>size_expression</em></span>)</pre><p>
					If used within a named window and an <tt class="literal">on-delete</tt> clause deletes events, the view accepts further arriving events until the number of retained events reaches the size of <span class="emphasis"><em>size_expression</em></span>.
				</p><p>
					The below example creates a view that retains only the first 10 events:
				</p><pre class="programlisting">select * from MyEvent.win:firstlength(10)</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="view-win-firsttime"></a>8.1.10.&nbsp;First Time (<tt class="literal">win:firsttime</tt>)</h3></div></div><div></div></div><a class="indexterm" name="d0e13741"></a><a class="indexterm" name="d0e13744"></a><p>
					The <tt class="literal">firsttime</tt> view retains all events arriving within a given time interval after statement start.
				</p><p>
					The synopsis is:
				</p><pre class="synopsis">win:firsttime(<span class="emphasis"><em>time_period</em></span>)</pre><pre class="synopsis">win:firsttime(<span class="emphasis"><em>seconds_interval_expression</em></span>)</pre><p>
					The below example creates a view that retains only those events arriving within 1 minute and 10 seconds of statement start:
				</p><pre class="programlisting">select * from MyEvent.win:firsttime(1 minute 10 seconds)</pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="std-views"></a>8.2.&nbsp;Standard view set</h2></div></div><div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="view-std-unique"></a>8.2.1.&nbsp;Unique (<tt class="literal">std:unique</tt>)</h3></div></div><div></div></div><a class="indexterm" name="d0e13779"></a><a class="indexterm" name="d0e13782"></a><a class="indexterm" name="d0e13787"></a><p>
					The <tt class="literal">unique</tt> view is a view that includes only the most recent among events having the same value(s) for the result of the specified expression or list of expressions.
				</p><p>
					The synopsis is:
				</p><pre class="synopsis">std:unique(<span class="emphasis"><em>unique_expression</em></span> [, <span class="emphasis"><em>unique_expression</em></span> ...])</pre><p>
					The view acts as a length window of size 1 for each distinct value returned by an expression, or combination of values returned by multiple expressions. It thus posts as old events the prior event of the same value(s), if any.
				</p><p>
					The below example creates a view that retains only the last event per symbol.
				</p><pre class="programlisting">select * from StockTickEvent.std:unique(symbol)</pre><p>
					The next example creates a view that retains the last event per symbol and feed.
				</p><pre class="programlisting">select * from StockTickEvent.std:unique(symbol, feed)</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="view-std-groupby"></a>8.2.2.&nbsp;Group-By (<tt class="literal">std:groupby</tt>)</h3></div></div><div></div></div><a class="indexterm" name="d0e13823"></a><a class="indexterm" name="d0e13826"></a><a class="indexterm" name="d0e13831"></a><p>
					This view groups events into sub-views by the value returned by the specified expression or the combination of values returned by a list of expressions. The view takes a single expression to supply the group-by values, or a list of expressions as parameters, as the synopsis shows:
				</p><pre class="synopsis">std:groupby(<span class="emphasis"><em>grouping_expression</em></span> [, <span class="emphasis"><em>grouping_expression</em></span> ...])</pre><p>
					This example computes the total price for the last 5 events per each symbol:
				</p><pre class="programlisting">select symbol, sum(price) from StockTickEvent.std:groupby(symbol).win:length(5)</pre><p>
					The group-by view can also take multiple expressions that provide values to group by. This example computes the total price for each symbol and feed for the last 10 events per symbol and feed combination:
				</p><pre class="programlisting">select sum(price) from StockTickEvent.std:groupby(symbol, feed).win:length(10)</pre><p>
					The order in which the group-by view appears within sub-views of a stream controls the data the engine derives from events for each group. The next 2 statements demonstrate this using a length window.
				</p><p>
					By putting the group-by view in position after the length window, we can change the semantics of the query. The query now returns the total price per symbol for only the last 10 events across all symbols. Here the engine allocates only one length window for all events:
				</p><pre class="programlisting">select sum(price) from StockTickEvent.win:length(10).std:groupby(symbol)</pre><p>
					We have learned that by placing the group-by view before other views, these other views become part of the grouped set of views. The engine dynamically allocates a new view instance for each subview, every time it encounters a new group key such as a new value for symbol. Therefore, in <tt class="literal">std:groupby(symbol).win:length(10)</tt> the engine allocates a new length window for each distinct symbol. However in <tt class="literal">win:length(10).std:groupby(symbol)</tt> the engine maintains a single length window.
				</p><p>
					Multiple group-by views can also be used in the same statement. The statement below groups by symbol and feed. As the statement declares the length window after the group-by view for symbols, the engine allocates a new length window per symbol however reports total price per symbol and feed. The query results are total price per symbol and feed for the last 100 events per symbol (and not per feed).
				</p><pre class="programlisting">select sum(price) from StockTickEvent.std:groupby(symbol).win:length(100)
    .std:groupby(feed)</pre><p>
					Last, we consider the permutation where the length window is declared after the group-by. Here, the query results are total price per symbol and feed for the last 100 events per symbol and feed.
				</p><pre class="programlisting">select sum(price) from StockTickEvent.std:groupby(symbol, feed)
    .win:length(100)</pre><p>
					For advanced users: There is an optional view that can control how the group-by view gets evaluated and that view is the <tt class="literal">std:merge</tt> view. 
					The merge view can only occur after a group-by view in a view chain and controls
					at what point in the view chain the merge of the data stream occurs from view-instance-per-criteria to single view.
				</p><p>
					Compare the following statements:
				</p><pre class="programlisting">select * from Market.std:groupby(ticker).win:length(1000000)
    .stat:weighted_avg(price, volume).std:merge(ticker)
// ... and ...
select * from Market.std:groupby(ticker).win:length(1000000).std:merge(ticker)
    .stat:weighted_avg(price, volume)</pre><p>
					If your statement does not specify the optional <tt class="literal">std:merge</tt> view, the semantics are the same as the first statement.
				</p><p>
					The first statement, in which the merge-view is added to the end (same as no merge view), computes weighted average per ticker, considering, per-ticker, the last 1M Market events for each ticker.
					The second statement, in which the merge view is added to the middle, computes weighted average considering, per-ticker, the last 1M Market events, computing the weighted average for all such events using a single view rather then multiple view instances with one view per ticker. 
				</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="view-std-size"></a>8.2.3.&nbsp;Size (<tt class="literal">std:size</tt>)</h3></div></div><div></div></div><a class="indexterm" name="d0e13898"></a><a class="indexterm" name="d0e13901"></a><a class="indexterm" name="d0e13906"></a><p>
					This view posts the number of events received from a stream or view. The synopsis is:
				</p><pre class="synopsis">std:size()</pre><p>					
					The view posts a single long-typed property named <tt class="literal">size</tt>. The view posts the prior size as old data, and the current size as new data to update listeners of the view. Via the <tt class="literal">iterator</tt> method of the statement the size value can also be polled (read).
				</p><p>					
					This view provides only a single property named <tt class="literal">size</tt> and no other properties of your selected stream are available. Use the <tt class="literal">count(...)</tt> aggregation function to select other properties of your stream.
				</p><p>
					When combined with a data window view, the size view reports the current and prior number of events in the data window. This example reports the number of tick events within the last 1 minute:
				</p><pre class="programlisting">select size from StockTickEvent.win:time(1 min).std:size()</pre><p>
					The size view is also useful in conjunction with a group-by view to count the number of events per group. The EPL below returns the number of events per symbol.
				</p><pre class="programlisting">select size from StockTickEvent.std:groupby(symbol).std:size()</pre><p>
					When used without a data window, the view simply counts the number of events:
				</p><pre class="programlisting">select size from StockTickEvent.std:size()</pre><p>
					All views can be used with pattern statements as well. The next EPL snippet shows a pattern where we look for tick events followed by trade events for the same symbol. The size view counts the number of occurances of the pattern.
				</p><pre class="programlisting">select size from pattern[every s=StockTickEvent -&gt; TradeEvent(symbol=s.symbol)].std:size()</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="view-std-last"></a>8.2.4.&nbsp;Last Event (<tt class="literal">std:lastevent</tt>)</h3></div></div><div></div></div><a class="indexterm" name="d0e13953"></a><a class="indexterm" name="d0e13956"></a><a class="indexterm" name="d0e13961"></a><p>
					This view exposes the last element of its parent view:
				</p><pre class="synopsis">std:lastevent()</pre><p>
					The view acts as a length window of size 1. It thus posts as old events the prior event in the stream, if any.
				</p><p>
					This example statement retains the last stock tick event for the symbol GE. 
				</p><pre class="programlisting">select * from StockTickEvent(symbol='GE').std:lastevent()</pre><p>
					If you want to output the last event within a sliding window, please see <a href="#epl-single-row-function-ref-previous" title="7.1.8.&nbsp;The Previous Function">Section&nbsp;7.1.8, &#8220;The Previous Function&#8221;</a>. That function accepts a relative (count) or absolute index and returns event properties or an event in the context of the specified data window.
				</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="view-std-first"></a>8.2.5.&nbsp;First Event (<tt class="literal">std:firstevent</tt>)</h3></div></div><div></div></div><a class="indexterm" name="d0e13986"></a><a class="indexterm" name="d0e13989"></a><p>
					This view retains only the first arriving event:
				</p><pre class="synopsis">std:firstevent()</pre><p>
					All events arriving after the first event are discarded.
				</p><p>
					If used within a named window and an <tt class="literal">on-delete</tt> clause deletes the first event, the view resets and will retain the next arriving event.
				</p><p>
					An example of a statement that retains the first <tt class="literal">ReferenceData</tt> event arriving is:
				</p><pre class="programlisting">select * from ReferenceData.std:firstevent()</pre><p>
					If you want to output the first event within a sliding window, please see <a href="#epl-single-row-function-ref-previous" title="7.1.8.&nbsp;The Previous Function">Section&nbsp;7.1.8, &#8220;The Previous Function&#8221;</a>. That function accepts a relative (count) or absolute index and returns event properties or an event in the context of the specified data window.
				</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="view-std-firstunique"></a>8.2.6.&nbsp;First Unique (<tt class="literal">std:firstunique</tt>)</h3></div></div><div></div></div><a class="indexterm" name="d0e14022"></a><a class="indexterm" name="d0e14025"></a><p>
					The <tt class="literal">firstunique</tt> view retains only the very first among events having the same value for the specified expression or list of expressions.
				</p><p>
					The synopsis is:
				</p><pre class="synopsis">std:firstunique(<span class="emphasis"><em>unique_expression</em></span> [, <span class="emphasis"><em>unique_expression</em></span> ...])</pre><p>
					If used within a named window and an <tt class="literal">on-delete</tt> clause deletes events, the view resets and will retain the next arriving event for the expression result value(s) of the deleted events.
				</p><p>
					The below example creates a view that retains only the first event per category:
				</p><pre class="programlisting">select * from ReferenceData.std:firstunique(category)</pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="stat-views"></a>8.3.&nbsp;Statistics views</h2></div></div><div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="view-stat-uni"></a>8.3.1.&nbsp;Univariate statistics (<tt class="literal">stat:uni</tt>)</h3></div></div><div></div></div><a class="indexterm" name="d0e14063"></a><a class="indexterm" name="d0e14066"></a><a class="indexterm" name="d0e14071"></a><p>
					This view calculates univariate statistics on a numeric expression. The view takes a single expression as a parameter. The expression must return a numeric value:
				</p><pre class="synopsis">stat:uni(<span class="emphasis"><em>value_expression</em></span>)</pre><div class="table"><a name="view-stat-uni-table"></a><p class="title"><b>Table&nbsp;8.3.&nbsp;Univariate statistics derived properties</b></p><table summary="Univariate statistics derived properties" border="1"><colgroup><col><col></colgroup><thead><tr><th>Property Name</th><th>Description</th></tr></thead><tbody><tr><td><tt class="literal">datapoints</tt></td><td>Number of values, equivalent to <tt class="literal">count(*)</tt> for the stream</td></tr><tr><td><tt class="literal">total</tt></td><td>Sum of values</td></tr><tr><td><tt class="literal">average</tt></td><td>Average of values</td></tr><tr><td><tt class="literal">variance</tt></td><td>Variance</td></tr><tr><td><tt class="literal">stdev</tt></td><td>Sample standard deviation (square root of variance) </td></tr><tr><td><tt class="literal">stdevpa</tt></td><td>Population standard deviation</td></tr></tbody></table></div><p>
					The below example selects the standard deviation on price for stock tick events for the last 10 events.
				</p><pre class="programlisting">select stdev from StockTickEvent.win:length(10).stat:uni(price)</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="view-stat-linest"></a>8.3.2.&nbsp;Regression (<tt class="literal">stat:linest</tt>)</h3></div></div><div></div></div><a class="indexterm" name="d0e14145"></a><a class="indexterm" name="d0e14148"></a><a class="indexterm" name="d0e14153"></a><p>
					This view calculates regression and related intermediate results on the values returned by two expressions. The view takes two expressions as parameters. The expressions must return a numeric value:
				</p><pre class="synopsis">stat:linest(<span class="emphasis"><em>value_expression</em></span>, <span class="emphasis"><em>value_expression</em></span>)</pre><div class="table"><a name="view-stat-linest-table"></a><p class="title"><b>Table&nbsp;8.4.&nbsp;Regression derived properties</b></p><table summary="Regression derived properties" border="1"><colgroup><col><col></colgroup><thead><tr><th>Property Name</th><th>Description</th></tr></thead><tbody><tr><td><tt class="literal">slope</tt></td><td>Slope.</td></tr><tr><td><tt class="literal">YIntercept</tt></td><td>Y intercept.</td></tr><tr><td><tt class="literal">XAverage</tt></td><td>X average.</td></tr><tr><td><tt class="literal">XStandardDeviationPop</tt></td><td>X standard deviation population.</td></tr><tr><td><tt class="literal">XStandardDeviationSample</tt></td><td>X standard deviation sample.</td></tr><tr><td><tt class="literal">XSum</tt></td><td>X sum.</td></tr><tr><td><tt class="literal">XVariance</tt></td><td>X variance.</td></tr><tr><td><tt class="literal">YAverage</tt></td><td>X average.</td></tr><tr><td><tt class="literal">YStandardDeviationPop</tt></td><td>Y standard deviation population.</td></tr><tr><td><tt class="literal">YStandardDeviationSample</tt></td><td>Y standard deviation sample.</td></tr><tr><td><tt class="literal">YSum</tt></td><td>Y sum.</td></tr><tr><td><tt class="literal">YVariance</tt></td><td>Y variance.</td></tr><tr><td><tt class="literal">dataPoints</tt></td><td>Number of data points.</td></tr><tr><td><tt class="literal">n</tt></td><td>Number of data points.</td></tr><tr><td><tt class="literal">sumX</tt></td><td>Sum of X (same as X Sum).</td></tr><tr><td><tt class="literal">sumXSq</tt></td><td>Sum of X squared.</td></tr><tr><td><tt class="literal">sumXY</tt></td><td>Sum of X times Y.</td></tr><tr><td><tt class="literal">sumY</tt></td><td>Sum of Y (same as Y Sum).</td></tr><tr><td><tt class="literal">sumYSq</tt></td><td>Sum of Y squared.</td></tr></tbody></table></div><p>
					Calculate regression and return the slope and y-intercept on price and offer for all events in the last 10 seconds.
				</p><pre class="programlisting">select slope, YIntercept from StockTickEvent.win:time(10 seconds).stat:linest(price, offer)</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="view-stat-correl"></a>8.3.3.&nbsp;Correlation (<tt class="literal">stat:correl</tt>)</h3></div></div><div></div></div><a class="indexterm" name="d0e14305"></a><a class="indexterm" name="d0e14308"></a><a class="indexterm" name="d0e14313"></a><p>
					This view calculates the correlation value on the value returned by two expressions. The view takes two expressions as parameters. The expressions must be return a numeric value:
				</p><pre class="synopsis">stat:correl(<span class="emphasis"><em>value_expression</em></span>, <span class="emphasis"><em>value_expression</em></span>)</pre><div class="table"><a name="view-stat-correl-table"></a><p class="title"><b>Table&nbsp;8.5.&nbsp;Correlation derived properties</b></p><table summary="Correlation derived properties" border="1"><colgroup><col><col></colgroup><thead><tr><th>Property Name</th><th>Description</th></tr></thead><tbody><tr><td><tt class="literal">correlation</tt></td><td>Correlation between two event properties</td></tr></tbody></table></div><p>
					Calculate correlation on price and offer over all stock tick events for GE.
				</p><pre class="programlisting">select correlation from StockTickEvent(symbol='GE').stat:correl(price, offer)</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="view-stat-weightedavg"></a>8.3.4.&nbsp;Weighted average (<tt class="literal">stat:weighted_avg</tt>)</h3></div></div><div></div></div><a class="indexterm" name="d0e14357"></a><a class="indexterm" name="d0e14360"></a><a class="indexterm" name="d0e14365"></a><p>
					This view returns the weighted average given an expression returning values to compute the average for and an expression returning weight. The view takes two expressions as parameters. The expressions must return numeric values:
				</p><pre class="synopsis">stat:weighted_avg(<span class="emphasis"><em>value_expression_field</em></span>, <span class="emphasis"><em>value_expression_weight</em></span>)</pre><div class="table"><a name="view-stat-weightedavg-table"></a><p class="title"><b>Table&nbsp;8.6.&nbsp;Weighted average derived properties</b></p><table summary="Weighted average derived properties" border="1"><colgroup><col><col></colgroup><thead><tr><th>Property Name</th><th>Description</th></tr></thead><tbody><tr><td><tt class="literal">average</tt></td><td>Weighted average</td></tr></tbody></table></div><p>
					A statement that derives the volume-weighted average price for the last 3 seconds:
				</p><pre class="programlisting">select average 
from StockTickEvent(symbol='GE').win:time(3 seconds).stat:weighted_avg(price, volume)</pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ext-views"></a>8.4.&nbsp;Extension View Set</h2></div></div><div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="view-ext-sort"></a>8.4.1.&nbsp;Sorted Window View (<tt class="literal">ext:sort</tt>)</h3></div></div><div></div></div><a class="indexterm" name="d0e14412"></a><a class="indexterm" name="d0e14415"></a><a class="indexterm" name="d0e14420"></a><p>					
					This view sorts by values returned by the specified expressionor list of expressions and keeps only the top (or bottom) events up to the given size. 
				</p><p>
					The syntax is as follows:
				</p><pre class="synopsis">ext:sort(<span class="emphasis"><em>size_expression</em></span>, 
    <span class="emphasis"><em>sort_criteria_expression</em></span> [asc/desc][, <span class="emphasis"><em>sort_criteria_expression</em></span> [asc/desc]...]) </pre><p>					
					An expression may be followed by the optional <tt class="literal">asc</tt> or <tt class="literal">desc</tt> keywords to indicate that the values returned by that expression are sorted in ascending or descending sort order.
				</p><p>
					The view below retains only those events that have the highest 10 prices and reports a total price:
				</p><pre class="programlisting">select sum(price) from StockTickEvent.ext:sort(10, price desc)</pre><p>
					The following example sorts events first by price in descending order, and then by symbol name in ascending (alphabetical) order, keeping only the 10
events with the highest price (with ties resolved by alphabetical order of symbol).
				</p><pre class="programlisting">select * from StockTickEvent.ext:sort(10, price desc, symbol asc)</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="view-time-order"></a>8.4.2.&nbsp;Time-Order View (<tt class="literal">ext:time_order</tt>)</h3></div></div><div></div></div><a class="indexterm" name="d0e14462"></a><a class="indexterm" name="d0e14465"></a><a class="indexterm" name="d0e14470"></a><p>
					This view orders events that arrive out-of-order, using timestamp-values provided by an expression, and by comparing that timestamp value to engine system time.
				</p><p>
					The syntax for this view is as follows.
				</p><pre class="synopsis">ext:time_order(<span class="emphasis"><em>timestamp_expression</em></span>, <span class="emphasis"><em>time_period</em></span>)</pre><pre class="synopsis">ext:time_order(<span class="emphasis"><em>timestamp_expression</em></span>, <span class="emphasis"><em>seconds_interval_expression</em></span>)</pre><p>
					The first parameter to the view is the expression that supplies timestamp values. The timestamp is expected to be a long-typed millisecond value that denotes an event's time of consideration by the view (or other expression). This is typically the time of arrival. The second parameter is a number-of-seconds expression or the time period specifying the time interval that an arriving event should maximally be held, in order to consider older events arriving at a later time.
				</p><p>
					Since the view compares timestamp values to engine time, the view requires that the timestamp values and current engine time are both following the same clock. Therefore, to the extend that the clocks that originated both timestamps differ, the view may produce inaccurate results.
				</p><p>
					As an example, the next statement uses the <tt class="literal">arrival_time</tt> property of <tt class="literal">MyTimestampedEvent</tt> events to order and release events by arrival time:
				</p><pre class="programlisting">insert rstream into ArrivalTimeOrderedStream
select rstream * from MyTimestampedEvent.ext:time_order(arrival_time, 10 sec)</pre><p>
					In the example above, the <tt class="literal">arrival_time</tt> property holds a long-typed timestamp value in milliseconds. On arrival of an event, the engine compares the timestamp value of each event to the tail-time of the window. The tail-time of the window is, in this example, 10 seconds before engine time (continuously sliding). If the timestamp value indicates that the event is older then the tail-time of the time window, the event is released immediately in the remove stream. If the timestamp value indicates that the event is newer then the tail-time of the window, the view retains the event until engine time moves such that the event timestamp is older then tail-time.
				</p><p>
					The examples thus holds each arriving event in memory anywhere from zero seconds to 10 seconds, to allow for older events (considering arrival time timestamp) to arrive. In other words, the view holds an event with an arrival time equal to engine time for 10 seconds. The view holds an event with an arrival time that is 2 seconds older then engine time for 8 seconds. The view holds an event with an arrival time that is 10 or more seconds older then engine time for zero seconds, and releases such (old) events immediately into the remove stream. 
				</p><p>
					The insert stream of this sliding window consists of all arriving events. The remove stream of the view is ordered by timestamp value: The event that has the oldest timestamp value is released first, followed by the next newer events. Note the statement above uses the <tt class="literal">rstream</tt> keyword in both the <tt class="literal">insert into</tt> clause and the <tt class="literal">select</tt> clause to select ordered events only. It uses the <tt class="literal">insert into</tt> clause to makes such ordered stream available for subsequent statements to use.
				</p><p>
					It is up to your application to populate the timestamp property into your events or use a sensible expression that returns timestamp values for consideration by the view. The view also works well if you use externally-provided time via timer events. 
				</p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="api"></a>Chapter&nbsp;9.&nbsp;API Reference</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="api-reference-intro"></a>9.1.&nbsp;API Overview</h2></div></div><div></div></div><p>
			Esper has the following primary interfaces:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
                    The event and event type interfaces are described in <a href="#api-event" title="9.5.&nbsp;Event and Event Type">Section&nbsp;9.5, &#8220;Event and Event Type&#8221;</a>.
                </p></li><li><p>
                    The administrative interface to create and manage EPL and pattern statements, and set runtime configurations, is described in <a href="#api-administrative" title="9.3.&nbsp;The Administrative Interface">Section&nbsp;9.3, &#8220;The Administrative Interface&#8221;</a>.
                </p></li><li><p>
			        The runtime interface to send events into the engine, set and get variable values and execute on-demand queries, is described in <a href="#api-runtime" title="9.4.&nbsp;The Runtime Interface">Section&nbsp;9.4, &#8220;The Runtime Interface&#8221;</a>.
                </p></li></ul></div><p>
          For EPL introductory information please see <a href="#epl-intro" title="4.1.&nbsp;EPL Introduction">Section&nbsp;4.1, &#8220;EPL Introduction&#8221;</a> and patterns are described at <a href="#event-pattern-intro" title="5.1.&nbsp;Event Pattern Overview">Section&nbsp;5.1, &#8220;Event Pattern Overview&#8221;</a>.
        </p><p>
			The JavaDoc documentation is also a great source for API information.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="api-engine-instances"></a>9.2.&nbsp;The Service Provider Interface</h2></div></div><div></div></div><a class="indexterm" name="d0e14567"></a><p>
			The <tt class="literal">EPServiceProvider</tt> interface represents an engine instance. Each instance of an Esper engine is completely independent of other engine instances and has its own administrative and runtime interface.
        </p><p>
			An instance of the Esper engine is obtained via static methods on the <tt class="literal">EPServiceProviderManager</tt> class.
			The <tt class="literal">getDefaultProvider</tt> method and the <tt class="literal">getProvider(String providerURI)</tt> methods return an instance of the Esper engine.
			The latter can be used to obtain multiple instances of the engine for different provider URI values. The <tt class="literal">EPServiceProviderManager</tt>
			determines if the provider URI matches all prior provider URI values and returns the same engine instance for the same provider URI value. If the provider URI has not been seen before, it creates a new engine instance.
        </p><p>
			The code snipped below gets the default instance Esper engine. Subsequent calls to get the default engine instance return the same instance.
        </p><pre class="programlisting">EPServiceProvider epService = EPServiceProviderManager.getDefaultProvider();</pre><p>
			This code snippet gets an Esper engine for the provider URI <tt class="literal">RFIDProcessor1</tt>. Subsequent calls to get an engine with the same provider URI return the same instance.
        </p><pre class="programlisting">EPServiceProvider epService = EPServiceProviderManager.getProvider("RFIDProcessor1");</pre><p>
			Since the <tt class="literal">getProvider</tt> methods return the same cached engine instance for each URI, there is no need to statically cache an engine instance in your application.
			An existing Esper engine instance can be reset via the <tt class="literal">initialize</tt> method on the <tt class="literal">EPServiceProvider</tt> instance. This operation stops and removes all statements and 
			resets the engine to the configuration provided when the engine instance was originally obtained. After an <tt class="literal">initialize</tt> the engine is ready for use.
        </p><p>
			An existing Esper engine instance can be reset via the <tt class="literal">initialize</tt> method on the <tt class="literal">EPServiceProvider</tt> instance. This operation stops and removes all statements in the Engine as well as restores the engine to the original configuration supplied when the engine instance for that URI was obtained. If no configuration is provided, an empty configuration applies.
        </p><p>
			The next code snippet outlines a typical sequence of use: 
        </p><pre class="programlisting">// Configure the engine, this is optional
Configuration config = new Configuration();
config.configure("configuration.xml");	// load a configuration from file
config.set....(...);    // make additional configuration settings

// Obtain an engine instance
EPServiceProvider epService = EPServiceProviderManager.getDefaultProvider(config);

// Optionally, use initialize if the same engine instance has been used before to start clean
epService.initialize();

// Optionally, make runtime configuration changes
epService.getEPAdministrator().getConfiguration().add...(...);

// Destroy the engine instance when no longer needed, frees up resources
epService.destroy();</pre><p>
			An existing Esper engine instance can be destroyed via the <tt class="literal">destroy</tt> method on the <tt class="literal">EPServiceProvider</tt> instance. This stops and removes all statements
			as well as frees all resources held by the instance. After a <tt class="literal">destroy</tt> the engine can no longer be used.
        </p><p>
			The <tt class="literal">EPServiceStateListener</tt> interface may be implemented by your application to receive callbacks when an engine instance is about to be destroyed and after an engine instance has been initialized. Listeners are registered via the <tt class="literal">addServiceStateListener</tt> method. The <tt class="literal">EPStatementStateListener</tt> interface is used to receive callbacks when a new statement gets created and when a statement gets started, stopped or destroyed. Listeners are registered via the <tt class="literal">addStatementStateListener</tt> method.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="api-administrative"></a>9.3.&nbsp;The Administrative Interface</h2></div></div><div></div></div><a class="indexterm" name="d0e14654"></a><a class="indexterm" name="d0e14657"></a><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="api-admin-creating"></a>9.3.1.&nbsp;Creating Statements</h3></div></div><div></div></div><p>
				Create event pattern expression and EPL  statements via the administrative interface <tt class="literal">EPAdministrator</tt>.
			</p><p>
				This code snippet gets an Esper engine then creates an event pattern and an EPL  statement.
			</p><pre class="programlisting">EPServiceProvider epService = EPServiceProviderManager.getDefaultProvider();
EPAdministrator admin = epService.getEPAdministrator();

EPStatement 10secRecurTrigger = admin.createPattern(
  "every timer:at(*, *, *, *, *, */10)");

EPStatement countStmt = admin.createEPL(
  "select count(*) from MarketDataBean.win:time(60 sec)");
</pre><p>
				Note that event pattern expressions can also occur within EPL  statements. This is outlined in more detail in <a href="#epl-from-clause-patterns" title="4.4.2.&nbsp;Pattern-based Event Streams">Section&nbsp;4.4.2, &#8220;Pattern-based Event Streams&#8221;</a>.
			</p><p>
				The <tt class="literal">create</tt> methods on <tt class="literal">EPAdministrator</tt> are overloaded and allow an optional statement name to be passed to the engine. A statement name can be useful for retrieving a statement
				by name from the engine at a later time. The engine assigns a statement name if no statement name is supplied on statement creation.
			</p><p>
				The <tt class="literal">createPattern</tt> and <tt class="literal">createEPL</tt> methods return <tt class="literal">EPStatement</tt> instances. Statements are automatically started and active when created. A statement can also be stopped and started again via the <tt class="literal">stop</tt> and <tt class="literal">start</tt> methods shown in the code snippet below.
			</p><pre class="programlisting">countStmt.stop();
countStmt.start();</pre><p>
				The <tt class="literal">create</tt> methods on <tt class="literal">EPAdministrator</tt> also accept a user object.  
				The user object is associated with a statement at time of statement creation and is a single, unnamed field that is stored with every statement.
				Applications may put arbitrary objects in this field. Use the <tt class="literal">getUserObject</tt> method on <tt class="literal">EPStatement</tt> to obtain the user object of a statement
				and <tt class="literal">StatementAwareUpdateListener</tt> for listeners.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="api-receive-results"></a>9.3.2.&nbsp;Receiving Statement Results</h3></div></div><div></div></div><a class="indexterm" name="d0e14723"></a><p>
				Esper provides three choices for your application to receive statement results. Your application can use all three mechanisms alone or in any combination for each statement. The choices are:
			</p><div class="table"><a name="api-admin-receive-results"></a><p class="title"><b>Table&nbsp;9.1.&nbsp;Choices For Receiving Statement Results</b></p><table summary="Choices For Receiving Statement Results" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>Name</th><th>Methods on <tt class="literal">EPStatement</tt></th><th>Description</th></tr></thead><tbody><tr><td>Listener Callbacks</td><td><tt class="literal">addListener</tt> and <tt class="literal">removeListener</tt></td><td><p> 
									Your application provides implementations of the <tt class="literal">UpdateListener</tt> or the <tt class="literal">StatementAwareUpdateListener</tt> interface to the statement. 
									Listeners receive <tt class="literal">EventBean</tt> instances containing statement results.
								</p><p>The engine continuously indicates results to all listeners as soon they occur, and following output rate limiting clauses if specified.</p></td></tr><tr><td>Subscriber Object</td><td><tt class="literal">setSubscriber</tt></td><td><p>
                                    Your application provides a POJO (plain Java object) that exposes methods to receive statement results.
                                </p><p>The engine continuously indicates results to the single subscriber as soon they occur, and following output rate limiting clauses if specified.</p><p>
                                    This is the fastest method to receive statement results, as the engine delivers strongly-typed results directly to your application objects without the need for
                                    building an <tt class="literal">EventBean</tt> result set as in the Listener Callback choice.
                                </p><p>
                                    There can be at most 1 Subscriber Object registered per statement. If you require more than one listener, use the Listener Callback instead (or in addition).
                                    The Subscriber Object is bound to the statement with a strongly typed support which ensure direct delivery of new events without type conversion. This optimization
                                    is made possible because there can only be 0 or 1 Subscriber Object per statement.
                                </p></td></tr><tr><td>Pull API</td><td><tt class="literal">safeIterator</tt> and <tt class="literal">iterator</tt></td><td><p>Your application asks the statement for results and receives a set of events via <tt class="literal">java.util.Iterator&lt;EventBean&gt;</tt>.</p><p>This is useful if your application does not need continuous indication of new results in real-time.</p></td></tr></tbody></table></div><p>
				Your application may attach one or more listeners, zero or one single subscriber and in addition use the Pull API on the same statement. There are no limitations to the use of iterator, subscriber or listener
				alone or in combination to receive statement results.
			</p><p>
				The best delivery performance can generally be achieved by attaching a subscriber and by not attaching listeners.
                The engine is aware of the listeners and subscriber attached to a statement. The engine uses this information internally to reduce statement overhead. For example, if your statement does not have listeners or a subscriber attached, the engine does not need to continuously generate results for delivery.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="api-admin-subscriber"></a>9.3.3.&nbsp;Setting a Subscriber Object</h3></div></div><div></div></div><a class="indexterm" name="d0e14813"></a><a class="indexterm" name="d0e14816"></a><p>
				A subscriber object is a direct binding of query results to a Java object. The object, a POJO, receives statement results via method invocation. The subscriber class need not implement an interface or extend a superclass.
			</p><p>
			  Subscriber objects have several advantages over listeners. First, they offer a substantial performance benefit: Query results are delivered directly to your method(s) through Java virtual machine method calls, and there is no intermediate representation (<tt class="literal">EventBean</tt>). Second, as subscribers receive strongly-typed parameters, the subscriber code tends to be simpler.
			</p><p>
			  This chapter describes the requirements towards the methods provided by your subscriber class.
			</p><p>
			  The engine can deliver results to your subscriber in two ways:			 
			</p><div class="orderedlist"><ol type="1"><li><p>
						Each evert in the insert stream results in a method invocation, and each event in the remove stream results in further method invocations. This is termed <span class="emphasis"><em>row-by-row delivery</em></span>.
					</p></li><li><p>
						A single method invocation that delivers all rows of the insert and remove stream. This is termed <span class="emphasis"><em>multi-row</em></span> delivery.
					</p></li></ol></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="api-admin-subscriber-rowbyrow"></a>9.3.3.1.&nbsp;Row-By-Row Delivery</h4></div></div><div></div></div><a class="indexterm" name="d0e14848"></a><p>
					Your subscriber class must provide a method by name <tt class="literal">update</tt> to receive insert stream events row-by-row. The number and types of parameters declared by the <tt class="literal">update</tt> method must match the number and types of columns as specified in the <tt class="literal">select</tt> clause, in the same order as in the <tt class="literal">select</tt> clause.
				</p><p>
					For example, if your statement is:
				</p><pre class="programlisting">select orderId, price, count(*) from OrderEvent</pre><p>
					Then your subscriber <tt class="literal">update</tt> method looks as follows:
				</p><pre class="programlisting">public class MySubscriber {
  ...
  public void update(String orderId, double price, long count) {...}
  ...
}</pre><p>
					Each method parameter declared by the <tt class="literal">update</tt> method must be assignable from the respective column type as listed in the <tt class="literal">select</tt>-clause, in the order selected. The assignability rules are:
				</p><div class="itemizedlist"><ul type="disc" compact><li><p>
							Widening of types follows Java standards. For example, if your <tt class="literal">select</tt> clause selects an integer value, the method parameter for the same column can be typed int, long, float or double (or any equivalent boxed type).
						</p></li><li><p>
							Auto-boxing and unboxing follows Java standards. For example, if your <tt class="literal">select</tt> clause selects an <tt class="literal">java.lang.Integer</tt> value, the method parameter for the same column can be typed <tt class="literal">int</tt>. Note that if your <tt class="literal">select</tt> clause column may generate <tt class="literal">null</tt> values, an exception may occur at runtime unboxing the <tt class="literal">null</tt> value.
						</p></li><li><p>
							Interfaces and super-classes are honored in the test for assignability. Therefore <tt class="literal">java.lang.Object</tt> can be used to accept any <tt class="literal">select</tt> clause column type
						</p></li></ul></div><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="api-admin-subscriber-rowbyrow-wildcard"></a>9.3.3.1.1.&nbsp;Wildcards</h5></div></div><div></div></div><p>
						If your <tt class="literal">select</tt> clause contains one or more wildcards (*), then the equivalent parameter type is the underlying event type of the stream selected from.
					</p><p>
						For example, your statement may be:
					</p><pre class="programlisting">select *, count(*) from OrderEvent</pre><p>
						Then your subscriber <tt class="literal">update</tt> method looks as follows:
					</p><pre class="programlisting">public void update(OrderEvent orderEvent, long count) {...}</pre><p>
						In a join, the wildcard expands to the underlying event type of each stream in the join in the order the streams occur in the <tt class="literal">from</tt> clause. An example statement for a join is:
					</p><pre class="programlisting">select *, count(*) from OrderEvent order, OrderHistory hist</pre><p>
						Then your subscriber <tt class="literal">update</tt> method should be:
					</p><pre class="programlisting">public void update(OrderEvent orderEvent, OrderHistory orderHistory, long count) {...}</pre><p>
						The stream wildcard syntax and the stream name itself can also be used:
					</p><pre class="programlisting">select hist.*, order from OrderEvent order, OrderHistory hist</pre><p>
						The matching <tt class="literal">update</tt> method is:
					</p><pre class="programlisting">public void update(OrderHistory orderHistory, OrderEvent orderEvent) {...}</pre></div><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="api-admin-subscriber-rowbyrow-generic"></a>9.3.3.1.2.&nbsp;Row Delivery as Map and Object Array </h5></div></div><div></div></div><p>
						Alternatively, your <tt class="literal">update</tt> method may simply choose to accept <tt class="literal">java.util.Map</tt> as a representation for each row. Each column in the <tt class="literal">select</tt> clause is 
						then made an entry in the resulting <tt class="literal">Map</tt>. The <tt class="literal">Map</tt> keys are the column name if supplied, or the expression string itself for columns without a name.
					</p><p>
						The <tt class="literal">update</tt> method for <tt class="literal">Map</tt> delivery is:
					</p><pre class="programlisting">public void update(Map row) {...}</pre><p>
						The engine also supports delivery of <tt class="literal">select</tt> clause columns as an object array. Each item in the object array represents a column in the <tt class="literal">select</tt> clause. The <tt class="literal">update</tt> method then looks as follows:
					</p><pre class="programlisting">public void update(Object[] row) {...}</pre></div><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="api-admin-subscriber-rowbyrow-rstream"></a>9.3.3.1.3.&nbsp;Delivery of Remove Stream Events</h5></div></div><div></div></div><p>
						Your subscriber receives remove stream events if it provides a method named <tt class="literal">updateRStream</tt>. The method must accept the same number and types of parameters as the <tt class="literal">update</tt> method.
					</p><p>
						An example statement:
					</p><pre class="programlisting">select orderId, count(*) from OrderEvent.win:time(20 sec) group by orderId</pre><p>
						Then your subscriber <tt class="literal">update</tt> and <tt class="literal">updateRStream</tt> methods should be:
					</p><pre class="programlisting">public void update(String, long count) {...}
public void updateRStream(String orderId, long count) {...}</pre></div><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="api-admin-subscriber-rowbyrow-beginend"></a>9.3.3.1.4.&nbsp;Delivery of Begin and End Indications</h5></div></div><div></div></div><p>
						If your subscriber requires a notification for begin and end of event delivery, it can expose methods by name <tt class="literal">start</tt> and <tt class="literal">end</tt>. 
					</p><p>
						The <tt class="literal">start</tt> method must take two integer parameters that indicate the number of events of the insert stream and remove stream to be delivered. The engine invokes the <tt class="literal">start</tt> method immediately prior to delivering events to the <tt class="literal">update</tt> and <tt class="literal">updateRStream</tt> methods.
					</p><p>
						The <tt class="literal">end</tt> method must take no parameters. The engine invokes the <tt class="literal">end</tt> method immediately after delivering events to the <tt class="literal">update</tt> and <tt class="literal">updateRStream</tt> methods.
					</p><p>
						An example set of delivery methods:
					</p><pre class="programlisting">// Called by the engine before delivering events to update methods
public void start(int insertStreamLength, int removeStreamLength)

// To deliver insert stream events
public void update(String orderId, long count) {...}

// To deliver remove stream events
public void updateRStream(String orderId, long count) {...}

// Called by the engine after delivering events
public void end() {...}</pre></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="api-admin-subscriber-multirow"></a>9.3.3.2.&nbsp;Multi-Row Delivery</h4></div></div><div></div></div><a class="indexterm" name="d0e15081"></a><p>
					In place of row-by-row delivery, your subscriber can receive all events in the insert and remove stream via a single method invocation. 
				</p><p>
					The event delivery follow the scheme as described earlier in <a href="#api-admin-subscriber-rowbyrow-generic" title="9.3.3.1.2.&nbsp;Row Delivery as Map and Object Array ">Section&nbsp;9.3.3.1.2, &#8220;Row Delivery as Map and Object Array &#8221;</a>. The subscriber class must provide one of the following methods:
				</p><div class="table"><a name="api-admin-subscriber-multirow-underlying"></a><p class="title"><b>Table&nbsp;9.2.&nbsp;Update Method for Multi-Row Delivery of Underlying Events</b></p><table summary="Update Method for Multi-Row Delivery of Underlying Events" border="1"><colgroup><col><col></colgroup><thead><tr><th>Method</th><th>Description</th></tr></thead><tbody><tr><td><tt class="literal">update(Object[][] insertStream, Object[][] removeStream)</tt></td><td><p>The first dimension of each Object array is the event row, and the second dimension is the column matching the column order of the statement <tt class="literal">select</tt> clause</p></td></tr><tr><td><tt class="literal">update(Map[] insertStream, Map[] removeStream)</tt></td><td><p> Each map represents one event, and Map entries represent columns of the statement <tt class="literal">select</tt> clause</p></td></tr></tbody></table></div><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="api-admin-subscriber-multirow-wildcard"></a>9.3.3.2.1.&nbsp;Wildcards</h5></div></div><div></div></div><p>
						If your <tt class="literal">select</tt> clause contains a single wildcard (*) or wildcard stream selector, the subscriber object may also directly receive arrays of the underlying events. In this case, the subscriber class should provide a method <tt class="literal">update(</tt><span class="emphasis"><em>Underlying</em></span><tt class="literal">[] insertStream, </tt><span class="emphasis"><em>Underlying</em></span>[] <span class="emphasis"><em>removeStream</em></span><tt class="literal">)</tt> , such that <span class="emphasis"><em>Underlying</em></span> represents the class of the underlying event.
					</p><p>
						For example, your statement may be:
					</p><pre class="programlisting">select * from OrderEvent.win:time(30 sec)</pre><p>
						Your subscriber class exposes the method:
					</p><pre class="programlisting">public void update(OrderEvent[] insertStream, OrderEvent[] removeStream) {...}</pre></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="api-admin-listeners"></a>9.3.4.&nbsp;Adding Listeners</h3></div></div><div></div></div><a class="indexterm" name="d0e15161"></a><a class="indexterm" name="d0e15164"></a><p>
				Your application can subscribe to updates posted by a statement via the <tt class="literal">addListener</tt> and <tt class="literal">removeListener</tt> methods on <tt class="literal">EPStatement</tt> . Your application must to provide an implementation of the <tt class="literal">UpdateListener</tt> or the <tt class="literal">StatementAwareUpdateListener</tt> interface to the statement:
			</p><pre class="programlisting">UpdateListener myListener = new MyUpdateListener();
countStmt.addListener(myListener);</pre><p>			
				EPL statements and event patterns publish old data and new data to registered <tt class="literal">UpdateListener</tt> listeners. 
				New data published by statements is the events representing the new values of derived data held by the statement.
				Old data published by statements constists of the events representing the prior values of derived data held by the statement.
			</p><p>			
				It is important to understand that <tt class="literal">UpdateListener</tt> listeners receive multiple result rows in one invocation by the engine: the new data and old data parameters to your listener are array parameters. For example, if your application uses one of the batch data windows, or your application creates a pattern that matches multiple times when a single event arrives, then the engine indicates such multiple result rows in one invocation and your new data array carries two or more rows.
			</p><p>			
				A second listener interface is the <tt class="literal">StatementAwareUpdateListener</tt> interface. A <tt class="literal">StatementAwareUpdateListener</tt> is especially useful for registering the same listener object with multiple statements, 
				as the listener receives the statement instance and engine instance in addition to new and old data when the engine indicates new results to a listener.
			</p><pre class="programlisting">StatementAwareUpdateListener myListener = new MyStmtAwareUpdateListener();
statement.addListener(myListener);</pre><p>			
				To indicate results the engine invokes this method on <tt class="literal">StatementAwareUpdateListener</tt> listeners: <tt class="literal">update(EventBean[] newEvents, EventBean[] oldEvents, EPStatement statement, EPServiceProvider epServiceProvider)</tt>
			</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="api-admin-listeners-replay"></a>9.3.4.1.&nbsp;Subscription Snapshot  and Atomic Delivery</h4></div></div><div></div></div><p>
					The <tt class="literal">addListenerWithReplay</tt> method provided by <tt class="literal">EPStatement</tt> makes it possible to send a snapshot of current statement results to a listener when the listener is added.
				</p><p>
					When using the <tt class="literal">addListenerWithReplay</tt> method to register a listener, the listener receives current statement results as the first call to the update method of the listener, passing in the newEvents parameter the current statement results as an array of zero or more events. Subsequent calls to the update method of the listener are statement results.   
				</p><p>
					Current statement results are the events returned by the <tt class="literal">iterator</tt> or <tt class="literal">safeIterator</tt> methods.
				</p><p>
					Delivery is atomic: Events occurring during delivery of current results to the listener are guaranteed to be delivered in a separate call and not lost. The listener implementation should thus minimize long-running or blocking operations to reduce lock times held on statement-level resources.
				</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="api-admin-iterators"></a>9.3.5.&nbsp;Using Iterators</h3></div></div><div></div></div><a class="indexterm" name="d0e15243"></a><a class="indexterm" name="d0e15246"></a><a class="indexterm" name="d0e15249"></a><p>
				Subscribing to events posted by a statement is following a push model. The engine pushes data to listeners when events are received that cause data to change or patterns to match. Alternatively, you need to know that statements serve up data that your application can obtain via the <tt class="literal">safeIterator</tt> and <tt class="literal">iterator</tt> methods on <tt class="literal">EPStatement</tt>. This is called the pull API and can come in handy if your application is not interested in all new updates, and only needs to perform a frequent or infrequent poll for the latest data. 
			</p><p>
				The <tt class="literal">safeIterator</tt> method on <tt class="literal">EPStatement</tt> returns a concurrency-safe iterator returning current statement results, even while concurrent threads may send events into the engine for processing. The safe iterator guarantees correct results even as events are being processed by other threads. The cost is that the iterator obtains and holds a statement lock that must be released via the <tt class="literal">close</tt> method on the <tt class="literal">SafeIterator</tt> instance. 
			</p><p>
				The <tt class="literal">iterator</tt> method on <tt class="literal">EPStatement</tt> returns a concurrency-unsafe iterator. This iterator is only useful for applications that are single-threaded, or applications that themselves perform coordination between the iterating thread and the  threads that send events into the engine for processing. The advantage to this iterator is that it does not hold a lock.
			</p><p>
				The next code snippet shows a short example of use of safe iterators:
			</p><pre class="programlisting">EPStatement statement = epAdmin.createEPL("select avg(price) as avgPrice from MyTick");
// .. send events into the engine
// then use the pull API...
SafeIterator&lt;EventBean&gt; safeIter = statement.safeIterator();
try {
  for (;safeIter.hasNext();) {
     // .. process event ..
     EventBean event = safeIter.next();
     System.out.println("avg:" + event.get("avgPrice");
  }
}
finally {
  safeIter.close();	// Note: safe iterators must be closed
}</pre><p>
				This is a short example of use of the regular iterator that is not safe for concurrent event processing:
			</p><pre class="programlisting">double averagePrice = (Double) eplStatement.iterator().next().get("average");</pre><p>
				The <tt class="literal">safeIterator</tt> and <tt class="literal">iterator</tt> methods can be used to pull results out of all statements, including statements that join streams, contain aggregation functions, pattern statements, and statements that contain a <tt class="literal">where</tt> clause, <tt class="literal">group by</tt> clause, <tt class="literal">having</tt> clause or <tt class="literal">order by</tt> clause.
			</p><p>
				For statements without an <tt class="literal">order by</tt> clause, the <tt class="literal">iterator</tt> method returns events in the order maintained by the data window. For statements that contain an <tt class="literal">order by</tt> clause, the <tt class="literal">iterator</tt> method returns events in the order indicated by the <tt class="literal">order by</tt> clause.
			</p><p>
				Consider using the <tt class="literal">on-select</tt> clause and a named window if your application requires iterating over a partial result set or requires indexed access for fast iteration; Note that <tt class="literal">on-select</tt> requires that you sent a trigger event, which may contain the key values for indexed access.
			</p><p>
				Esper places the following restrictions on the pull API and usage of the <tt class="literal">safeIterator</tt> and <tt class="literal">iterator</tt> methods:
			</p><div class="orderedlist"><ol type="1" compact><li><p>
						In multithreaded applications, use the <tt class="literal">safeIterator</tt> method. Note: make sure your application closes the iterator via the <tt class="literal">close</tt> method when done, otherwise the iterated statement stays locked and event processing for that statement does not resume.
					</p></li><li><p>
						In multithreaded applications, the <tt class="literal">iterator</tt> method does not hold any locks. The iterator returned by this method does not make any guarantees towards correctness of results and fail-behavior, if your application processes events into the engine instance by multiple threads. Use the <tt class="literal">safeIterator</tt> method for concurrency-safe iteration instead.
					</p></li><li><p>
						Since the <tt class="literal">safeIterator</tt> and <tt class="literal">iterator</tt> methods return events to the application immediately, the iterator does not honor an output rate limiting clause, if present. That is, the iterator returns results as if there is no output-rate clause for the statement in statements without grouping or aggregation. For statements with grouping or aggregation, the iterator in combintion with an output clause returns last output group and aggregation results. Use a separate statement and the <tt class="literal">insert into</tt> clause to control the output rate for iteration, if so required.
					</p></li></ol></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="api-admin-mgmt-stmt"></a>9.3.6.&nbsp;Managing Statements</h3></div></div><div></div></div><p>
				The <tt class="literal">EPAdministrator</tt> interface provides the facilities for managing statements:
			</p><div class="itemizedlist"><ul type="disc" compact><li><p>
						Use the <tt class="literal">getStatement</tt> method to obtain an existing started or stopped statement by name
					</p></li><li><p>
						Use the <tt class="literal">getStatementNames</tt> methods to obtain a list of started and stopped statement names
					</p></li><li><p>
						Use the <tt class="literal">startAllStatements</tt>, <tt class="literal">stopAllStatements</tt> and <tt class="literal">destroyAllStatements</tt> methods to manage all statements in one operation
					</p></li></ul></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="api-admin-runtime-config"></a>9.3.7.&nbsp;Runtime Configuration</h3></div></div><div></div></div><a class="indexterm" name="d0e15413"></a><p>
				Certain configuration changes are available to perform on an engine instance while in operation. Such configuration operations are available via the <tt class="literal">getConfiguration</tt> method on <tt class="literal">EPAdministrator</tt>,
				which returns a <tt class="literal">ConfigurationOperations</tt> object.
			</p><p>
				Please consult the JavaDoc of <tt class="literal">ConfigurationOperations</tt> for further information. The section <a href="#configuration-runtime" title="10.6.&nbsp;Runtime Configuration">Section&nbsp;10.6, &#8220;Runtime Configuration&#8221;</a> provides a summary of available configurations.
			</p><p>
				In summary, the configuration operations available on a running engine instance are as follows:
			</p><div class="itemizedlist"><ul type="disc" compact><li><p>
						Add new event types for all event representations, check if an event type exists, or update an existing Map event type.
					</p></li><li><p>
						Add a variant stream.
					</p></li><li><p>
						Add a revision event type.
					</p></li><li><p>
						Add variables (get and set variable values is done via the runtime API).
					</p></li><li><p>
						Add event types for all event classes in a given Java package, using the simple class name as the event name.
					</p></li><li><p>
						Add import for user-defined functions.
					</p></li><li><p>
						Add a plug-in aggregation function, plug-in event type, plug-in type resolution URIs.
					</p></li><li><p>
						Control metrics reporting.
					</p></li></ul></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="api-runtime"></a>9.4.&nbsp;The Runtime Interface</h2></div></div><div></div></div><a class="indexterm" name="d0e15466"></a><p>
			The <tt class="literal">EPRuntime</tt> interface is used to send events for processing into an Esper engine, set and get variable values and execute on-demand queries.
        </p><p>
			The below code snippet shows how to send a Java object event to the engine. Note that the <tt class="literal">sendEvent</tt> method is overloaded. As events can take on different representation classes in Java, the <tt class="literal">sendEvent</tt> takes parameters to reflect the different 
			types of events that can be send into the engine. The <a href="#event_representation" title="Chapter&nbsp;2.&nbsp;Event Representations">Chapter&nbsp;2, <i>Event Representations</i></a> section explains the types of events 
			accepted.
        </p><pre class="programlisting">EPServiceProvider epService = EPServiceProviderManager.getDefaultProvider();
EPRuntime runtime = epService.getEPRuntime();

// Send an example event containing stock market data
runtime.sendEvent(new MarketDataBean('IBM', 75.0));		
</pre><p>
			Events, in theoretical terms, are observations of a state change that occurred in the past. Since one cannot change an event that happened in the past, events are best modelled as immutable objects. 
        </p><p>
			Note that the Esper engine relies on events that are sent into an engine to not change their state. Typically, applications create a new event object for every new event, to represent that new event. Application should not modify an existing event that was sent into the engine.
        </p><p>
			Another important method in the runtime interface is the <tt class="literal">route</tt> method. This method is designed for use by <tt class="literal">UpdateListener</tt> and subscriber implementations that
			need to send events into an engine instance to avoid the possibility of a stack overflow due to nested calls to <tt class="literal">sendEvent</tt>.
        </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="api-runtime-eventsender"></a>9.4.1.&nbsp;Event Sender</h3></div></div><div></div></div><p>
				The <tt class="literal">EventSender</tt> interface processes event objects that are of a known type. This facility can reduce the overhead of event object reflection and type lookup as an event sender
				is always associated to a single concrete event type.
			</p><p>
				Use the method <tt class="literal">getEventSender(String eventTypeName) </tt> to obtain an event sender for processing events of the named type:
			</p><pre class="programlisting">EventSender sender = epService.getEPRuntime().getEventSender("MyEvent");
sender.sendEvent(myEvent);</pre><p>
				For events backed by a Java class (JavaBean events), the event sender ensures that the event object equals the underlying class, or implements or extends the underlying class
				for the given event type name.
			</p><p>
				For events backed by a <tt class="literal">java.util.Map</tt> (Map events), the event sender does not perform any checking other then checking that the event object implements Map.
			</p><p>
				For events backed by a org.w3c.Node (XML DOM events), the event sender checks that the root element name equals the root element name for the event type.
			</p><p>
				A second method to obtain an event sender is the method <tt class="literal">getEventSender(URI[])</tt>, which takes an array of URIs. This method is for use with plug-in event representations.
				The event sender returned by this method processes event objects that are of one of the types of one or more plug-in event representations. Please consult <a href="#custom-event-representation" title="11.5.&nbsp;Custom Event Representation">Section&nbsp;11.5, &#8220;Custom Event Representation&#8221;</a> for more information.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="api-runtime-unmatched"></a>9.4.2.&nbsp;Receiving Unmatched Events</h3></div></div><div></div></div><a class="indexterm" name="d0e15535"></a><p>
				Your application can register an implementation of the <tt class="literal">UnmatchedListener</tt> interface with the <tt class="literal">EPRuntime</tt> runtime via the <tt class="literal">setUnmatchedListener</tt> method to receive events that were not matched by any statement.
			</p><p>
				 Events that can be unmatched are all events that your application sends into the runtime via one of the <tt class="literal">sendEvent</tt> or <tt class="literal">route</tt> methods, or that have been generated via an <tt class="literal">insert into</tt> clause.
			</p><p>
				For an event to become unmatched by any statement, the event must not match any statement's event stream filter criteria. Note that the EPL  <tt class="literal">where</tt> clause or <tt class="literal">having</tt> clause are not considered part of the filter criteria for a stream, as explained by example below.
			</p><p>
				In the next statement all MyEvent events match the statement's event stream filter criteria, regardless of the value of the 'quantity' property. As long as the below statement remains started, the engine would not deliver MyEvent events to your registered <tt class="literal">UnmatchedListener</tt> instance:
			</p><pre class="programlisting">select * from MyEvent where quantity &gt; 5</pre><p>
				In the following statement a MyEvent event with a 'quantity' property value of 5 or less does not match this statement's event stream filter criteria. The engine delivers such an event to the registered <tt class="literal">UnmatchedListener</tt> instance provided no other statement matches on the event:
			</p><pre class="programlisting">select * from MyEvent(quantity &gt; 5)</pre><p>
				 For patterns, if no pattern sub-expression is active for an event type, an event of that type also counts as unmatched in regards to the pattern statement.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="api-runtime-ondemand"></a>9.4.3.&nbsp;On-Demand Snapshot Query Execution</h3></div></div><div></div></div><p>
				As your application may not require streaming results and may not know each query in advance, the on-demand query facility provides for ad-hoc execution of an EPL expression.
			</p><p>
				On-demand queries are not continuous in nature: The query engine executes the query once and returns all result rows to the application. On-demand query execution is very lightweight as the engine performs no statement creation
				and the query leaves no traces within the engine.
			</p><p>
				The following limitations apply:
			</p><div class="itemizedlist"><ul type="disc"><li><p>
						An on-demand EPL expression only evaluates against the named windows that your application creates. On-demand queries may not specify any other streams or application event types.
					</p></li><li><p>
						The following clauses are not allowed in on-demand EPL: <tt class="literal">insert into</tt> and <tt class="literal">output</tt>.
					</p></li><li><p>
						Views and patterns are not allowed to appear in on-demand queries.
					</p></li><li><p>
						On-demand EPL may not perform subqueries.
					</p></li><li><p>
						The <tt class="literal">previous</tt> and <tt class="literal">prior</tt> functions may not be used.
					</p></li></ul></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="api-runtime-ondemand-use"></a>9.4.3.1.&nbsp;On-Demand Query API</h4></div></div><div></div></div><p>
					The <tt class="literal">EPRuntime</tt> provides two ways to run on-demand queries:
				</p><div class="orderedlist"><ol type="1"><li><p>
							Dynamic on-demand queries are executed once through the <tt class="literal">executeQuery</tt> method.
						</p></li><li><p>
							Prepared on-demand queries: The <tt class="literal">prepareQuery</tt> method returns an <tt class="literal">EPOnDemandPreparedQuery</tt> representing the query, and the query can be performed repeatedly via the <tt class="literal">execute</tt> method.
						</p></li></ol></div><p>
					Prepared on-demand queries are designed for repeated execution and may perform better then the dynamic queries if running the same query multiple times. Placeholders are not allowed in prepared on-demand queries.
				</p><p>
					The next program listing runs an on-demand query against a named window <tt class="literal">MyNamedWindow</tt> and prints a column of each row result of the query:
				</p><pre class="programlisting">String query = "select * from MyNamedWindow";
EPOnDemandQueryResult result = epRuntime.executeQuery(query);
for (EventBean row : result.getArray()) {
  System.out.println("name=" + row.get("name"));
}</pre><p>
					The next code snippet demonstrates prepared on-demand queries:
				</p><pre class="programlisting">EPOnDemandPreparedQuery prepared = epRuntime.prepareQuery(query);
EPOnDemandQueryResult result = prepared.execute();
// ...later ...
prepared.execute();	// execute a second time</pre></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="api-event"></a>9.5.&nbsp;Event and Event Type</h2></div></div><div></div></div><a class="indexterm" name="d0e15664"></a><a class="indexterm" name="d0e15667"></a><p>
			An <tt class="literal">EventBean</tt> object represents a row (event) in your continuous query's result set. Each <tt class="literal">EventBean</tt> object has an associated <tt class="literal">EventType</tt> object providing event metadata.
        </p><p>
			An <tt class="literal">UpdateListener</tt> implementation receives one or more <tt class="literal">EventBean</tt> events with each invocation. Via the <tt class="literal">iterator</tt> method on <tt class="literal">EPStatement</tt> your application can poll or read data out of statements. Statement iterators also return <tt class="literal">EventBean</tt> instances.
        </p><p>
			Each statement provides the event type of the events it produces, available via the <tt class="literal">getEventType</tt> method on <tt class="literal">EPStatement</tt>.
        </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="api-eventtype"></a>9.5.1.&nbsp;Event Type Metadata</h3></div></div><div></div></div><p>
				An <tt class="literal">EventType</tt> object encapulates all the metadata about a certain type of events. As Esper supports an inheritance hierarchy for event types, it also provides information about super-types to an event type.
			</p><p>
				An <tt class="literal">EventType</tt> object provides the following information:
			</p><div class="itemizedlist"><ul type="disc" compact><li><p>
						For each event property, it lists the property name and type as well as flags for indexed or mapped properties and whether a property is a fragment.
					</p></li><li><p>
						The direct and indirect super-types to the event type.
					</p></li><li><p>
						Value getters for property expressions.
					</p></li><li><p>
						Underlying class of the event representation.
					</p></li></ul></div><p>
				For each property of an event type, there is an <tt class="literal">EventPropertyDescriptor</tt> object that describes the property.
				The <tt class="literal">EventPropertyDescriptor</tt> contains flags that indicate whether a property is an indexed (array) or a mapped property and whether access to property values require an integer index value (indexed properties only) or string key value (mapped properties only). The descriptor also contains a fragment flag that indicates whether a property value is available as a fragment.
			</p><p>
				The term <span class="emphasis"><em>fragment</em></span> means an event property value that is itself an event, or a property value that can be represented as an event. The <tt class="literal">getFragmentType</tt> on <tt class="literal">EventType</tt> may be used to determine a fragment's event type in advance. 
			</p><p>
				A fragment event type and thereby fragment events allow navigation over a statement's results even if the statement result contains nested events or a graph of events. There is no need to use the Java reflection API to navigate events, 
				since fragments allow the querying of nested event properties or array values, including nested Java classes.
			</p><p>
				When using the Map event representation, any named Map type nested within a Map as a simple or array property is also available as a fragment. When using Java objects either directly or within Map events, any object that is neither a primitive or boxed built-in type, and that is not an enumeration and does not implement the Map interface is also available as a fragment.
			</p><p>
				The nested, indexed and mapped property syntax can be combined to a property expression that may query an event property graph. Most of the methods on the <tt class="literal">EventType</tt> interface allow a property expression to be passed.
			</p><p>
				Your application may use an <tt class="literal">EventType</tt> object to obtain special getter-objects. A getter-object is a fast accessor to a property value of an event of a given type. All getter objects implement the <tt class="literal">EventPropertyGetter</tt> interface.  Getter-objects work only for events of the same type or sub-types as the <tt class="literal">EventType</tt> that provides the <tt class="literal">EventPropertyGetter</tt>. The performance section provides additional information and samples on using getter-objects.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="api-eventbean"></a>9.5.2.&nbsp;Event Object</h3></div></div><div></div></div><p>
				An event object is an <tt class="literal">EventBean</tt> that provides:
			</p><div class="itemizedlist"><ul type="disc" compact><li><p>
						The property value for a property given a property name or property expression that may include nested, indexed or mapped properties in any combination.
					</p></li><li><p>
						The event type of the event.
					</p></li><li><p>
						Access to the underlying event object.
					</p></li><li><p>
						The <tt class="literal">EventBean</tt> fragment or array of <tt class="literal">EventBean</tt> fragments given a property name or property expression.
					</p></li></ul></div><p>
				The <tt class="literal">getFragment</tt> method on <tt class="literal">EventBean</tt> and <tt class="literal">EventPropertyGetter</tt> return the fragment <tt class="literal">EventBean</tt> or array of <tt class="literal">EventBean</tt>, if the property is itself an event
				or can be represented as an event. Your application may use <tt class="literal">EventPropertyDescriptor</tt> to determine which properties are also available as fragments.
			</p><p>
				The underlying event object of an <tt class="literal">EventBean</tt> can be obtained via the <tt class="literal">getUnderlying</tt> method. Please see <a href="#event_representation" title="Chapter&nbsp;2.&nbsp;Event Representations">Chapter&nbsp;2, <i>Event Representations</i></a>  for more information on different event representations.
			</p><p>
				From a threading perspective, it is safe to retain and query <tt class="literal">EventBean</tt> and <tt class="literal">EventType</tt> objects in multiple threads.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="api-eventtype-query"></a>9.5.3.&nbsp;Query Example</h3></div></div><div></div></div><p>
				Consider a statement that returns the symbol, count of events per symbol and average price per symbol for tick events. Our sample statement may declare a fully-qualified Java class name as the event type: <tt class="literal">org.sample.StockTickEvent</tt>. Assume that this class exists and exposes a <tt class="literal">symbol</tt> property of type String, and a <tt class="literal">price</tt> property of type (Java primitive) double.
			</p><pre class="programlisting">select symbol, avg(price) as avgprice, count(*) as mycount 
from org.sample.StockTickEvent 
group by symbol</pre><p>
				The next table summarizes the property names and types as posted by the statement above:
			</p><div class="table"><a name="d0e15857"></a><p class="title"><b>Table&nbsp;9.3.&nbsp;Properties offered by sample statement aggregating price</b></p><table summary="Properties offered by sample statement aggregating price" border="1"><colgroup><col><col><col><col></colgroup><thead><tr><th>Name</th><th>Type</th><th>Description</th><th>Java code snippet</th></tr></thead><tbody><tr><td><tt class="literal">symbol</tt></td><td>java.lang.String</td><td>Value of symbol event property</td><td><pre class="synopsis">eventBean.get("symbol")</pre></td></tr><tr><td><tt class="literal">avgprice</tt></td><td>java.lang.Double</td><td>Average price per symbol</td><td><pre class="synopsis">eventBean.get("avgprice")</pre></td></tr><tr><td><tt class="literal">mycount</tt></td><td>java.lang.Long</td><td>Number of events per symbol</td><td><pre class="synopsis">eventBean.get("mycount")</pre></td></tr></tbody></table></div><p>
				A code snippet out of a possible <tt class="literal">UpdateListener</tt> implementation to this statement may look as below:
			</p><pre class="programlisting">String symbol = (String) newEvents[0].get("symbol");
Double price= (Double) newEvents[0].get("avgprice");
Long count= (Long) newEvents[0].get("mycount");</pre><p>
				The engine supplies the boxed <tt class="literal">java.lang.Double</tt> and <tt class="literal">java.lang.Long</tt> types as property values rather then primitive Java types. This is because aggregated values can return a <tt class="literal">null</tt> value to indicate that no data is available for aggregation. Also, in a select statement that computes expressions, the underlying event objects to <tt class="literal">EventBean</tt> instances are of type <tt class="literal">java.util.Map</tt>.
			</p><p>
				Consider the next statement that specifies a wildcard selecting the same type of event:
			</p><pre class="programlisting">select * from org.sample.StockTickEvent where price &gt; 100</pre><p>
				The property names and types provided by an <tt class="literal">EventBean</tt> query result row, as posted by the statement above are as follows:
			</p><div class="table"><a name="d0e15942"></a><p class="title"><b>Table&nbsp;9.4.&nbsp;Properties offered by sample wildcard-select statement</b></p><table summary="Properties offered by sample wildcard-select statement" border="1"><colgroup><col><col><col><col></colgroup><thead><tr><th>Name</th><th>Type</th><th>Description</th><th>Java code snippet</th></tr></thead><tbody><tr><td><tt class="literal">symbol</tt></td><td>java.lang.String</td><td>Value of symbol event property</td><td><pre class="synopsis">eventBean.get("symbol")</pre></td></tr><tr><td><tt class="literal">price</tt></td><td>double</td><td>Value of price event property</td><td><pre class="synopsis">eventBean.get("price")</pre></td></tr></tbody></table></div><p>
				As an alternative to querying individual event properties via the <tt class="literal">get</tt> methods, the <tt class="literal">getUnderlying</tt> method on <tt class="literal">EventBean</tt> returns the underlying object representing the query result.
				In the sample statement that features a wildcard-select, the underlying event object is of type <tt class="literal">org.sample.StockTickEvent</tt>:
			</p><pre class="programlisting">StockTickEvent tick = (StockTickEvent) newEvents[0].getUnderlying();</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="api-eventtype-pattern"></a>9.5.4.&nbsp;Pattern Example</h3></div></div><div></div></div><p>
				Composite events are events that aggregate one or more other events. Composite events are typically created by the engine for statements that join two event streams, and for event patterns in which the causal events are retained and reported in a composite event. The example below shows such an event pattern.
			</p><pre class="programlisting">// Look for a pattern where BEvent follows AEvent
String pattern = "a=AEvent -&gt; b=BEvent";
EPStatement stmt = epService.getEPAdministrator().createPattern(pattern);
stmt.addListener(testListener);
</pre><pre class="programlisting">// Example listener code
public class MyUpdateListener implements UpdateListener {
  public void update(EventBean[] newData, EventBean[] oldData) {
    System.out.println("a event=" + newData[0].get("a"));
    System.out.println("b event=" + newData[0].get("b"));
  }
}</pre><p>
				Note that the <tt class="literal">update</tt> method can receive multiple events at once as it accepts an array of <tt class="literal">EventBean</tt> instances. For example, a time batch window may post multiple events to listeners representing a batch of events received during a given time period. 
			</p><p>
				Pattern statements can also produce multiple events delivered to update listeners in one invocation. The pattern statement below, for instance, delivers an event for each A event that was not followed by a B event with the same <tt class="literal">id</tt> property within 60 seconds of the A event. The engine may deliver all matching A events as an array of events in a single invocation of the <tt class="literal">update</tt> method of each listener to the statement:
			</p><pre class="programlisting">select * from pattern[
  every a=A -&gt; (timer:interval(60 sec) and not B(id=a.id))]</pre><p>
				A code snippet out of a possible <tt class="literal">UpdateListener</tt> implementation to this statement that retrives the events as fragments may look as below:
			</p><pre class="programlisting">EventBean a = (EventBean) newEvents[0].getFragment("a");
// ... or using a nested property expression to get a value out of A event...
double value = (Double) newEvent[0].get("a.value");</pre><p>
				Some pattern objects return an array of events. An example is the unbound repeat operator. Here is a sample pattern that collects all A events until a B event arrives:
			</p><pre class="programlisting">select * from pattern [a=A until b=B]</pre><p>
				A possible code to retrieve different fragments or property values:
			</p><pre class="programlisting">EventBean[] a = (EventBean[]) newEvents[0].getFragment("a");
// ... or using a nested property expression to get a value out of A event...
double value = (Double) newEvent[0].get("a[0].value");</pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="api-threading"></a>9.6.&nbsp;Engine Threading and Concurrency</h2></div></div><div></div></div><a class="indexterm" name="d0e16044"></a><p>
			Esper is designed from the ground up to operate as a component to multi-threaded, highly-concurrent applications that require efficient use of Java VM resources. In addition, multi-threaded execution requires guarantees in predictability of results and deterministic processing. This section discusses these concerns in detail. 
        </p><p>
In Esper, an engine instance is a unit of separation. Applications can obtain and discard (initialize) one or more engine instances within the same Java VM and can provide the same or different engine configurations to each instance. An engine instance efficiently shares resources between statements. For example, consider two statements that declare the same data window. The engine matches up view declarations provided by each statement and can thus provide a single data window representation shared between the two statements.
        </p><p>
			Applications can use Esper APIs to concurrently, by multiple threads of execution, perform such functions as creating and 
managing statements, or sending events into an engine instance for processing. Applications can use application-managed thread pools or any set of same or different threads of execution with any of the public Esper APIs. There are no restrictions towards threading other then those noted in specific sections of this document. 
        </p><p>
Esper does not prescribe a specific threading model. Applications using Esper retain full control over threading, allowing an engine to be easily embedded and used as a component or library in your favorite Java container or process.
        </p><p>
In the default configuration it is up to the application code to use multiple threads for processing events by the engine, if so desired. All event processing takes places within your application thread call stack. The exception is timer-based processing if your engine instance relies on the internal timer (default). If your application relies on external timer events instead of the internal timer then there need not be any Esper-managed internal threads.
        </p><p>
The fact that event processing can take place within your application thread's call stack makes developing applications with Esper easier: Any common Java integrated development environment (IDE) can host an Esper engine instance. This allows developers to easily set up test cases, debug through listener code and inspect input or output events, or trace their call stack.
        </p><p>
In the default configuration, each engine instance maintains a single timer thread (internal timer) providing for time or schedule-based processing within the engine. The default resolution at which the internal timer operates is 100 milliseconds. The internal timer thread can be disabled and applications can instead send external time events to an engine instance to perform timer or scheduled processing at the resolution required by an application.
        </p><p>
Each engine instance performs minimal locking to enable high levels of concurrency. An engine instance locks on a statement level to protect statement resources.
        </p><p>
For an engine instance to produce predictable results from the viewpoint of listeners to statements, an engine instance by default ensures that 
it dispatches statement result events to listeners in the order in which a statement produced result events. Applications that require the highest possible concurrency and do not require predictable order of delivery of events to listeners, this feature can be turned off via configuration.
        </p><p>
In multithreaded environments, when one or more statements make result events available via the <tt class="literal">insert into</tt> clause to further statements, the engine preserves the order of events inserted into the generated insert-into stream, allowing statements that consume other statement's events to behave deterministic. This feature can also be turned off via configuration.
        </p><p>
We generally recommended that listener implementations block minimally or do not block at all. By implementing listener code as non-blocking code execution threads can often achieve higher levels of concurrency.
        </p><p>
We recommended that, when using a single listener or subscriber instance to receive output from multiple statements, that the listener or subscriber code is multithread-safe. If your application has shared state between
listener or subscriber instances then such shared state should be thread-safe. 
        </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="api-threading-advanced"></a>9.6.1.&nbsp;Advanced Threading</h3></div></div><div></div></div><p>
				In the default configuration the same application thread that invokes any of the <tt class="literal">sendEvent</tt> methods will process the event fully and also deliver output events to listeners and subscribers. By default the single internal timer thread based on system time performs time-based processing and delivery of time-based results. 
			</p><p>
				This default configuration reduces the processing overhead associated with thread context switching, is lightweight and fast and works well in many environments such as J2EE, server or client. Latency and throughput requirements are largely use case dependant, and Esper provides engine-level facilities for controlling concurrency that are described next.
			</p><p>
				<span class="emphasis"><em>Inbound Threading</em></span> queues all incoming events: A pool of engine-managed threads performs the event processing. The application thread that sends an event via any of the <tt class="literal">sendEvent</tt> methods returns without blocking.
			</p><p>
				<span class="emphasis"><em>Outbound Threading</em></span> queues events for delivery to listeners and subscribers, such that slow or blocking listeners or subscribers do not block event processing.
			</p><p>
				<span class="emphasis"><em>Timer Execution Threading</em></span> means time-based event processing is performed by a pool of engine-managed threads. With this option the internal timer thread (or external timer event) serves only as a metronome, providing units-of-work to the engine-managed threads in the timer execution pool, pushing threading to the level of each statement for time-based execution.
			</p><p>
				<span class="emphasis"><em>Route Execution Threading</em></span> means that the thread sending in an event via any of the <tt class="literal">sendEvent</tt> methods only identifies and pre-processes an event, and a pool of engine-managed threads handles the actual processing of the event for each statement, pushing threading to the level of each statement for event-arrival-based execution.
			</p><p>
				The engine starts engine-managed threads as daemon threads when the engine instance is first obtained. The engine stops engine-managed threads when the engine instance is destroyed via the <tt class="literal">destroy</tt> method. When the engine is initialized via the <tt class="literal">initialize</tt> method the existing engine-managed threads are stopped and new threads are created. When shutting down your application, use the <tt class="literal">destroy</tt> method to stop engine-managed threads.
			</p><p>
				Note that the options discussed herein may introduce additional processing overhead into your system, as each option involves work queue management and thread context switching.
			</p><p>
				If your use cases require ordered processing of events or do not tolerate disorder, the threading options described herein may not be the right choice.
			</p><p>
				If your use cases require loss-less processing of events, wherein the threading options mean that events are held in an in-memory queue, the threading options described herein may not be the right choice.
			</p><p>
				Care should be taken to consider arrival rates and queue depth. Threading options utilize unbound queues or capacity-bound queues with blocking-put, depending on configuration, and may therefore introduce an overload or blocking situation to your application. You may use the service provider interface as outlined below to manage queue sizes, if required, and to help tune the engine to your application needs.
			</p><p>
				All threading options are on the level of an engine. If you require different threading behavior for certain statements then consider using multiple engine instances, consider using the <tt class="literal">route</tt> method or consider 
				using application threads instead.
			</p><p>
				Please consult <a href="#config-engine-threading" title="10.4.9.&nbsp;Engine Settings related to Concurrency and Threading">Section&nbsp;10.4.9, &#8220;Engine Settings related to Concurrency and Threading&#8221;</a> for instructions on how to configure threading options. Threading options take effect at engine initialization time.
			</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="api-threading-advanced-inbound"></a>9.6.1.1.&nbsp;Inbound Threading</h4></div></div><div></div></div><p>
					With inbound threading an engine places inbound events in a queue for processing by one or more engine-managed threads other then the delivering application threads.
				</p><p>
					The delivering application thread uses one of the <tt class="literal">sendEvent</tt> methods on <tt class="literal">EPRuntime</tt> to deliver events or may also use the <tt class="literal">sendEvent</tt> method on a <tt class="literal">EventSender</tt>. The engine receives the event and places the event into a queue, allowing the delivering thread to continue and not block while the event is being processed and results are delivered.
				</p><p>
					Events that are sent into the engine via one of the <tt class="literal">route</tt> methods are not placed into queue but processed by the same thread invoking the <tt class="literal">route</tt> operation.
				</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="api-threading-advanced-outbound"></a>9.6.1.2.&nbsp;Outbound Threading</h4></div></div><div></div></div><p>
					With outbound threading an engine places outbound events in a queue for delivery by one or more engine-managed threads other then the processing thread originating the result.
				</p><p>
					With outbound threading your listener or subscriber class receives statement results from one of the engine-managed threads in the outbound pool of threads. This is useful when you expect your listener or subscriber code to perform significantly blocking operations and you do not want to hold up event processing.
				</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="api-threading-advanced-timer-exec"></a>9.6.1.3.&nbsp;Timer Execution Threading</h4></div></div><div></div></div><p>
					With timer execution threading an engine places time-based work units into a queue for processing by one or more engine-managed threads other then the internal timer thread or the application thread that sends an external timer event.
				</p><p>
					Using timer execution threading the internal timer thread (or thread delivering an external timer event) serves to evaluate which time-based work units must be processed. A pool of engine-managed threads performs the actual processing of time-based work units and thereby offloads the work from the internal timer thread (or thread delivering an external timer event).
				</p><p>
					Enable this option as a tuning parameter when your statements utilize time-based patterns or data windows. Timer execution threading is fine grained and works on the level of a time-based schedule in combination with a statement.
				</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="api-threading-advanced-route-exec"></a>9.6.1.4.&nbsp;Route Execution Threading</h4></div></div><div></div></div><p>
					With route execution threading an engine identifies event-processing work units based on the event and statement combination. It places such work units into a queue for processing by one or more engine-managed threads other then the thread that originated the event.
				</p><p>
					While inbound threading works on the level of an event, route execution threading is fine grained and works on the level of an event in combination with a statement.
				</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="api-threading-management"></a>9.6.1.5.&nbsp;Threading Service Provider Interface</h4></div></div><div></div></div><p>
					The service-provider interface <tt class="literal">EPServiceSPI</tt> is an extension API that allows to manage engine-level queues and thread pools .
				</p><p>
					The service-provider interface <tt class="literal">EPServiceSPI</tt> is considered an extension API and subject to change between release versions.
				</p><p>
					The following code snippet shows how to obtain the <tt class="literal">BlockingQueue&lt;Runnable&gt;</tt> and the <tt class="literal">ThreadPoolExecutor</tt> for the managing the queue and thread pool responsible for inbound threading:
				</p><pre class="programlisting">EPServiceProviderSPI spi = (EPServiceProviderSPI) epService;
int queueSize = spi.getThreadingService().getInboundQueue().size();
ThreadPoolExecutor threadpool = spi.getThreadingService().getInboundThreadPool();</pre></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="api-controlling-time"></a>9.7.&nbsp;Controlling Time-Keeping</h2></div></div><div></div></div><a class="indexterm" name="d0e16214"></a><a class="indexterm" name="d0e16219"></a><p>
			There are two modes for an engine to keep track of time: The internal timer based on JVM system time (the default), and externally-controlled time giving your application full control over the concept of time within an engine. 
        </p><p>
			By default the internal timer provides time and evaluates schedules. External clocking can be used to supply time ticks to the engine instead. The latter is useful for testing time-based event sequences or for synchronizing the engine with an external time source.
        </p><p>
			The internal timer relies on the <tt class="literal">java.util.concurrent.ScheduledThreadPoolExecutor</tt> class for time tick events. The next section describes timer resolution for the internal timer, by default set to 100 milliseconds. When using externally-controlled time the timer resolution is in your control.
        </p><p>
			To disable the internal timer and use externally-provided time instead, there are two options. The first option is to use the configuration API at engine initialization time. The second option toggles on and off the internal timer at runtime, via special timer control events that are sent into the engine like any other event.
        </p><p>
			If using a timer execution thread pool as discussed above, the internal timer or external time event provide the schedule evaluation however do not actually perform the time-based processing. The time-based processing is performed by the threads in the timer execution thread pool.
        </p><p>
			This code snippet shows the use of the configuration API to disable the internal timer and thereby turn on externally-provided time (see the Configuration section for configuration via XML file):
        </p><pre class="programlisting">Configuration config = new Configuration();
config.getEngineDefaults().getThreading().setInternalTimerEnabled(false);
EPServiceProvider epService = EPServiceProviderManager.getDefaultProvider(config);</pre><p>
			After disabling the internal timer, it is wise to set a defined time so that any statements created thereafter start relative to the time defined. Use the <tt class="literal">CurrentTimeEvent</tt> class to indicate current time to the engine
			and to move time forward for the engine.
        </p><p>
			This code snippet obtains the current time and sends a timer event in:
        </p><pre class="programlisting">long timeInMillis = System.currentTimeMillis();
CurrentTimeEvent timeEvent = new CurrentTimeEvent(timeInMillis);
epService.getEPRuntime().sendEvent(timeEvent);</pre><p>
			Alternatively, you can use special timer control events to enable or disable the internal timer. Use the <tt class="literal">TimerControlEvent</tt> class to control timer operation at runtime.
        </p><p>
			The next code snippet demonstrates toggling to external timer at runtime, by sending in a <tt class="literal">TimerControlEvent</tt> event:
        </p><pre class="programlisting">EPServiceProvider epService = EPServiceProviderManager.getDefaultProvider();
EPRuntime runtime = epService.getEPRuntime();
// switch to external clocking
runtime.sendEvent(new TimerControlEvent(TimerControlEvent.ClockType.CLOCK_EXTERNAL));</pre><p>
			Your application sends a <tt class="literal">CurrentTimeEvent</tt> event when it desires to move the time forward. All aspects of Esper engine time related to EPL statements and patterns are driven by the time provided by the <tt class="literal">CurrentTimeEvent</tt> that your application sends in.
		</p><p>
			The next example sequence of instructions sets time to zero, then creates a statement, then moves time forward to 1 seconds later and then 6 seconds later:
		</p><pre class="programlisting">// Set start time at zero.
epRuntime().sendEvent(new CurrentTimeEvent(0));

// create a statement here
epAdministrator.createEPL("select * from MyEvent output every 5 seconds");

// move time forward 1 second
epRuntime().sendEvent(new CurrentTimeEvent(1000));

// move time forward 5 seconds
epRuntime().sendEvent(new CurrentTimeEvent(6000));</pre><p>
			When sending external timer events, your application should make sure that <tt class="literal">long</tt>-type time values are ascending. That is, each long-type value should be either the same value or a larger value then the prior value provided by a <tt class="literal">CurrentTimeEvent</tt>. The engine outputs a warning if time events move back in time.
		</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="api-time-resolution"></a>9.8.&nbsp;Time Resolution</h2></div></div><div></div></div><a class="indexterm" name="d0e16283"></a><p>
			The minimum resolution that all data windows, patterns and output rate limiting operate at is the millisecond. 
			Parameters to time window views, pattern operators or the <tt class="literal">output</tt> clause that are less then 1 millisecond are not allowed. As stated earlier, the default frequency at which the internal timer operates is 100 milliseconds.
        </p><p>
			The internal timer thread, by default, uses the call <tt class="literal">System.currentTimeMillis()</tt> to obtain system time. Please see the JIRA issue ESPER-191 Support nano/microsecond resolution for more information on Java system time-call performance, accuracy and drift. 
        </p><p>
			The internal timer thread can be configured to use nano-second time as returned by <tt class="literal">System.nanoTime()</tt>. If configured for nano-second time, the engine computes an offset of the nano-second ticks to wall clock time upon startup to present back an accurate millisecond wall clock time. 
			Please see section <a href="#config-engine-time-source" title="10.4.15.&nbsp;Engine Settings related to Time Source">Section&nbsp;10.4.15, &#8220;Engine Settings related to Time Source&#8221;</a> to configure the internal timer thread to use <tt class="literal">System.nanoTime()</tt>.
		</p><p>
			The internal timer is based on <tt class="literal">java.util.concurrent.ScheduledThreadPoolExecutor</tt> (<tt class="literal">java.util.Timer</tt> does not support high accuracy VM time).
        </p><p>
			Your application can achieve a higher tick rate then 1 tick per millisecond by sending external timer events that carry a long-value which is not based on milliseconds since January 1, 1970, 00:00:00 GMT. In this case, your time interval parameters need to take consideration of the changed use of engine time. 
        </p><p>
			Thus, if your external timer events send long values that represents microseconds (1E-6 sec), then your time window interval must be 1000-times larger, i.e. "win:time(1000)" becomes a 1-second time window.
        </p><p>
			And therefore, if your external timer events send long values that represents nanoseconds (1E-9 sec), then your time window interval must be 1000000-times larger, i.e. "win:time(1000000)" becomes a 1-second time window.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="api-soda"></a>9.9.&nbsp;Statement Object Model</h2></div></div><div></div></div><a class="indexterm" name="d0e16325"></a><p>
			The statement object model is a set of classes that provide an object-oriented representation of an EPL  or pattern statement. The object model classes are found in package <tt class="literal">com.espertech.esper.client.soda</tt>. An instance of <tt class="literal">EPStatementObjectModel</tt> represents a statement's object model.
        </p><p>
			The statement object model classes are a full and complete specification of a statement. All EPL  and pattern constructs including expressions and sub-queries are available via the statement object model. 
        </p><p>
			In conjunction with the administrative API, the statement object model provides the means to build, change or interrogate statements beyond the EPL  or pattern syntax string representation. The object graph of the statement object model is fully navigable for easy querying by code, and is also serializable allowing applications to persist or transport statements in object form, when required.
        </p><p>
			The statement object model supports full round-trip from object model to EPL  statement string and back to object model: A statement object model can be rendered into an EPL  string representation via the <tt class="literal">toEPL</tt> method on <tt class="literal">EPStatementObjectModel</tt>. Further, the administrative API allows to compile a statement string into an object model representation via the <tt class="literal">compileEPL</tt> method on <tt class="literal">EPAdministrator</tt>.
        </p><p>
			The <tt class="literal">create</tt> method on <tt class="literal">EPAdministrator</tt> creates and starts a statement as represented by an object model. In order to obtain an object model from an existing statement, obtain the statement expression text of the statement via the <tt class="literal">getText</tt> method on <tt class="literal">EPStatement</tt> and use the <tt class="literal">compileEPL</tt> method to obtain the object model.
		</p><p>
			The following limitations apply:
		</p><div class="itemizedlist"><ul type="disc" compact><li><p>
					Statement object model classes are not safe for sharing between threads other then for read access. 
				</p></li><li><p>
					Between versions of Esper, the serialized form of the object model is subject to change. Esper makes no guarantees that the serialized object model of one version will be fully compatible with the 
					serialized object model generated by another version of Esper. Please consider this issue when storing Esper object models in persistent store. 
				</p></li></ul></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="api-soda-building-step1"></a>9.9.1.&nbsp;Building an Object Model</h3></div></div><div></div></div><p>
				A <tt class="literal">EPStatementObjectModel</tt> consists of an object graph representing all possible clauses that can be part of an EPL  statement. 
			</p><p>
				Among all clauses, the <tt class="literal">SelectClause</tt> and <tt class="literal">FromClause</tt> objects are required clauses that must be present, in order to define what to select and where to select from.
			</p><div class="table"><a name="soda-building-classes-1"></a><p class="title"><b>Table&nbsp;9.5.&nbsp;Required Statement Object Model Instances</b></p><table summary="Required Statement Object Model Instances" border="1"><colgroup><col><col></colgroup><thead><tr><th>Class</th><th>Description</th></tr></thead><tbody><tr><td><span class="emphasis"><em>EPStatementObjectModel</em></span></td><td>All statement clauses for a statement, such as the select-clause and the from-clause, are specified within the object graph of an instance of this class</td></tr><tr><td><span class="emphasis"><em>SelectClause</em></span></td><td>A list of the selection properties or expressions, or a wildcard</td></tr><tr><td><span class="emphasis"><em>FromClause</em></span></td><td>A list of one or more streams; A stream can be a filter-based, a pattern-based or a SQL-based stream; Views are added to streams to provide data window or other projections</td></tr></tbody></table></div><p>
				Part of the statement object model package are convenient builder classes that make it easy to build a new object model or change an existing object model. The <tt class="literal">SelectClause</tt> and <tt class="literal">FromClause</tt> are such builder classes and provide convenient <tt class="literal">create</tt> methods.
			</p><p>
				Within the from-clause we have a choice of different streams to select on. The <tt class="literal">FilterStream</tt> class represents a stream that is filled by events of a certain type and that pass an optional filter expression.
			</p><p>
				We can use the classes introduced above to create a simple statement object model:
			</p><pre class="programlisting">EPStatementObjectModel model = new EPStatementObjectModel();
model.setSelectClause(SelectClause.createWildcard());
model.setFromClause(FromClause.create(FilterStream.create("com.chipmaker.ReadyEvent")));</pre><p>
				The model as above is equivalent to the EPL :
			</p><pre class="programlisting">select * from com.chipmaker.ReadyEvent</pre><p>
				Last, the code snippet below creates a statement from the object model:
			</p><pre class="programlisting">EPStatement stmt = epService.getEPAdministrator().create(model);</pre><p>
				Notes on usage: 
			</p><div class="itemizedlist"><ul type="disc" compact><li><p>
						Variable names can simply be treated as property names.
					</p></li><li><p>
						When selecting from named windows, the name of the named window is the event type name for use in <tt class="literal">FilterStream</tt> instances or patterns.
					</p></li><li><p>
						To compile an arbitrary sub-expression text into an <tt class="literal">Expression</tt> object representation, simply add the expression text to a <tt class="literal">where</tt> clause,
						compile the EPL  string into an object model via the <tt class="literal">compileEPL</tt> on <tt class="literal">EPAdministrator</tt>, and obtain the compiled <tt class="literal">where</tt>
						from the <tt class="literal">EPStatementObjectModel</tt> via the <tt class="literal">getWhereClause</tt> method.
					</p></li></ul></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="api-soda-building-step2"></a>9.9.2.&nbsp;Building Expressions</h3></div></div><div></div></div><p>
				The <tt class="literal">EPStatementObjectModel</tt> includes an optional where-clause. The where-clause is a filter expression that the engine applies to events in one or more streams. The key interface for all expressions is the <tt class="literal">Expression</tt> interface.
			</p><p>
				The <tt class="literal">Expressions</tt> class provides a convenient way of obtaining <tt class="literal">Expression</tt> instances for all possible expressions. Please consult the JavaDoc for detailed method information. 
				The next example discusses sample where-clause expressions.
			</p><p>
				Use the <tt class="literal">Expressions</tt> class as a service for creating expression instances, and add additional expressions via the <tt class="literal">add</tt> method that most expressions provide.
			</p><p>
				In the next example we add a simple where-clause to the EPL  as shown earlier:
			</p><pre class="programlisting">select * from com.chipmaker.ReadyEvent where line=8</pre><p>
				And the code to add a where-clause to the object model is below.
			</p><pre class="programlisting">model.setWhereClause(Expressions.eq("line", 8));</pre><p>
				The following example considers a more complex where-clause. Assume we need to build an expression using logical-and and logical-or:
			</p><pre class="programlisting">select * from com.chipmaker.ReadyEvent 
where (line=8) or (line=10 and age&lt;5)</pre><p>
				The code for building such a where-clause by means of the object model classes is:
			</p><pre class="programlisting">model.setWhereClause(Expressions.or()
  .add(Expressions.eq("line", 8))
  .add(Expressions.and()
      .add(Expressions.eq("line", 10))
      .add(Expressions.lt("age", 5))
  ));</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="api-soda-building-step3"></a>9.9.3.&nbsp;Building a Pattern Statement</h3></div></div><div></div></div><p>
				The <tt class="literal">Patterns</tt> class is a factory for building pattern expressions. It provides convenient methods to create all pattern expressions of the pattern language.
			</p><p>
				Patterns in EPL  are seen as a stream of events that consist of patterns matches. The <tt class="literal">PatternStream</tt> class represents a stream of pattern matches and contains a pattern expression within. 
			</p><p>
				 For instance, consider the following pattern statement.
			</p><pre class="programlisting">select * from pattern [every a=MyAEvent and not b=MyBEvent]</pre><p>
				The next code snippet outlines how to use the statement object model and specifically the <tt class="literal">Patterns</tt> class to create a statement object model that is equivalent to the pattern statement above.
			</p><pre class="programlisting">EPStatementObjectModel model = new EPStatementObjectModel();
model.setSelectClause(SelectClause.createWildcard());
PatternExpr pattern = Patterns.and()
  .add(Patterns.everyFilter("MyAEvent", "a"))
  .add(Patterns.notFilter("MyBEvent", "b"));
model.setFromClause(FromClause.create(PatternStream.create(pattern)));</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="api-soda-building-step4"></a>9.9.4.&nbsp;Building a Select Statement</h3></div></div><div></div></div><p>
				In this section we build a complete example statement and include all optional clauses in one EPL  statement, to demonstrate the object model API.
			</p><p>
				A sample statement:
			</p><pre class="programlisting">insert into ReadyStreamAvg(line, avgAge) 
select line, avg(age) as avgAge 
from com.chipmaker.ReadyEvent(line in (1, 8, 10)).win:time(10) as RE
where RE.waverId != null
group by line 
having avg(age) &lt; 0
output every 10.0 seconds 
order by line</pre><p>
				Finally, this code snippet builds the above statement from scratch:
			</p><pre class="programlisting">EPStatementObjectModel model = new EPStatementObjectModel();
model.setInsertInto(InsertIntoClause.create("ReadyStreamAvg", "line", "avgAge"));
model.setSelectClause(SelectClause.create()
    .add("line")
    .add(Expressions.avg("age"), "avgAge"));
Filter filter = Filter.create("com.chipmaker.ReadyEvent", Expressions.in("line", 1, 8, 10));
model.setFromClause(FromClause.create(
    FilterStream.create(filter, "RE").addView("win", "time", 10)));
model.setWhereClause(Expressions.isNotNull("RE.waverId"));
model.setGroupByClause(GroupByClause.create("line"));
model.setHavingClause(Expressions.lt(Expressions.avg("age"), Expressions.constant(0)));
model.setOutputLimitClause(OutputLimitClause.create(10, OutputLimitUnit.SECONDS));
model.setOrderByClause(OrderByClause.create("line"));</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="api-soda-building-step5"></a>9.9.5.&nbsp;Building a Create-Variable and On-Set Statement</h3></div></div><div></div></div><p>
				This sample statement creates a variable:
			</p><pre class="programlisting">create variable integer var_output_rate = 10</pre><p>
				The code to build the above statement using the object model:
			</p><pre class="programlisting">EPStatementObjectModel model = new EPStatementObjectModel();
model.setCreateVariable(CreateVariableClause.create("integer", "var_output_rate", 10));
epService.getEPAdministrator().create(model);</pre><p>
				A second statement sets the variable to a new value:
			</p><pre class="programlisting">on NewValueEvent set var_output_rate = new_rate</pre><p>
				The code to build the above statement using the object model:
			</p><pre class="programlisting">EPStatementObjectModel model = new EPStatementObjectModel();
model.setOnExpr(OnClause.createOnSet("var_output_rate", Expressions.property("new_rate")));
model.setFromClause(FromClause.create(FilterStream.create("NewValueEvent")));
EPStatement stmtSet = epService.getEPAdministrator().create(model);</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="api-soda-building-step6"></a>9.9.6.&nbsp;Building Create-Window, On-Delete and On-Select Statements</h3></div></div><div></div></div><p>
				This sample statement creates a named window:
			</p><pre class="programlisting">create window OrdersTimeWindow.win:time(30 sec) as select symbol as sym, volume as vol, price from OrderEvent</pre><p>
				The is the code that builds the create-window statement as above:
			</p><pre class="programlisting">EPStatementObjectModel model = new EPStatementObjectModel();
model.setCreateWindow(CreateWindowClause.create("OrdersTimeWindow").addView("win", "time", 30));
model.setSelectClause(SelectClause.create()
		.addWithName("symbol", "sym")
		.addWithName("volume", "vol")
		.add("price"));
model.setFromClause(FromClause.create(FilterStream.create("OrderEvent)));</pre><p>
				A second statement deletes from the named window:
			</p><pre class="programlisting">on NewOrderEvent as myNewOrders
delete from AllOrdersNamedWindow as myNamedWindow
where myNamedWindow.symbol = myNewOrders.symbol</pre><p>
				The object model is built by:
			</p><pre class="programlisting">EPStatementObjectModel model = new EPStatementObjectModel();
model.setOnExpr(OnClause.createOnDelete("AllOrdersNamedWindow", "myNamedWindow"));
model.setFromClause(FromClause.create(FilterStream.create("NewOrderEvent", "myNewOrders")));
model.setWhereClause(Expressions.eqProperty("myNamedWindow.symbol", "myNewOrders.symbol"));
EPStatement stmtOnDelete = epService.getEPAdministrator().create(model);</pre><p>
				A third statement selects from the named window using the non-continuous on-demand selection via on-select:
			</p><pre class="programlisting">on QueryEvent(volume&gt;0) as query
select count(*) from OrdersNamedWindow as win
where win.symbol = query.symbol</pre><p>
				The on-select statement is built from scratch via the object model as follows:
			</p><pre class="programlisting">EPStatementObjectModel model = new EPStatementObjectModel();
model.setOnExpr(OnClause.createOnSelect("OrdersNamedWindow", "win"));
model.setWhereClause(Expressions.eqProperty("win.symbol", "query.symbol"));
model.setFromClause(FromClause.create(FilterStream.create("QueryEvent", "query", 
  Expressions.gt("volume", 0))));
model.setSelectClause(SelectClause.create().add(Expressions.countStar()));
EPStatement stmtOnSelect = epService.getEPAdministrator().create(model);</pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="api-prepared"></a>9.10.&nbsp;Prepared Statement and Substitution Parameters</h2></div></div><div></div></div><p>
			The <tt class="literal">prepare</tt> method that is part of the administrative API pre-compiles an EPL  statement and stores the precompiled statement in an <tt class="literal">EPPreparedStatement</tt> object. This 
			object can then be used to efficiently start the parameterized statement multiple times.
        </p><p>
			Substitution parameters are inserted into an EPL  statement as a single question mark character <tt class="literal">'?'</tt>. The engine assigns the first substitution parameter an index of 1 and subsequent parameters increment the index by one.
        </p><p>
			Substitution parameters can be inserted into any EPL  construct that takes an expression. They are therefore valid in any clauses such as the select-clause, from-clause filters, where-clause, group-by-clause, having-clause or order-by-clause. 
			Substitution parameters cannot be used as parameters to views, pattern observers and guards. They also cannot be used where a numeric constant is required rather then an expression.
        </p><p>
			All substitution parameters must be replaced by actual values before a statement with substitution parameters can be started. Substitution parameters can be replaced with an actual value using the <tt class="literal">setObject</tt> method for each index. Substitution parameters can be set to new values and new statements can be created from the same <tt class="literal">EPPreparedStatement</tt> object more then once.
        </p><p>
			While the <tt class="literal">setObject</tt> method allows substitution parameters to assume any actual value including application Java objects or enumeration values, the application must provide the correct type of  substitution parameter that matches the requirements of the expression the parameter resides in.
        </p><p>
			In the following example of setting parameters on a prepared statement and starting the prepared statement, <tt class="literal">epService</tt> represents an engine instance:
        </p><pre class="programlisting">String stmt = "select * from com.chipmaker.ReadyEvent(line=?)";
EPPreparedStatement prepared = epService.getEPAdministrator().prepareEPL(stmt);
prepared.setObject(1, 8);
EPStatement statement = epService.getEPAdministrator().create(prepared);</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="api-instrumentation"></a>9.11.&nbsp;Engine and Statement Metrics Reporting</h2></div></div><div></div></div><p>
			Metrics reporting is a feature that allows an application to receive ongoing reports about key engine-level and statement-level metrics. Examples are the number of incoming events, the CPU time and wall time taken by statement executions or the number of output events per statement.
        </p><p>
			Metrics reporting is, by default, disabled. To enable reporting, please follow the steps as outlined in <a href="#config-engine-instrumentation" title="10.4.16.&nbsp;Engine Settings related to Metrics Reporting">Section&nbsp;10.4.16, &#8220;Engine Settings related to Metrics Reporting&#8221;</a>. Metrics reporting must be enabled at engine initialization time. Reporting intervals can be controlled at runtime via the <tt class="literal">ConfigurationOperations</tt> interface available from the administrative API.
        </p><p>
			Your application receives metrics at configurable intervals via EPL statement. A metric datapoint is simply a well-defined event. The events are <tt class="literal">EngineMetric</tt> and <tt class="literal">StatementMetric</tt> and the Java class representing the events can be found in the client API in package <tt class="literal">com.espertech.esper.client.metric</tt>.
        </p><p>
			Since metric events are processed by the engine the same as application events, your EPL may use any construct on such events. For example, your application may select, filter, aggregate properties, sort or insert into a stream or named window all metric events the same as application events.
        </p><p>
			This example statement selects all engine metric events:
        </p><pre class="programlisting">select * from com.espertech.esper.client.metric.EngineMetric</pre><p>
			Make sure to have metrics reporting enabled since only then do listeners or subscribers to a statement such as above receive metric events.
        </p><p>
			The engine provides metric events after the configured interval of time has passed. By default, only started statements that have activity within an interval (in the form of event or timer processing) are reported upon.
        </p><p>
			The default configuration performs the publishing of metric events in an Esper daemon thread under the control of the engine instance. Metrics reporting honors externally-supplied time, if using external timer events. 
        </p><p>
			Via runtime configuration options provided by <tt class="literal">ConfigurationOperations</tt>, your application may enable and disable metrics reporting globally, provided that metrics reporting was enabled at initialization time. Your application may also enable and disable metrics reporting for individual statements by statement name.
        </p><p>
			Statement groups is a configuration feature that allows to assign reporting intervals to statements. Statement groups are described further in the <a href="#config-engine-instrumentation" title="10.4.16.&nbsp;Engine Settings related to Metrics Reporting">Section&nbsp;10.4.16, &#8220;Engine Settings related to Metrics Reporting&#8221;</a> section. Statement groups cannot be added or removed at runtime. 
        </p><p>
			The following limitations apply:
		</p><div class="itemizedlist"><ul type="disc" compact><li><p>
					If your Java VM version does not report current thread CPU time (most JVM do), then CPU time is reported as zero (use <tt class="literal"> ManagementFactory.getThreadMXBean().isCurrentThreadCpuTimeSupported()</tt> to determine if your JVM supports this feature).
				</p></li><li><p>
					Your Java VM may not provide high resolution time via <tt class="literal">System.nanoTime</tt>. In such case wall time may be inaccurate and inprecise.
				</p></li><li><p>
					CPU time and wall time have nanosecond precision but not necessarily nanosecond accuracy, please check with your Java VM provider.
				</p></li><li><p>
					There is a performance cost to collecting and reporting metrics.
				</p></li><li><p>
					Not all statements may report metrics: The engine performs certain runtime optimizations sharing resources between similar statements, thereby not reporting on certain statements unless resource sharing is disabled through configuration.
				</p></li></ul></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="api-instrumentation-enginemetrics"></a>9.11.1.&nbsp;Engine Metrics</h3></div></div><div></div></div><p>
				Engine metrics are properties of <tt class="literal">EngineMetric</tt> events:
			</p><div class="table"><a name="api-instrumentation-events-engine"></a><p class="title"><b>Table&nbsp;9.6.&nbsp;EngineMetric Properties</b></p><table summary="EngineMetric Properties" border="1"><colgroup><col><col></colgroup><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td>engineURI</td><td>The URI of the engine instance.</td></tr><tr><td>timestamp</td><td>The current engine time.</td></tr><tr><td>inputCount</td><td>Cumulative number of input events since engine initialization time. Input events are defined as events send in via application threads as well as <tt class="literal">insert into</tt> events.</td></tr><tr><td>scheduleDepth</td><td>Number of outstanding schedules.</td></tr></tbody></table></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="api-instrumentation-statementmetrics"></a>9.11.2.&nbsp;Statement Metrics</h3></div></div><div></div></div><p>
				Statement metrics are properties of <tt class="literal">StatementMetric</tt>. The properties are:
			</p><div class="table"><a name="api-instrumentation-events-statement"></a><p class="title"><b>Table&nbsp;9.7.&nbsp;StatementMetric Properties</b></p><table summary="StatementMetric Properties" border="1"><colgroup><col><col></colgroup><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td>engineURI</td><td>The URI of the engine instance.</td></tr><tr><td>timestamp</td><td>The current engine time.</td></tr><tr><td>statementName</td><td>Statement name, if provided at time of statement creation, otherwise a generated name.</td></tr><tr><td>cpuTime</td><td>Statement processing CPU time (system and user) in nanoseconds (if available by Java VM).</td></tr><tr><td>wallTime</td><td>Statement processing wall time in nanoseconds (based on <tt class="literal">System.nanoTime</tt>).</td></tr><tr><td>numOutputIStream</td><td>Number of insert stream rows output to listeners or the subscriber, if any.</td></tr><tr><td>numOutputRStream</td><td>Number of remove stream rows output to listeners or the subscriber, if any.</td></tr></tbody></table></div><p>
				The totals reported are cumulative relative to the last metric report.
			</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="api-output-rendering"></a>9.12.&nbsp;Event Rendering to XML and JSON</h2></div></div><div></div></div><p>
			Your application may use the built-in XML and JSON formatters to render output events into a readable textual format, such as for integration or debugging purposes. This section introduces the utility classes in the client <tt class="literal">util</tt> package for rendering events to strings. Further API information can be found in the JavaDocs.
		</p><p>
			The <tt class="literal">EventRenderer</tt> interface accessible from the runtime interface via the <tt class="literal">getEventRenderer</tt> method provides access to JSON and XML rendering. For repeated rendering of events of the same event type or subtypes, it is recommended to obtain a <tt class="literal">JSONEventRenderer</tt> or <tt class="literal">XMLEventRenderer</tt> instance and use the <tt class="literal">render</tt> method provided by the interface. This allows the renderer implementations to cache event type metadata for fast rendering.
		</p><p>
			In this example we show how one may obtain a renderer for repeated rendering of events of the same type, assuming that <tt class="literal">statement</tt> is an instance of <tt class="literal">EPStatement</tt>:
		</p><pre class="programlisting">JSONEventRenderer jsonRenderer = epService.getEPRuntime().
    getEventRenderer().getJSONRenderer(statement.getEventType());</pre><p>
			Assuming that <tt class="literal">event</tt> is an instance of <tt class="literal">EventBean</tt>, this code snippet renders an event into the JSON format:
		</p><pre class="programlisting">String jsonEventText = jsonRenderer.render("MyEvent", event);</pre><p>
			The XML renderer works the same:
		</p><pre class="programlisting">XMLEventRenderer xmlRenderer = epService.getEPRuntime().
    getEventRenderer().getXMLRenderer(statement.getEventType());</pre><p>
			...and...
		</p><pre class="programlisting">String xmlEventText = xmlRenderer.render("MyEvent", event);</pre><p>
			If the event type is not known in advance or if you application does not want to obtain a renderer instance per event type for fast rendering, your application can use one of the following methods to render an event to a XML or JSON textual format:
		</p><pre class="programlisting">String json = epService.getEPRuntime().getEventRenderer().renderJSON(event);
String xml = epService.getEPRuntime().getEventRenderer().renderXML(event);</pre><p>
			Use the <tt class="literal">JSONRenderingOptions</tt> or <tt class="literal">XMLRenderingOptions</tt> classes to control how events are rendered.
		</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="api-output-rendering-json"></a>9.12.1.&nbsp;JSON Event Rendering Conventions and Options</h3></div></div><div></div></div><p>
				The JSON renderer produces JSON text according to the standard documented at <tt class="literal">http://www.json.org</tt>.
			</p><p>
				The renderer formats simple properties as well as nested properties and indexed properties according to the JSON string encoding, array encoding and nested object encoding requirements.
			</p><p>
				The renderer does render indexed properties, it does not render indexed properties that require an index, i.e. if your event representation is backed by POJO objects and your getter method is <tt class="literal">getValue(int index)</tt>, the indexed property values are not part of the JSON text. This is because the implementation has no way to determine how many index keys there are. A workaround is to have a method such as <tt class="literal">Object[] getValue()</tt> instead.
			</p><p>
				The same is true for mapped properties that the renderer also renders.  If a property requires a Map key for access, i.e. your getter method is <tt class="literal">getValue(String key)</tt>, such property values are not part of the result text as there is no way for the implementation to determine the key set.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="api-output-rendering-xml"></a>9.12.2.&nbsp;XML Event Rendering Conventions and Options</h3></div></div><div></div></div><p>
				The XML renderer produces well-formed XML text according to the XML standard.
			</p><p>
				The renderer can be configured to format simple properties as attributes or as elements. Nested properties and indexed properties are always represented as XML sub-elements to the root or parent element.
			</p><p>
				The root element name provided to the XML renderer must be the element name of the root in the XML document and may include namespace instructions.
			</p><p>
				The renderer does render indexed properties, it does not render indexed properties that require an index, i.e. if your event representation is backed by POJO objects and your getter method is <tt class="literal">getValue(int index)</tt>, the indexed property values are not part of the XML text. This is because the implementation has no way to determine how many index keys there are. A workaround is to have a method such as <tt class="literal">Object[] getValue()</tt> instead.
			</p><p>
				The same is true for mapped properties that the renderer also renders.  If a property requires a Map key for access, i.e. your getter method is <tt class="literal">getValue(String key)</tt>, such property values are not part of the result text as there is no way for the implementation to determine the key set.
			</p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="configuration"></a>Chapter&nbsp;10.&nbsp;Configuration</h2></div></div><div></div></div><a class="indexterm" name="d0e16941"></a><a class="indexterm" name="d0e16946"></a><p>
        Esper engine configuration is entirely optional. Esper has a very small number of configuration parameters that can be used to simplify event 
        pattern and EPL statements, and to tune the engine behavior to specific requirements. The Esper engine works out-of-the-box without configuration.
    </p><p>
        An application can supply configuration at the time of engine allocation using the <tt class="literal">Configuration</tt> class, and can also use XML files to hold configuration. Configuration can be changed at runtime
        via the <tt class="literal">ConfigurationOperations</tt> interface available from <tt class="literal">EPAdministrator</tt> via the <tt class="literal">getConfiguration</tt> method.
    </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-programmatic"></a>10.1.&nbsp;Programmatic Configuration</h2></div></div><div></div></div><a class="indexterm" name="d0e16968"></a><p>
            An instance of <tt class="literal">com.espertech.esper.client.Configuration</tt> represents all configuration parameters. The <tt class="literal">Configuration</tt> is used to build an <tt class="literal">EPServiceProvider</tt>, which provides the administrative and runtime interfaces for an Esper engine instance.
        </p><p>
            You may obtain a <tt class="literal">Configuration</tt> instance by instantiating it directly and adding or setting values on it. The <tt class="literal">Configuration</tt> instance is then passed to <tt class="literal">EPServiceProviderManager</tt> to obtain a configured Esper engine.
        </p><pre class="programlisting">Configuration configuration = new Configuration();
configuration.addEventType("PriceLimit", PriceLimit.class.getName());
configuration.addEventType("StockTick", StockTick.class.getName());
configuration.addImport("org.mycompany.mypackage.MyUtility");
configuration.addImport("org.mycompany.util.*");

EPServiceProvider epService = EPServiceProviderManager.getProvider("sample", configuration);
</pre><p>
			Note that <tt class="literal">Configuration</tt> is meant only as an initialization-time object. The Esper engine represented by an <tt class="literal">EPServiceProvider</tt> does not retain any association back to the <tt class="literal">Configuration</tt>.
        </p><p>
			The <tt class="literal">ConfigurationOperations</tt> interface provides runtime configuration options. Through this interface applications can, for example, add new event types at runtime and then create new statements
			that rely on the additional configuration. The <tt class="literal">getConfiguration</tt> method on <tt class="literal">EPAdministrator</tt> allows access to <tt class="literal">ConfigurationOperations</tt>.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-via-xml"></a>10.2.&nbsp;Configuration via XML File</h2></div></div><div></div></div><a class="indexterm" name="d0e17025"></a><p>
			An alternative approach to configuration is to specify a configuration in a XML file. 
        </p><p>
			The default name for the XML configuration file is <tt class="literal">esper.cfg.xml</tt>. Esper reads this file from the root of the <tt class="literal">CLASSPATH</tt> as an application resource via the <tt class="literal">configure</tt> method.
        </p><pre class="programlisting">Configuration configuration = new Configuration();		
configuration.configure();
</pre><p>
			The <tt class="literal">Configuration</tt> class can read the XML configuration file from other sources as well. The <tt class="literal">configure</tt> method accepts <tt class="literal">URL, File and String</tt> filename parameters.
        </p><pre class="programlisting">Configuration configuration = new Configuration();		
configuration.configure("myengine.esper.cfg.xml");
</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-xml"></a>10.3.&nbsp;XML Configuration File</h2></div></div><div></div></div><p>
			Here is an example configuration file.
            The schema for the configuration file can be found in the <tt class="literal">etc</tt> folder and is named <tt class="literal">esper-configuration-3-0.xsd</tt>.
            It is also available online at <tt class="literal">http://www.espertech.com/schema/esper/esper-configuration-2.0.xsd</tt> so that IDE can fetch it automatically.
            The namespace used is <tt class="literal">http://www.espertech.com/schema/esper</tt>.
        </p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;esper-configuration xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns="http://www.espertech.com/schema/esper"
    xsi:schemaLocation="
http://www.espertech.com/schema/esper
http://www.espertech.com/schema/esper/esper-configuration-2.0.xsd"&gt;
  &lt;event-type name="StockTick" class="com.espertech.esper.example.stockticker.event.StockTick"/&gt;
  &lt;event-type name="PriceLimit" class="com.espertech.esper.example.stockticker.event.PriceLimit"/&gt;
  &lt;auto-import import-name="org.mycompany.mypackage.MyUtility"/&gt;
  &lt;auto-import import-name="org.mycompany.util.*"/&gt;
&lt;/esper-configuration&gt;		
</pre><p>
			The example above is only a subset of the configuration items available. The next chapters outline the available configuration in greater detail.
		</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-items"></a>10.4.&nbsp;Configuration Items</h2></div></div><div></div></div><a class="indexterm" name="d0e17082"></a><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="config-java"></a>10.4.1.&nbsp;Events represented by Java Classes</h3></div></div><div></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="config-java-package-alias"></a>10.4.1.1.&nbsp;Package of Java Event Classes</h4></div></div><div></div></div><p>
					Via this configuration an application can make the Java package or packages that contain an application's Java event classes known to an engine. 
					Thereby an application can simply refer to event types in statements by using the simple class name of
					each Java class representing an event type.
				</p><p>
					For example, consider an order-taking application that places all event classes in package <tt class="literal">com.mycompany.order.event</tt>. One Java class representing an event is the class <tt class="literal">OrderEvent</tt>. 
					The application can simply issue a statement as follows to select <tt class="literal">OrderEvent</tt> events:
				</p><pre class="programlisting">select * from OrderEvent</pre><p>
					The XML configuration for defining the Java packages that contain Java event classes is:
				</p><pre class="programlisting">&lt;event-type-auto-name package-name="com.mycompany.order.event"/&gt;</pre><p>
					The same configuration but using the <tt class="literal">Configuration</tt> class:
				</p><pre class="programlisting">Configuration config = new Configuration();
config.addEventTypeAutoName("com.mycompany.order.event");
// ... or ...
config.addEventTypeAutoName(MyEvent.getPackage().getName());</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="config-java-event-name"></a>10.4.1.2.&nbsp;Event type name to Java class mapping</h4></div></div><div></div></div><p>
					This configuration item can be used to allow event pattern statements and EPL statements to use an event type name rather then the fully qualified Java class name. Note that Java Interface classes and abstract classes are also supported as event types via the fully qualified Java class name, and an event type name can also be defined for such classes.
				</p><p>
					The example pattern statement below first shows a pattern that uses the name <tt class="literal">StockTick</tt>. The second pattern statement is equivalent but specifies the fully-qualified Java class name.
				</p><pre class="programlisting">every StockTick(symbol='IBM')"</pre><pre class="programlisting">every com.espertech.esper.example.stockticker.event.StockTick(symbol='IBM')</pre><p>
					The event type name can be listed in the XML configuration file as shown below. The <tt class="literal">Configuration</tt> API can also be used to programatically specify an event type name, as shown in an earlier code snippet.
				</p><pre class="programlisting">&lt;event-type name="StockTick" class="com.espertech.esper.example.stockticker.event.StockTick"/&gt;</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="config-java-legacy"></a>10.4.1.3.&nbsp;Non-JavaBean and Legacy Java Event Classes</h4></div></div><div></div></div><p>
					Esper can process Java classes that provide event properties through other means then through JavaBean-style getter methods. It is not necessary that the method and member variable names in your Java class adhere to the JavaBean convention - any public methods and public member variables can be exposed as event properties via the below configuration.
				</p><p>
					A Java class can optionally be configured with an accessor style attribute. This attribute instructs the engine how it should expose methods and fields for use as event properties in statements.
				</p><div class="table"><a name="d0e17147"></a><p class="title"><b>Table&nbsp;10.1.&nbsp;Accessor Styles</b></p><table summary="Accessor Styles" border="1"><colgroup><col><col></colgroup><thead><tr><th>Style Name</th><th>Description</th></tr></thead><tbody><tr><td><tt class="literal">javabean</tt></td><td>As the default setting, the engine exposes an event property for each public method following the JavaBean getter-method conventions</td></tr><tr><td><tt class="literal">public</tt></td><td>The engine exposes an event property for each public method and public member variable of the given class</td></tr><tr><td><tt class="literal">explicit</tt></td><td>The engine exposes an event property only for the explicitly configured public methods and public member variables</td></tr></tbody></table></div><p>
					Using the <tt class="literal">public</tt> setting for the <tt class="literal">accessor-style</tt> attribute instructs the engine to expose an event property for each public method and public member variable of a Java class. The engine assigns event property names of the same name as the name of the method or member variable in the Java class.
				</p><p>					
					For example, assuming the class <tt class="literal">MyLegacyEvent</tt> exposes a method named <tt class="literal">readValue</tt> and a member variable named <tt class="literal">myField</tt>, we can then use properties as shown. 
				</p><pre class="programlisting">select readValue, myField from MyLegacyEvent</pre><p>
					Using the <tt class="literal">explicit</tt> setting for the <tt class="literal">accessor-style</tt> attribute requires that event properties are declared via configuration. This is outlined in the next chapter.
				</p><p>
					When configuring an engine instance from a XML configuration file, the XML snippet below demonstrates the use of the <tt class="literal">legacy-type</tt> element and the <tt class="literal">accessor-style</tt> attribute.
				</p><pre class="programlisting">&lt;event-type name="MyLegacyEvent" class="com.mycompany.mypackage.MyLegacyEventClass"&gt;
  &lt;legacy-type accessor-style="public"/&gt;
&lt;/event-type&gt;</pre><p>
					When configuring an engine instance via Configuration API, the sample code below shows how to set the accessor style.
				</p><pre class="programlisting">Configuration configuration = new Configuration();
ConfigurationEventTypeLegacy legacyDef = new ConfigurationEventTypeLegacy();
legacyDef.setAccessorStyle(ConfigurationEventTypeLegacy.AccessorStyle.PUBLIC);
config.addEventType("MyLegacyEvent", MyLegacyEventClass.class.getName(), legacyDef);

EPServiceProvider epService = EPServiceProviderManager.getProvider("sample", configuration);
</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="config-java-spec-properties"></a>10.4.1.4.&nbsp;Specifying Event Properties for Java Classes</h4></div></div><div></div></div><p>
					Sometimes it may be convenient to use event property names in pattern and EPL statements that are backed up by a given public method or member variable (field) in a Java class. And it can be useful to declare multiple event properties that each map to the same method or member variable.
				</p><p>
					We can configure properties of events via <tt class="literal">method-property</tt> and <tt class="literal">field-property</tt> elements, as the next example shows.
				</p><pre class="programlisting">&lt;event-type name="StockTick" class="com.espertech.esper.example.stockticker.event.StockTickEvent"&gt;
	&lt;legacy-type accessor-style="javabean" code-generation="enabled"&gt;
		&lt;method-property name="price" accessor-method="getCurrentPrice" /&gt;
		&lt;field-property name="volume" accessor-field="volumeField" /&gt;
	&lt;/legacy-type&gt;
&lt;/event-type&gt;</pre><p>
					The XML configuration snippet above declared an event property named <tt class="literal">price</tt> backed by a getter-method named <tt class="literal">getCurrentPrice</tt>, and a second event property named <tt class="literal">volume</tt> that is backed by a public member variable named <tt class="literal">volumeField</tt>. Thus the price and volume properties can be used in a statement:
				</p><pre class="programlisting">select avg(price * volume) from StockTick</pre><p>
					As with all configuration options, the API can also be used:
				</p><pre class="programlisting">Configuration configuration = new Configuration();
ConfigurationEventTypeLegacy legacyDef = new ConfigurationEventTypeLegacy();
legacyDef.addMethodProperty("price", "getCurrentPrice");
legacyDef.addFieldProperty("volume", "volumeField");
config.addEventType("StockTick", StockTickEvent.class.getName(), legacyDef);</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="config-java-codegen"></a>10.4.1.5.&nbsp;Turning off Code Generation</h4></div></div><div></div></div><p>
					Esper employes the <tt class="literal">CGLIB</tt> library for very fast read access to event property values. For certain legacy Java classes it may be desirable to disable the use of this library and instead use Java reflection to obtain event property values from event objects.
				</p><p>
					In the XML configuration, the optional <tt class="literal">code-generation</tt> attribute in the <tt class="literal">legacy-type</tt> section can be set to <tt class="literal">disabled</tt> as shown next.
				</p><pre class="programlisting">&lt;event-type name="MyLegacyEvent" class="com.mycompany.package.MyLegacyEventClass"&gt;
	&lt;legacy-type accessor-style="javabean" code-generation="disabled" /&gt;
&lt;/event-type&gt;
</pre><p>
					The sample below shows how to configure this option via the API.
				</p><pre class="programlisting">Configuration configuration = new Configuration();
ConfigurationEventTypeLegacy legacyDef = new ConfigurationEventTypeLegacy();
legacyDef.setCodeGeneration(ConfigurationEventTypeLegacy.CodeGeneration.DISABLED);
config.addEventType("MyLegacyEvent", MyLegacyEventClass.class.getName(), legacyDef);</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="config-java-property-case-sensitivity"></a>10.4.1.6.&nbsp;Case Sensitivity and Property Names</h4></div></div><div></div></div><p>
					By default the engine resolves Java event properties case sensitive. That is, property names in statements must match JavaBean-convention property names in name and case. This option controls case sensitivity per Java class.
				</p><p>
					In the configuration XML, the optional <tt class="literal">property-resolution-style</tt> attribute in the <tt class="literal">legacy-type</tt> element can be set to any of these values:
				</p><div class="table"><a name="d0e17294"></a><p class="title"><b>Table&nbsp;10.2.&nbsp;Property Resolution Case Sensitivity Styles</b></p><table summary="Property Resolution Case Sensitivity Styles" border="1"><colgroup><col><col></colgroup><thead><tr><th>Style Name</th><th>Description</th></tr></thead><tbody><tr><td><tt class="literal">case_sensitive (default)</tt></td><td>As the default setting, the engine matches property names for the exact name and case only.</td></tr><tr><td><tt class="literal">case_insensitive</tt></td><td>Properties are matched if the names are identical.  A case insensitive search is used and will choose the first property that matches the name exactly 
											or the first property that matches case insensitively should no match be found.
								</td></tr><tr><td><tt class="literal">distinct_case_insensitive</tt></td><td>Properties are matched if the names are identical.  A case insensitive search is used and will choose the first property that matches the name exactly case insensitively.  If more than one 'name' can be mapped to the property an exception is thrown.</td></tr></tbody></table></div><p>
					The sample below shows this option in XML configuration, however the setting can also be changed via API:
				</p><pre class="programlisting">&lt;event-type name="MyLegacyEvent" class="com.mycompany.package.MyLegacyEventClass"&gt;
  &lt;legacy-type property-resolution-style="case_insensitive"/&gt;
&lt;/event-type&gt;</pre></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="config-java-util-map"></a>10.4.2.&nbsp;Events represented by <tt class="literal">java.util.Map</tt></h3></div></div><div></div></div><p>
				The engine can process <tt class="literal">java.util.Map</tt> events via the <tt class="literal">sendEvent(Map map, String eventTypeName)</tt> method on the <tt class="literal">EPRuntime</tt> interface. Entries in the Map represent event properties. Keys must be of type <tt class="literal">java.util.String</tt> for the engine to be able to look up event property names in pattern or EPL statements. Values can be of any type. JavaBean-style objects as values in a <tt class="literal">Map</tt> can be processed by the engine, and strongly-typed nested maps are also supported. Please see the <a href="#event_representation" title="Chapter&nbsp;2.&nbsp;Event Representations">Chapter&nbsp;2, <i>Event Representations</i></a> section for details on how to use <tt class="literal">Map</tt> events with the engine.
			</p><p>
				Via configuration we provide an event type name for <tt class="literal">Map</tt> events for use in statements, and the event property names and types enabling the engine to validate properties in statements.
			</p><p>
				The below snippet of XML configuration configures an event named <tt class="literal">MyMapEvent</tt>.
			</p><pre class="programlisting">&lt;event-type name="MyMapEvent"&gt;
  &lt;java-util-map&gt;
    &lt;map-property name="carId" class="int"/&gt;
    &lt;map-property name="carType" class="string"/&gt;
    &lt;map-property name="assembly" class="com.mycompany.Assembly"/&gt;    
  &lt;/java-util-map&gt;
&lt;/event-type&gt;</pre><p>
				This configuration defines the <tt class="literal">carId</tt> property of <tt class="literal">MyMapEvent</tt> events to be of type <tt class="literal">int</tt>, and the <tt class="literal">carType</tt> property to be of type <tt class="literal">java.util.String</tt>. The <tt class="literal">assembly</tt> property of the Map event will contain instances of <tt class="literal">com.mycompany.Assembly</tt> for the engine to query.
			</p><p>
				The valid types for the <tt class="literal">class</tt> attribute are listed in <a href="#configuration-type-names" title="10.5.&nbsp;Type Names">Section&nbsp;10.5, &#8220;Type Names&#8221;</a>. In addition, any fully-qualified Java class name that can be resolved via <tt class="literal">Class.forName</tt> is allowed.
			</p><p>
				 You can also use the configuration API to configure <tt class="literal">Map</tt> event types, as the short code snippet below demonstrates:
			</p><pre class="programlisting">Map&lt;String, Object&gt; properties = new Map&lt;String, Object&gt;();
properties.put("carId", "int");
properties.put("carType", "string");
properties.put("assembly", Assembly.class.getName());

Configuration configuration = new Configuration();
configuration.addEventType("MyMapEvent", properties);</pre><p>
				 For strongly-typed nested maps (maps-within-maps), the configuration API method <tt class="literal">addEventType</tt> can also used to define the nested types. The XML configuration does not provide the capability to configure nested maps.
			</p><p>
				Finally, here is a sample EPL statement that uses the configured <tt class="literal">MyMapEvent</tt> map event. This statement uses the <tt class="literal">chassisTag</tt> and <tt class="literal">numParts</tt> properties of <tt class="literal">Assembly</tt> objects in each map.
			</p><pre class="programlisting">select carType, assembly.chassisTag, count(assembly.numParts) from MyMapEvent.win:time(60 sec)</pre><p>
				A Map event type may also become a subtype of one or more supertypes that must also be Map event types. The <tt class="literal">java-util-map</tt> element provides an optional attribute <tt class="literal">supertype-names</tt> that accepts a comma-separated list of names of Map event types that are supertypes to the type:
			</p><pre class="programlisting">&lt;event-type name="AccountUpdate"&gt;
&lt;java-util-map supertype-names="BaseUpdate, AccountEvent"&gt;
...</pre><p>
				For initialization time configuration, the <tt class="literal">addMapSuperType</tt> method can be used to add Map hierarchy information. For runtime configuration, pass the supertype names to the <tt class="literal">addEventType</tt> method in <tt class="literal">ConfigurationOperations</tt>.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="config-xml-dom"></a>10.4.3.&nbsp;Events represented by <tt class="literal">org.w3c.dom.Node</tt></h3></div></div><div></div></div><p>
				Via this configuration item the Esper engine can natively process <tt class="literal">org.w3c.dom.Node</tt> instances, i.e. XML document object model (DOM) nodes.
				Please see the <a href="#event_representation" title="Chapter&nbsp;2.&nbsp;Event Representations">Chapter&nbsp;2, <i>Event Representations</i></a> section for details on how to use <tt class="literal">Node</tt> events with the engine.
			</p><p>
				Esper allows configuring XPath expressions as event properties. You can specify arbitrary XPath functions or expressions and provide a property name by which their result values will be available for use in expressions. 
			</p><p>
				For XML documents that follow a XML schema, Esper can load and interrogate your schema and validate event property names and types against the schema information. 
			</p><p>
				Nested, mapped and indexed event properties are also supported in expressions against <tt class="literal">org.w3c.dom.Node</tt> events. Thus XML trees can conveniently be
				interrogated using the existing event property syntax for querying JavaBean objects, JavaBean object graphs or <tt class="literal">java.util.Map</tt> events.
			</p><p>
				In the simplest form, the Esper engine only requires a configuration entry containing the root element name and the event type name in order to process <tt class="literal">org.w3c.dom.Node</tt> events:
			</p><pre class="programlisting">&lt;event-type name="MyXMLNodeEvent"&gt;
  &lt;xml-dom root-element-name="myevent" /&gt;
&lt;/event-type&gt;</pre><p>
				 You can also use the configuration API to configure XML event types, as the short example below demonstrates. 
				 In fact, all configuration options available through XML configuration can 
				 also be provided via setter methods on the <tt class="literal">ConfigurationEventTypeXMLDOM</tt> class.
			</p><pre class="programlisting">Configuration configuration = new Configuration();
ConfigurationEventTypeXMLDOM desc = new ConfigurationEventTypeXMLDOM();
desc.setRootElementName("myevent");
desc.addXPathProperty("name1", "/element/@attribute", XPathConstants.STRING);
desc.addXPathProperty("name2", "/element/subelement", XPathConstants.NUMBER);
configuration.addEventType("MyXMLNodeEvent", desc);</pre><p>
				 The next example presents configuration options in a sample configuration entry.
			</p><pre class="programlisting">&lt;event-type name="AutoIdRFIDEvent"&gt;
  &lt;xml-dom root-element-name="Sensor" schema-resource="data/AutoIdPmlCore.xsd" 
       default-namespace="urn:autoid:specification:interchange:PMLCore:xml:schema:1"&gt;
    &lt;namespace-prefix prefix="pmlcore" 
       namespace="urn:autoid:specification:interchange:PMLCore:xml:schema:1"/&gt;
    &lt;xpath-property property-name="countTags" 
       xpath="count(/pmlcore:Sensor/pmlcore:Observation/pmlcore:Tag)" type="number"/&gt;
  &lt;/xml-dom&gt;
&lt;/event-type&gt;</pre><p>
				 This example configures an event property named <tt class="literal">countTags</tt> whose value is computed by an XPath expression. The namespace prefixes
				 and default namespace are for use with XPath expressions and must also be made known to the engine in order for the engine to compile XPath expressions. 
				 Via the <tt class="literal">schema-resource</tt> attribute we instruct the engine to load a schema file.
			</p><p>
				 Here is an example EPL statement using the configured event type named <tt class="literal">AutoIdRFIDEvent</tt>.
			</p><pre class="programlisting">select ID, countTags from AutoIdRFIDEvent.win:time(30 sec)</pre><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="config-xml-dom-schema"></a>10.4.3.1.&nbsp;Schema Resource</h4></div></div><div></div></div><p>
					 The <tt class="literal">schema-resource</tt> attribute takes a schema resource URL or classpath-relative filename. 
					 The engine attempts to resolve the schema resource as an URL. If the schema resource name is not a valid URL, the engine attempts to resolve the resource from classpath via the <tt class="literal">ClassLoader.getResource</tt> method using the thread context class loader. If the name could not be resolved, the engine uses the Configuration class classloader.
				</p><p>
					 By configuring a schema file for the engine to load, the engine performs these additional services:
				</p><div class="itemizedlist"><ul type="disc" compact><li><p>
							Validates the event properties in a statement, ensuring the event property name matches an attribute or element in the XML
						</p></li><li><p>
							Determines the type of the event property allowing event properties to be used in type-sensitive expressions such as expressions involving arithmetic (Note: XPath properties are also typed)
						</p></li><li><p>
							Matches event property names to either element names or attributes
						</p></li></ul></div><p>
					 If no schema resource is specified, none of the event properties specified in statements are validated at statement creation time and their type defaults to <tt class="literal">java.lang.String</tt>. Also, attributes are not supported
					 if no schema resource is specified and must thus be declared via XPath expression.
				</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="config-xml-dom-xpathprop"></a>10.4.3.2.&nbsp;Explicit XPath Property</h4></div></div><div></div></div><p>
					 The <tt class="literal">xpath-property</tt> element adds explicitly-names event properties to the event type that are computed via an XPath expression.
					 In order for the XPath expression to compile, be sure to specify the <tt class="literal">default-namespace</tt> attribute and use the 
					 <tt class="literal">namespace-prefix</tt> to declare namespace prefixes.
				</p><p>
					 XPath expression properties are strongly typed. The <tt class="literal">type</tt> attribute allows the following values. These values correspond to those declared by 
					 <tt class="literal">javax.xml.xpath.XPathConstants</tt>.
				</p><div class="itemizedlist"><ul type="disc" compact><li><p>
							number (Note: resolves to a <tt class="literal">double</tt>)
						</p></li><li><p>
							string
						</p></li><li><p>
							boolean
						</p></li><li><p>
							node
						</p></li><li><p>
							nodeset
						</p></li></ul></div><p>
					 In case you need your XPath expression to return a type other then the types listed above, an optional cast-to type can be specified. If specified, the operation firsts obtains the result of the XPath expression as the defined type (number, string, boolean) and then casts or parses the returned type to the specified cast-to-type. At runtime, a warning message is logged if the XPath expression returns a result object that cannot be casted or parsed.
				</p><p>
					 The next line shows how to return a long-type property for an XPath expression that returns a string:
				</p><pre class="programlisting">desc.addXPathProperty("name", "/element/sub", XPathConstants.STRING, "long");</pre><p>
					 The equivalent configuration XML is:
				</p><pre class="programlisting">&lt;xpath-property property-name="name"  xpath="/element/sub" type="string" cast="long"/&gt;</pre><p>
				  See <a href="#configuration-type-names" title="10.5.&nbsp;Type Names">Section&nbsp;10.5, &#8220;Type Names&#8221;</a> for a list of cast-to type names.
				</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="config-xml-dom-absolute"></a>10.4.3.3.&nbsp;Absolute or Deep Property Resolution</h4></div></div><div></div></div><p>
					This setting indicates that when properties are compiled to XPath expressions that the compilation should generate an absolute XPath expression or a deep (find element) XPath expression. 					
				</p><p>
					For example, consider the following statement against an event type that is represented by a XML DOM document, assuming the event type GetQuote has been configured with the engine as a XML DOM event type:
				</p><pre class="programlisting">select request, request.symbol from GetQuote</pre><p>
					By default, the engine compiles the "request" property name to an XPath expression "/GetQuote/request". It compiles the nested property named "request.symbol" to an XPath expression "/GetQuote/request/symbol", wherein the root element node is "GetQuote".
				</p><p>
					By setting absolute property resolution to false, the engine compiles the "request" property name to an XPath expression "//request". It compiles the nested property named "request.symbol" to an XPath expression "//request/symbol".
					This enables these elements to be located anywhere in the XML document.
				</p><p>
					The setting is available in XML via the attribute <tt class="literal">resolve-properties-absolute</tt>.
				</p><p>
					The configuration API provides the above settings as shown here in a sample code:
				</p><pre class="programlisting">ConfigurationEventTypeXMLDOM desc = new ConfigurationEventTypeXMLDOM();
desc.setRootElementName("GetQuote");
desc.setDefaultNamespace("http://services.samples/xsd");
desc.setRootElementNamespace("http://services.samples/xsd");
desc.addNamespacePrefix("m0", "http://services.samples/xsd");
desc.setResolvePropertiesAbsolute(false);
configuration.addEventType("GetQuote", desc);</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="config-xml-dom-xpathresolver"></a>10.4.3.4.&nbsp;XPath Variable and Function Resolver</h4></div></div><div></div></div><p>
					If your XPath expressions require variables or functions, your application may provide the class name of an <tt class="literal">XPathVariableResolver</tt> and <tt class="literal">XPathFunctionResolver</tt>. At type initialization time 
					the engine instantiates the resolver instances and provides these to the XPathFactory.
				</p><p>
					This example shows the API to set this configuration.
				</p><pre class="programlisting">ConfigurationEventTypeXMLDOM desc = new ConfigurationEventTypeXMLDOM();
desc.setXPathFunctionResolver(MyXPathFunctionResolver.class.getName());
desc.setXPathVariableResolver(MyXPathVariableResolver.class.getName());</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="config-xml-dom-autofragment"></a>10.4.3.5.&nbsp;Auto Fragment</h4></div></div><div></div></div><p>
					This option is for use when a XSD schema is provided and determines whether the engine automatically creates an event type when a property expression transposes a property that is a complex type according to the schema.
				</p><p>
					An example:
				</p><pre class="programlisting">ConfigurationEventTypeXMLDOM desc = new ConfigurationEventTypeXMLDOM();
desc.setAutoFragment(false);</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="config-xml-dom-xpathpropertyexpr"></a>10.4.3.6.&nbsp;XPath Property Expression</h4></div></div><div></div></div><p>
					By default Esper employs the built-in DOM walker implementation to evaluate XPath expressions, which is not namespace-aware.
				</p><p>
					This configuration setting, when set to true, instructs the engine to rewrite property expressions into XPath.
				</p><p>
					An example:
				</p><pre class="programlisting">ConfigurationEventTypeXMLDOM desc = new ConfigurationEventTypeXMLDOM();
desc.setXPathPropertyExpr(true);</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="config-xml-dom-eventsendervalidatesroot"></a>10.4.3.7.&nbsp;Event Sender Setting</h4></div></div><div></div></div><p>
					By default an <tt class="literal">EventSender</tt> for a given XML event type validates the root element name for which the type has been declared against the one provided by the <tt class="literal">org.w3c.Node</tt> sent into the engine.
				</p><p>
					This configuration setting, when set to false, instructs an <tt class="literal">EventSender</tt> to not validate.
				</p><p>
					An example:
				</p><pre class="programlisting">ConfigurationEventTypeXMLDOM desc = new ConfigurationEventTypeXMLDOM();
desc.setEventSenderValidatesRoot(false);</pre></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="config-plugineventrep"></a>10.4.4.&nbsp;Events represented by Plug-in Event Representations</h3></div></div><div></div></div><p>
				As part of the extension API plug-in event representations allows an application to create new event types and event instances based on information available elsewhere. Please see <a href="#custom-event-representation" title="11.5.&nbsp;Custom Event Representation">Section&nbsp;11.5, &#8220;Custom Event Representation&#8221;</a> for details.
			</p><p>
				The configuration examples shown next use the configuration API to select settings. All options are also configurable via XML, please refer to the sample configuration XML in file <tt class="literal">esper.sample.cfg.xml</tt>.
			</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="config-plugineventrep-enable"></a>10.4.4.1.&nbsp;Enabling an Custom Event Representation</h4></div></div><div></div></div><p>
					Use the method <tt class="literal">addPlugInEventRepresentation</tt> to enable a custom event representation, like this:
				</p><pre class="programlisting">URI rootURI = new URI("type://mycompany/myproject/myname");
config.addPlugInEventRepresentation(rootURI, 
    MyEventRepresentation.class.getName(), null);</pre><p>
					The <tt class="literal">type://</tt> part of the URI is an optional convention for the scheme part of an URI. 
				</p><p>
					If your event representation takes initialization parameters, these are passed in as the last parameter. Initialization parameters can also be stored in the configuration XML, in which case
					they are passed as an XML string to the plug-in class.
				</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="config-plugineventrep-types"></a>10.4.4.2.&nbsp;Adding Plug-in Event Types</h4></div></div><div></div></div><p>
					To register event types that your plug-in event representation creates in advance of creating an EPL statement (either at runtime or at configuration time), use the method <tt class="literal">addPlugInEventType</tt>:
				</p><pre class="programlisting">URI childURI = new URI("type://mycompany/myproject/myname/MyEvent");
configuration.addPlugInEventType("MyEvent", new URI[] {childURI}, null);</pre><p>
					Your plug-in event type may take initialization parameters, these are passed in as the last parameter. Initialization parameters can also be stored in the configuration XML.
				</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="config-plugineventrep-resolution"></a>10.4.4.3.&nbsp;Setting Resolution URIs</h4></div></div><div></div></div><p>
					The engine can invoke your plug-in event representation when an EPL statement is created with an event type name that the engine has not seen before. Plug-in event representations can resolve such names to an actual event type. In order to do this, you need to supply a list of resolution URIs. Use the method <tt class="literal">setPlugInEventTypeNameResolutionURIs</tt>, at runtime or at configuration time:
				</p><pre class="programlisting">URI childURI = new URI("type://mycompany/myproject/myname");
configuration.setPlugInEventTypeNameResolutionURIs(new URI[] {childURI});</pre></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="config-class--package-imports"></a>10.4.5.&nbsp;Class and package imports</h3></div></div><div></div></div><p>
				Esper allows invocations of static Java library functions in expressions, as outlined in <a href="#epl-single-row-function-ref" title="7.1.&nbsp;Single-row Function Reference">Section&nbsp;7.1, &#8220;Single-row Function Reference&#8221;</a>. This configuration 
				item can be set to allow a partial rather than a fully qualified class name in such invocations. The imports work in the same way as in Java files, so both packages and classes can be imported.
			</p><pre class="programlisting">select Math.max(priceOne, PriceTwo)
// via configuration equivalent to
select java.lang.Math.max(priceOne, priceTwo)</pre><p>
				Esper auto-imports the following Java library packages if no other configuration is supplied.
				This list is replaced with any configuration specified in a configuration file or through the API.
			</p><div class="itemizedlist"><ul type="disc" compact><li><p>
						java.lang.*
					</p></li><li><p>
						java.math.*
					</p></li><li><p>
						java.text.*
					</p></li><li><p>
						java.util.*
					</p></li></ul></div><p>
				In a XML configuration file the auto-import configuration may look as below:
			</p><pre class="programlisting">&lt;auto-import import-name="com.mycompany.mypackage.*"/&gt;
&lt;auto-import import-name="com.mycompany.myapp.MyUtilityClass"/&gt;</pre><p>
				Here is an example of providing imports via the API:
			</p><pre class="programlisting">Configuration config = new Configuration();
config.addImport("com.mycompany.mypackage.*");	// package import
config.addImport("com.mycompany.mypackage.MyLib");   // class import</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="config-method-invocations"></a>10.4.6.&nbsp;Cache Settings for From-Clause Method Invocations</h3></div></div><div></div></div><p>
				Method invocations are allowed in the <tt class="literal">from</tt> clause in EPL, such that your application may join event streams to the data returned by a web service, or to data read from a distributed cache or object-oriented database, or obtain data by other means. A local cache may be placed in front of such method invocations through the configuration settings described herein.
			</p><p>
				The LRU cache is described in detail in <a href="#config-database-cache-lru" title="10.4.8.6.1.&nbsp;LRU Cache">Section&nbsp;10.4.8.6.1, &#8220;LRU Cache&#8221;</a>. The expiry-time cache documentation can be found in <a href="#config-database-cache-expiry" title="10.4.8.6.2.&nbsp;Expiry-time Cache">Section&nbsp;10.4.8.6.2, &#8220;Expiry-time Cache&#8221;</a>
			</p><p>
				The next XML snippet is a sample cache configuration that applies to methods provided by the classes 'MyFromClauseLookupLib'  and 'MyFromClauseWebServiceLib'. The XML and API configuration understand both the fully-qualified Java class name, as well as the simple class name:
			</p><pre class="programlisting">&lt;method-reference class-name="com.mycompany.MyFromClauseLookupLib"&gt;
  &lt;expiry-time-cache max-age-seconds="10" purge-interval-seconds="10" ref-type="weak"/&gt;
&lt;/method-reference&gt; 	
&lt;method-reference class-name="MyFromClauseWebServiceLib"&gt;
  &lt;lru-cache size="1000"/&gt;
&lt;/method-reference&gt; </pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="config-variables"></a>10.4.7.&nbsp;Variables</h3></div></div><div></div></div><p>
				Variables can be created dynamically in EPL via the <tt class="literal">create variable</tt> syntax but can also be configured at runtime and at configuration time.
			</p><p>
				A variable is declared by specifying a variable name, the variable type and an optional initialization value. The initialization value can be of the same or compatible type as the variable type, or can also be a String value that, when parsed, is compatible to the type declared for the variable.
			</p><p>
				In a XML configuration file the variable configuration may look as below. The <tt class="literal">Configuration</tt> API can also be used to configure variables.
			</p><pre class="programlisting">&lt;variable name="var_threshold" type="long" initialization-value="100"/&gt;
&lt;variable name="var_key" type="string"/&gt;</pre><p>
				Please find the list of valid values for the <tt class="literal">type</tt> attribute in <a href="#configuration-type-names" title="10.5.&nbsp;Type Names">Section&nbsp;10.5, &#8220;Type Names&#8221;</a>.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="config-database-ref"></a>10.4.8.&nbsp;Relational Database Access</h3></div></div><div></div></div><p>
				Esper has the capability to join event streams against historical data sources, such as a relational database. This section describes the configuration entries that the engine requires to access data stored in your database. Please see <a href="#histdata_overview" title="4.15.&nbsp;Accessing Relational Data via SQL">Section&nbsp;4.15, &#8220;Accessing Relational Data via SQL&#8221;</a> for information on the use of EPL queries that include historical data sources.
			</p><p>
					EPL queries that poll data from a relational database specify the name of the database as part of the EPL statement. The engine uses the configuration information described here to resolve the database name in the statement to database settings. The required and optional database settings are summarized below. 
			</p><div class="itemizedlist"><ul type="disc" compact><li><p>
						Database connections can be obtained via JDBC <tt class="literal">javax.xml.DataSource</tt>, via <tt class="literal">java.sql.DriverManager</tt> and via data source factory. Either one of these methods to obtain database connections is a required configuration.
					</p></li><li><p>
						Optionally, JDBC connection-level settings such as auto-commit, transaction isolation level, read-only and the catalog name can be defined.
					</p></li><li><p>
						Optionally, a connection lifecycle can be set to indicate to the engine whether the engine must retain connections or must obtain a new connection for each lookup and close the connection when the lookup is done (pooled).
					</p></li><li><p>
						Optionally, define a cache policy to allow the engine to retrieve data from a query cache, reducing the number of query executions.
					</p></li></ul></div><p>
				Some of the settings can have important performance implications that need to be carefully considered in relationship to your database software, JDBC driver and runtime environment. This section attempts to outline such implications where appropriate.
			</p><p>
				The sample XML configuration file in the "etc" folder can be used as a template for configuring database settings. All settings are also available by means of the configuration API through the classes <tt class="literal">Configuration</tt> and <tt class="literal">ConfigurationDBRef</tt>.
			</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="config-database-datasource"></a>10.4.8.1.&nbsp;Connections obtained via DataSource</h4></div></div><div></div></div><p>
					This configuration causes Esper to obtain a database connection from a <tt class="literal">javax.sql.DataSource</tt> available from your JNDI provider.
				</p><p>
					The setting is most useful when running within an application server or when a JNDI directory is otherwise present in your Java VM. If your application environment does not provide an available <tt class="literal">DataSource</tt>, the next section outlines how to use Apache DBCP as a <tt class="literal">DataSource</tt> implementation with connection pooling options and outlines how to use a custom factory for <tt class="literal">DataSource</tt> implementations.
				</p><p>
					If your <tt class="literal">DataSource</tt> provides connections out of a connection pool, your configuration should set the collection lifecycle setting to <tt class="literal">pooled</tt>.
				</p><p>
				The snippet of XML below configures a database named <tt class="literal">mydb1</tt> to obtain connections via a <tt class="literal">javax.sql.DataSource</tt>. The <tt class="literal">datasource-connection</tt> element instructs the engine to obtain new connections to the database <tt class="literal">mydb1</tt> by performing a lookup via <tt class="literal">javax.naming.InitialContext</tt> for the given object lookup name. Optional environment properties for the <tt class="literal">InitialContext</tt> are also shown in the example.
				</p><pre class="programlisting">&lt;database-reference name="mydb1"&gt;
  &lt;datasource-connection context-lookup-name="java:comp/env/jdbc/mydb"&gt;
    &lt;env-property name="java.naming.factory.initial" value ="com.myclass.CtxFactory"/&gt;
    &lt;env-property name="java.naming.provider.url" value ="iiop://localhost:1050"/&gt;
  &lt;/datasource-connection&gt;
&lt;/database-reference&gt;</pre><p>
					To help you better understand how the engine uses this information to obtain connections, we have included the logic below.
				</p><pre class="programlisting">if (envProperties.size() &gt; 0) {
  initialContext = new InitialContext(envProperties);
}
else {
  initialContext = new InitialContext();
}
DataSource dataSource = (DataSource) initialContext.lookup(lookupName);
Connection connection = dataSource.getConnection();</pre><p>
					In order to plug-in your own implementation of the <tt class="literal">DataSource</tt> interface, your application may use an existing JNDI provider as provided by an application server if running in a J2EE environment.
				</p><p>
					In case your application does not have an existing JNDI implementation to register a <tt class="literal">DataSource</tt> to provide connections, you may set the <tt class="literal">java.naming.factory.initial</tt> property in the configuration to point to your application's own implementation of the <tt class="literal">javax.naming.spi.InitialContextFactory</tt> interface that can return your application <tt class="literal">DataSource</tt> though the <tt class="literal">javax.naming.Context</tt> provided by the factory implementation. Please see Java Naming and Directory Interface (JNDI) API documentation for further information.
				</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="config-database-datasourcefactory"></a>10.4.8.2.&nbsp;Connections obtained via DataSource Factory</h4></div></div><div></div></div><p>
					This section describes how to use <a href="http://commons.apache.org/dbcp" target="_top"><i class="citetitle">Apache Commons Database Connection Pooling (Apache DBCP)</i></a> with Esper. We also explain how to provide a custom application-specific <tt class="literal">DataSource</tt> factory if not using Apache DBCP.
				</p><p>
					If your <tt class="literal">DataSource</tt> provides connections out of a connection pool, your configuration should set the collection lifecycle setting to <tt class="literal">pooled</tt>.
				</p><p>
					Apache DBCP provides comprehensive means to test for dead connections or grow and shrik a connection pool. Configuration properties for Apache DBCP can be found at <a href="http://commons.apache.org/dbcp/configuration.html" target="_top"><i class="citetitle">Apache DBCP configuration</i></a>. The listed properties are passed to Apache DBCP via the properties list provided as part of the Esper configuration.
				</p><p>
				   The snippet of XML below is an example that configures a database named <tt class="literal">mydb3</tt> to obtain connections via the pooling <tt class="literal">DataSource</tt> provided by Apache DBCP <tt class="literal">BasicDataSourceFactory</tt>.
				</p><p>
				   The listed properties are passed to DBCP to instruct DBCP how to manage the connection pool. The settings below initialize the connection pool to 2 connections and provide the validation query <tt class="literal">select 1 from dual</tt> for DBCP to validate a connection before providing a connection from the pool to Esper:
				</p><pre class="programlisting">&lt;database-reference name="mydb3"&gt;
  &lt;!-- For a complete list of properties see Apache DBCP. --&gt;
  &lt;datasourcefactory-connection class-name="org.apache.commons.dbcp.BasicDataSourceFactory"&gt;	
    &lt;env-property name="username" value ="myusername"/&gt;
    &lt;env-property name="password" value ="mypassword"/&gt;
    &lt;env-property name="driverClassName" value ="com.mysql.jdbc.Driver"/&gt;
    &lt;env-property name="url" value ="jdbc:mysql://localhost/test"/&gt;
    &lt;env-property name="initialSize" value ="2"/&gt;
    &lt;env-property name="validationQuery" value ="select 1 from dual"/&gt;
  &lt;/datasourcefactory-connection&gt;
  &lt;connection-lifecycle value="pooled"/&gt;
&lt;/database-reference&gt;</pre><p>
					The same configuration options provided through the API:
				</p><pre class="programlisting">Properties props = new Properties();
props.put("username", "myusername");
props.put("password", "mypassword");
props.put("driverClassName", "com.mysql.jdbc.Driver");
props.put("url", "jdbc:mysql://localhost/test");
props.put("initialSize", 2);
props.put("validationQuery", "select 1 from dual");

ConfigurationDBRef configDB = new ConfigurationDBRef();
// BasicDataSourceFactory is an Apache DBCP import
configDB.setDataSourceFactory(props, BasicDataSourceFactory.class.getName());
configDB.setConnectionLifecycleEnum(ConfigurationDBRef.ConnectionLifecycleEnum.POOLED);

Configuration configuration = new Configuration();;
configuration.addDatabaseReference("mydb3", configDB);</pre><p>
					Apache Commons DBCP is a separate download and not provided as part of the Esper distribution. The Apache Commons DBCP jar file requires the Apache Commons Pool jar file.
				</p><p>
					Your application can provide its own factory implementation for <tt class="literal">DataSource</tt> instances: Set the class name to the name of the application class that provides a public static method named <tt class="literal">createDataSource</tt> which takes a single <tt class="literal">Properties</tt> object as parameter and returns a  <tt class="literal">DataSource</tt> implementation. For example:
				</p><pre class="programlisting">configDB.setDataSourceFactory(props, MyOwnDataSourceFactory.class.getName());
...
class MyOwnDataSourceFactory {
  public static DataSource createDataSource(Properties properties) {
    return new MyDataSourceImpl(properties);
  }
}</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="config-database-drivermanager"></a>10.4.8.3.&nbsp;Connections obtained via DriverManager</h4></div></div><div></div></div><p>
				The next snippet of XML configures a database named <tt class="literal">mydb2</tt> to obtain connections via <tt class="literal">java.sql.DriverManager</tt>. The <tt class="literal">drivermanager-connection</tt> element instructs the engine to obtain new connections to the database <tt class="literal">mydb2</tt> by means of <tt class="literal">Class.forName</tt> and <tt class="literal">DriverManager.getConnection</tt> using the class name, URL and optional username, password and connection arguments.
				</p><pre class="programlisting">&lt;database-reference name="mydb2"&gt;
  &lt;drivermanager-connection class-name="my.sql.Driver" 
        url="jdbc:mysql://localhost/test?user=root&amp;amp;password=mypassword" 
        user="myuser" password="mypassword"&gt;
    &lt;connection-arg name="user" value ="myuser"/&gt;
    &lt;connection-arg name="password" value ="mypassword"/&gt;
    &lt;connection-arg name="somearg" value ="someargvalue"/&gt;
  &lt;/drivermanager-connection&gt;
&lt;/database-reference&gt;</pre><p>
					The username and password are shown in multiple places in the XML only as an example. Please check with your database software on the required information in
					URL and connection arguments.
				</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="config-database-connections"></a>10.4.8.4.&nbsp;Connections-level settings</h4></div></div><div></div></div><p>
					Additional connection-level settings can optionally be provided to the engine which the engine will apply to new connections. When the engine obtains a new connection, it applies only those settings to the connection that are explicitly configured. The engine leaves all other connection settings at default values.
				</p><p>
					The below XML is a sample of all available configuration settings. Please refer to the Java API JavaDocs for <tt class="literal">java.sql.Connection</tt> for more information to each option or check the documentation of your JDBC driver and database software.
				</p><pre class="programlisting">&lt;database-reference name="mydb2"&gt;
... configure data source or driver manager settings...
  &lt;connection-settings auto-commit="true" catalog="mycatalog" 
      read-only="true" transaction-isolation="1" /&gt;
&lt;/database-reference&gt;</pre><p>
					The <tt class="literal">read-only</tt> setting can be used to indicate to your database engine that SQL statements are read-only. The <tt class="literal">transaction-isolation</tt> and <tt class="literal">auto-commit</tt> help you database software perform the right level of locking and lock release. Consider setting these values to reduce transactional overhead in your database queries.
				</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="config-database-connections-lifecycle"></a>10.4.8.5.&nbsp;Connections lifecycle settings</h4></div></div><div></div></div><p>
					By default the engine retains a separate database connection for each started EPL statement. However, it is possible to override this behavior and require the engine to obtain a new database connection for each lookup, and to close that database connection after the lookup is completed. This often makes sense when you have a large number of EPL statements and require pooling of connections via a connection pool.
				</p><p>
					In the <tt class="literal">pooled</tt> setting, the engine obtains a database connection from the data source or driver manager for every query, and closes the connection when done, returning the database connection to the pool if using a pooling data source.
				</p><p>
					In the <tt class="literal">retain</tt> setting, the engine retains a separate dedicated database connection for each statement and does not close the connection between uses.
				</p><p>
					The XML for this option is below. The connection lifecycle allows the following values: <tt class="literal">pooled</tt> and <tt class="literal">retain</tt>.
				</p><pre class="programlisting">&lt;database-reference name="mydb2"&gt;
... configure data source or driver manager settings...
    &lt;connection-lifecycle value="pooled"/&gt;
&lt;/database-reference&gt;</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="config-database-cache"></a>10.4.8.6.&nbsp;Cache settings</h4></div></div><div></div></div><p>
					Cache settings can dramatically reduce the number of database queries that the engine executes for EPL statements. If no cache setting is specified, the engine does not cache query results and executes a separate database query for every event.
				</p><p>
					Caches store the results of database queries and make these results available to subsequent queries using the exact same query parameters as the query for which
					the result was stored. If your query returns one or more rows, the cache keep the result rows of the query keyed to the parameters of the query. If your query returns no rows, the cache also keeps the empty result. Query results are held by a cache until the cache entry is evicted. The strategies available for evicting cached 
					query results are listed next.
				</p><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="config-database-cache-lru"></a>10.4.8.6.1.&nbsp;LRU Cache</h5></div></div><div></div></div><p>
						The least-recently-used (LRU) cache is configured by a maximum size. The cache discards the least recently used query results first once the cache reaches the maximum size.
					</p><p>
						The XML configuration entry for a LRU cache is as below. This entry configures an LRU cache holding up to 1000 query results.
					</p><pre class="programlisting">&lt;database-reference name="mydb"&gt;
... configure data source or driver manager settings...
    &lt;lru-cache size="1000"/&gt;
&lt;/database-reference&gt;</pre></div><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="config-database-cache-expiry"></a>10.4.8.6.2.&nbsp;Expiry-time Cache</h5></div></div><div></div></div><p>
						The expiry time cache is configured by a maximum age in seconds, a purge interval and an optional reference type. The cache discards (on the get operation) any query results that are older then the maximum age so that stale data is not used. If the cache is not empty, then every purge interval number of seconds the engine purges any expired entries from the cache.
					</p><p>
						The XML configuration entry for an expiry-time cache is as follows. The example configures an expiry time cache in which prior query results are valid for 60 seconds and which the engine inspects every 2 minutes to remove query results older then 60 seconds.
					</p><pre class="programlisting">&lt;database-reference name="mydb"&gt;
... configure data source or driver manager settings...
    &lt;expiry-time-cache max-age-seconds="60" purge-interval-seconds="120" /&gt;
&lt;/database-reference&gt;</pre><p>
						By default, the expiry-time cache is backed by a <tt class="literal">java.util.WeakHashMap</tt> and thus relies on weak references. That means that cached SQL results can be freed during garbage collection. 
					</p><p>
						Via XML or using the configuration API the type of reference can be configured to not allow entries to be garbage collected, by setting the <tt class="literal">ref-type</tt> property to <tt class="literal">hard</tt>:
					</p><pre class="programlisting">&lt;database-reference name="mydb"&gt;
... configure data source or driver manager settings...
    &lt;expiry-time-cache max-age-seconds="60" purge-interval-seconds="120" ref-type="hard"/&gt;
&lt;/database-reference&gt;</pre></div><p>
						The last setting for the cache reference type is <tt class="literal">soft</tt>: This strategy allows the garbage collection of cache entries only when all other weak references have been collected.
					</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="config-database-columnchangecase"></a>10.4.8.7.&nbsp;Column Change Case</h4></div></div><div></div></div><p>
					This setting instructs the engine to convert to lower- or uppercase any output column names returned by your database system. When using Oracle relational database software, for example, column names
					can be changed to lowercase via this setting.
				</p><p>
					A sample XML configuration entry for this setting is:
				</p><pre class="programlisting">&lt;column-change-case value="lowercase"/&gt;</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="config-database-sqltypes"></a>10.4.8.8.&nbsp;SQL Types Mapping</h4></div></div><div></div></div><p>
					By providing a mapping of SQL types (<tt class="literal">java.sql.Types</tt>) to Java built-in types your code can avoid using sometimes awkward default database types and can easily change the way Esper
					returns Java types for columns returned by a SQL query.
				</p><p>
					The mapping maps a constant as defined by <tt class="literal">java.sql.Types</tt> to a Java built-in type of any of the following Java type names: <tt class="literal">String, BigDecimal, Boolean, Byte, Short, Int, Long, Float, Double, ByteArray, SqlDate, SqlTime, SqlTimestamp</tt>.  The Java type names are not case-sensitive.
				</p><p>
					A sample XML configuration entry for this setting is shown next. The sample maps <tt class="literal">Types.NUMERIC</tt> which is a constant value of <tt class="literal">2</tt> per JDBC API to the Java <tt class="literal">int</tt> type.
				</p><pre class="programlisting">&lt;sql-types-mapping sql-type="2" java-type="int" /&gt;</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="config-database-metadata"></a>10.4.8.9.&nbsp;Metadata Origin</h4></div></div><div></div></div><p>
					This setting controls how the engine retrieves SQL statement metadata from JDBC prepared statements.
				</p><div class="table"><a name="epl-grouping-aggregate-func"></a><p class="title"><b>Table&nbsp;10.3.&nbsp;Syntax and results of aggregate functions</b></p><table summary="Syntax and results of aggregate functions" border="1"><colgroup><col><col></colgroup><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody><tr><td>default</td><td><p>
										By default, the engine detects the driver name and queries prepared statement metadata if the driver is not an Oracle database driver. For Oracle drivers, the engine uses
										lexical analysis of the SQL statement to construct a sample SQL statement and then fires that statement to retrieve statement metadata.
									</p></td></tr><tr><td>metadata</td><td><p>
										The engine always queries prepared statement metadata regardless of the database driver used.
									</p></td></tr><tr><td>sample</td><td><p>
										The engine always uses lexical analysis of the SQL statement to construct a sample SQL statement, and then fires that statement to retrieve statement metadata.
									</p></td></tr></tbody></table></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="config-engine-threading"></a>10.4.9.&nbsp;Engine Settings related to Concurrency and Threading</h3></div></div><div></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="config-engine-threading-dispatch"></a>10.4.9.1.&nbsp;Preserving the order of events delivered to listeners</h4></div></div><div></div></div><p>
					In multithreaded environments, this setting controls whether dispatches of statement result events to listeners preserve the ordering in which a statement processes events. By default the engine guarantees that it delivers a statement's result events to statement listeners in the order in which the result is generated. This behavior can be turned off via configuration as below. 
				</p><p>
					The next code snippet shows how to control this feature:
				</p><pre class="programlisting">Configuration config = new Configuration();
config.getEngineDefaults().getThreading().setListenerDispatchPreserveOrder(false);
engine = EPServiceProviderManager.getDefaultProvider(config);</pre><p>
					And the XML configuration file can also control this feature by adding the following elements:
				</p><pre class="programlisting">&lt;engine-settings&gt;
  &lt;defaults&gt;
    &lt;threading&gt;
      &lt;listener-dispatch preserve-order="true" timeout-msec="1000" locking="spin"/&gt;
    &lt;/threading&gt;
  &lt;/defaults&gt;
&lt;/engine-settings&gt;</pre><p>
					As discussed, by default the engine can temporarily block another processing thread when delivering result events to listeners in order to preserve the order in which results are delivered to a given statement. The maximum time the engine blocks a thread can also be configured, and by default is set to 1 second.
				</p><p>
					As such delivery locks are typically held for a very short amount of time, the default blocking technique employs a spin lock (There are two techniques for implementing blocking; having the operating system suspend the thread until it is awakened later or using spin locks). While spin locks are CPU-intensive and appear inefficient, a spin lock can be more efficient than suspending the thread and subsequently waking it up, especially if the lock in question is held for a very short time. That is because there is significant overhead to suspending and rescheduling a thread.  
				</p><p>
					The locking technique can be changed to use a blocking strategy that suspends the thread, by means of setting the locking property to 'suspend'.
				</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="config-engine-threading-insert-into"></a>10.4.9.2.&nbsp;Preserving the order of events for insert-into streams</h4></div></div><div></div></div><p>
					In multithreaded environments, this setting controls whether statements producing events for other statements via insert-into preserve the order of delivery within the producing and consuming statements, allowing statements that consume other statement's events to behave deterministic in multithreaded applications, if the consuming statement requires such determinism. By default, the engine makes this guarantee (the setting is on).
				</p><p>
					Take, for example, an application where a single statement (S1) inserts events into a stream that another statement (S2) further evaluates. A multithreaded application may have multiple threads processing events into statement S1. As statement S1 produces events for consumption by statement S2, such results may need to be delivered in the exact order produced as the consuming statement may rely on the order received. For example, if the first statement counts the number of events, the second statement may employ a pattern that inspects counts and thus expect the counts posted by statement S1 to continuously increase by 1 even though multiple threads process events. 
				</p><p>
					The engine may need to block a thread such that order of delivery is maintained, and statements that require order (such as pattern detection, previous and prior functions) receive a deterministic order of events. The settings available control the blocking technique and parameters. As described in the section immediately prior, the default blocking technique employs spin locks per statement inserting events for consumption, as the locks in questions are typically held a very short time. The 'suspend' blocking technique can be configured and a timeout value can also defined.
				</p><p>
					The XML configuration file may change settings via the following elements:
				</p><pre class="programlisting">&lt;engine-settings&gt;
  &lt;defaults&gt;
    &lt;threading&gt;
      &lt;insert-into-dispatch preserve-order="true" timeout-msec="100" locking="spin"/&gt;
    &lt;/threading&gt;
  &lt;/defaults&gt;
&lt;/engine-settings&gt;</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="config-engine-threading-internal-timer"></a>10.4.9.3.&nbsp;Internal Timer Settings</h4></div></div><div></div></div><p>
					This option can be used to disable the internal timer thread and such have the application supply external time events, as well as to set a timer resolution.
				</p><p>
					The next code snippet shows how to disable the internal timer thread via the configuration API:
				</p><pre class="programlisting">Configuration config = new Configuration();
  config.getEngineDefaults().getThreading().setInternalTimerEnabled(false);</pre><p>
					This snippet of XML configuration leaves the internal timer enabled (the default) and sets a resolution of 200 milliseconds (the default is 100 milliseconds):
				</p><pre class="programlisting">&lt;engine-settings&gt;
  &lt;defaults&gt;
    &lt;threading&gt;
      &lt;internal-timer enabled="true" msec-resolution="200"/&gt;
    &lt;/threading&gt;
  &lt;/defaults&gt;
&lt;/engine-settings&gt;</pre><p>
					We recommend that when disabling the internal timer, applications send an external timer event setting the start time before creating statements,
					such that statement start time is well-defined.
				</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="config-engine-threading-advanced"></a>10.4.9.4.&nbsp;Advanced Threading Options</h4></div></div><div></div></div><p>
					The settings described herein are for enabling advanced threading options for inbound, outbound, timer and route executions.
				</p><p>
					Take the next snippet of XML configuration as an example. It configures all threading options to 2 threads, which may not be suitable to your application, however demonstrates the configuration:
				</p><pre class="programlisting">&lt;engine-settings&gt;
  &lt;defaults&gt;
    &lt;threading&gt;
      &lt;threadpool-inbound enabled="true" num-threads="2"/&gt;
      &lt;threadpool-outbound enabled="true" num-threads="2" capacity="1000"/&gt;
      &lt;threadpool-timerexec enabled="true" num-threads="2"/&gt;
      &lt;threadpool-routeexec enabled="true" num-threads="2"/&gt;
    &lt;/threading&gt;
  &lt;/defaults&gt;
&lt;/engine-settings&gt;</pre><p>
					By default, queues are unbound and backed by <tt class="literal">java.util.concurrent.LinkedBlockingQueue</tt>. 
					The optional <tt class="literal">capacity</tt> attribute can be set to instruct the threading option to configure a capacity-bound queue with a sender-wait (blocking put) policy, backed <tt class="literal">ArrayBlockingQueue</tt>.
				</p><p>
					This example uses the API for configuring inbound threading :
				</p><pre class="programlisting">Configuration config = new Configuration();
config.getEngineDefaults().getThreading().setThreadPoolInbound(true);
config.getEngineDefaults().getThreading().setThreadPoolInboundNumThreads(2);</pre><p>
					With a bounded work queue, the queue size and pool size should be tuned together. A large queue coupled with a small pool can help reduce memory usage, CPU usage, and context switching, at the cost of potentially constraining throughput.
				</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="config-engine-eventmeta"></a>10.4.10.&nbsp;Engine Settings related to Event Metadata</h3></div></div><div></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="config-engine-eventmeta-propertyreso"></a>10.4.10.1.&nbsp;Java Class Property Names and Case Sensitivity</h4></div></div><div></div></div><p>
				  As discussed in <a href="#config-java-property-case-sensitivity" title="10.4.1.6.&nbsp;Case Sensitivity and Property Names">Section&nbsp;10.4.1.6, &#8220;Case Sensitivity and Property Names&#8221;</a> this setting controls case sensitivity for Java event class properties of all Java classes as a default, rather then at a class level.
				</p><p>
					The next code snippet shows how to control this feature via the API:
				</p><pre class="programlisting">Configuration config = new Configuration();
config.getEngineDefaults().getEventMeta().setClassPropertyResolutionStyle(
    Configuration.PropertyResolutionStyle.CASE_INSENSITIVE);</pre></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="config-engine-viewresources"></a>10.4.11.&nbsp;Engine Settings related to View Resources</h3></div></div><div></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="config-engine-viewresources-sharing"></a>10.4.11.1.&nbsp;Sharing View Resources between Statements</h4></div></div><div></div></div><p>
				   The engine by default attempts to optimize resource usage and thus re-uses or shares views between statements that declare same views. However, in multi-threaded environments, this can lead to reduced concurrency as 
				   locking for shared view resources must take place. Via this setting this behavior can be turned off for higher concurrency in multi-threaded processing.
				</p><p>
					The next code snippet outlines the API to turn off view resource sharing between statements:
				</p><pre class="programlisting">Configuration config = new Configuration();
config.getEngineDefaults().getViewResources().setShareViews(false);</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="config-engine-viewresources-multipolicy"></a>10.4.11.2.&nbsp;Configuring Multi-Expiry Policy Defaults</h4></div></div><div></div></div><p>
				   By default, when combining multiple data window views, Esper applies an intersection of the data windows unless the <tt class="literal">retain-union</tt> keyword is provided which instructs to apply an union. The setting described herein may be used primarily for backward compatibility to instruct that intersection should not be the default.
				</p><p>
				   Here is a sample statement that specifies multiple expiry policies:
				</p><pre class="programlisting">select * from MyEvent.std:unique(price).std:unique(quantity)</pre><p>
				   By default Esper applies intersection as described in <a href="#epl-from-clause-view-multidatawindow" title="4.4.4.&nbsp;Multiple Data Window Views">Section&nbsp;4.4.4, &#8220;Multiple Data Window Views&#8221;</a>. 
				</p><p>
				   Here is the setting to allow multiple data windows without the intersection default:
				</p><pre class="programlisting">Configuration config = new Configuration();
config.getEngineDefaults().getViewResources().setAllowMultipleExpiryPolicies(true);</pre><p>
				   When setting this option to true, and when using multiple data window views for a given stream, the behavior is as follows: The top-most data window receives an insert stream of events. It passes each insert stream event to each further data window view in the chain. Each data window view may remove events according to its expiry policy. Such remove stream events are only passed to data window views further in the chain, and are not made available to data window views earlier in the chain.
				</p><p>
				   It is recommended to leave the default setting at false.
				</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="config-engine-logging"></a>10.4.12.&nbsp;Engine Settings related to Logging</h3></div></div><div></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="config-engine-logging-execpath"></a>10.4.12.1.&nbsp;Execution Path Debug Logging</h4></div></div><div></div></div><p>
				   By default, the engine does not produce debug output for the event processing execution paths even when Log4j or Logger configurations have been set to output debug level logs.
				   To enable debug level logging, set this option in the configuration as well as in your Log4j configuration file.
				</p><p>
				   When debug-level logging is enabled by setting the flag as below and by setting DEBUG in the Log4j configuration file, then the timer processing may produce extensive debug output that
				   you may not want to have in the log file. The <tt class="literal">timer-debug</tt> setting in the XML or via API as below disables timer debug output which is enabled by default.
				</p><p>
					The API to use to enable debug logging and disable timer event output is shown here:
				</p><pre class="programlisting">Configuration config = new Configuration();
config.getEngineDefaults().getLogging().setEnableExecutionDebug(true);
config.getEngineDefaults().getLogging().setEnableTimerDebug(false);</pre><p>
					Note: this is a configuration option that applies to all engine instances of a given Java module or VM.
				</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="config-engine-variables"></a>10.4.13.&nbsp;Engine Settings related to Variables</h3></div></div><div></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="config-engine-variables-lifetimeold"></a>10.4.13.1.&nbsp;Variable Version Release Interval</h4></div></div><div></div></div><p>
				   This setting controls the length of time that the engine retains variable versions for use by statements that use variables and that execute, within the same statement for the same event, longer then the time interval.
				   By default, the engine retains 15 seconds of variable versions.
				</p><p>
				   For statements that use variables and that execute (in response to a single timer or other event) longer then the time period, the engine returns the current variable version at the time the statement executes, thereby softening the guarantee of consistency of variable values within the long-running statement. Please see <a href="#variable_using" title="4.19.3.&nbsp;Using Variables">Section&nbsp;4.19.3, &#8220;Using Variables&#8221;</a> for more information.
				</p><p>
					The XML configuration for this setting is shown below:
				</p><pre class="programlisting">&lt;engine-settings&gt;
  &lt;defaults&gt;
    &lt;variables&gt;
      &lt;msec-version-release value="15000"/&gt;
    &lt;/variables&gt;
  &lt;/defaults&gt;
&lt;/engine-settings&gt;</pre></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="config-engine-stream-selection"></a>10.4.14.&nbsp;Engine Settings related to Stream Selection</h3></div></div><div></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="config-engine-streamselect-choices"></a>10.4.14.1.&nbsp;Default Statement Stream Selection</h4></div></div><div></div></div><p>
				   Statements can produce both insert stream (new data) and remove stream (old data) results. Remember that insert stream refers to arriving events and new aggregation values, while remove stream refers to events leaving data windows and prior aggregation values. By default, the engine delivers only the insert stream to listeners and observers of a statement.
				</p><p>
				   There are keywords in the <tt class="literal">select</tt> clause that instruct the engine to not generate insert stream and/or remove stream results if your application does not need either one of the streams. These keywords are the <tt class="literal">istream</tt>, <tt class="literal">rstream</tt> and the <tt class="literal">irstream</tt> keywords. 
				</p><p>
				   By default, the engine only generates insert stream results equivalent to using the optional <tt class="literal">istream</tt> keyword in the <tt class="literal">select</tt> clause.
				   If you application requires insert and remove stream results for many statements, your application can add the <tt class="literal">irstream</tt> keyword to the <tt class="literal">select</tt> clause of each statement,
				   or you can set a new default stream selector via this setting.
				</p><p>
					The XML configuration for this setting is shown below:
				</p><pre class="programlisting">&lt;engine-settings&gt;
  &lt;defaults&gt;
    &lt;stream-selection&gt;
      &lt;stream-selector value="irstream" /&gt;
    &lt;/stream-selection&gt;
  &lt;/defaults&gt;
&lt;/engine-settings&gt;</pre><p>
					The equivalent code snippet using the configuration API is here:
				</p><pre class="programlisting">Configuration config = new Configuration();
config.getEngineDefaults().getStreamSelection()
    .setDefaultStreamSelector(StreamSelector.RSTREAM_ISTREAM_BOTH);</pre></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="config-engine-time-source"></a>10.4.15.&nbsp;Engine Settings related to Time Source</h3></div></div><div></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="config-engine-timesource-choices"></a>10.4.15.1.&nbsp;Default Time Source</h4></div></div><div></div></div><p>
				   This setting only applies if internal timer events control engine time (default). If external timer events provide engine clocking, the setting does not apply.
				</p><p>
				   By default, the internal timer uses the call <tt class="literal">System.currentTimeMillis()</tt> to determine engine time in milliseconds. Via this setting the internal timer can be instructed to use <tt class="literal">System.nanoTime()</tt> instead. Please see <a href="#api-time-resolution" title="9.8.&nbsp;Time Resolution">Section&nbsp;9.8, &#8220;Time Resolution&#8221;</a> for more information. 
				</p><p>
					Note: This is a Java VM global setting. If running multiple engine instances in a Java VM, the timer setting is global and applies to all engine instances in the same Java VM, for performance reasons.
				</p><p>
					A sample XML configuration for this setting is shown below, whereas the sample setting sets the time source to the nanosecond time provider:
				</p><pre class="programlisting">&lt;engine-settings&gt;
  &lt;defaults&gt;
    &lt;time-source&gt;
      &lt;time-source-type value="nano" /&gt;
    &lt;/time-source&gt;
  &lt;/defaults&gt;
&lt;/engine-settings&gt;</pre><p>
					The equivalent code snippet using the configuration API is here:
				</p><pre class="programlisting">Configuration config = new Configuration();
config.getEngineDefaults().getTimeSource().
      setTimeSourceType(ConfigurationEngineDefaults.TimeSourceType.NANO);</pre></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="config-engine-instrumentation"></a>10.4.16.&nbsp;Engine Settings related to Metrics Reporting</h3></div></div><div></div></div><p>
				This section explains how to enable and configure metrics reporting, which is by default disabled. Please see <a href="#api-instrumentation" title="9.11.&nbsp;Engine and Statement Metrics Reporting">Section&nbsp;9.11, &#8220;Engine and Statement Metrics Reporting&#8221;</a> for more information on the metrics data reported to your application.
			</p><p>
				The flag that enables metrics reporting is global to a Java virtual machine. If metrics reporting is enabled, the overhead incurred for reporting metrics is carried by all engine instances per Java VM.
			</p><p>
				Metrics reporting occurs by an engine-controlled separate daemon thread that each engine instance starts at engine initialization time, if metrics reporting and threading is enabled (threading enabled is the default).
			</p><p>
			    Engine and statement metric intervals are in milliseconds. A negative or zero millisecond interval value may be provided to disable reporting.
			</p><p>
			    To control statement metric reporting for individual statements or groups of statements, the engine provides a facility that groups statements by statement name. 
			    Each such statement group may have different reporting intervals configured, and intervals can be
			    changed at runtime through runtime configuration. A statement group is assigned a group name at configuration time to identify the group.
			</p><p>
			    Metrics reporting configuration is part of the engine default settings. All configuration options are also available via the <tt class="literal">Configuration</tt> API.
			</p><p>
			    A sample XML configuration is shown below:
			</p><pre class="programlisting">&lt;engine-settings&gt;
  &lt;defaults&gt;
    &lt;metrics-reporting enabled="true" engine-interval="1000" statement-interval="1000" 
        threading="true"/&gt;
  &lt;/defaults&gt;
&lt;/engine-settings&gt;</pre><p>
			    The <tt class="literal">engine-interval</tt> setting (defaults to 10 seconds) determines the frequency in milliseconds at which the engine reports engine metrics, in this example every 1 second. The <tt class="literal">statement-interval</tt> is for statement metrics. The <tt class="literal">threading</tt> flag is true by default since reporting takes place by a dedicated engine thread and can be set to false to use the external or internal timer thread instead.
			</p><p>
			    The next example XML declares a statement group: The statements that have statement names that fall within the group follow a different reporting frequency:
			</p><pre class="programlisting">&lt;metrics-reporting enabled="true" statement-interval="0"&gt;
  &lt;stmtgroup name="MyStmtGroup" interval="2000" default-include="true" num-stmts="100" 
        report-inactive="true"&gt;
    &lt;exclude-regex&gt;.*test.*&lt;/exclude-regex&gt;
  &lt;/stmtgroup&gt;
&lt;/metrics-reporting&gt;</pre><p>
			    The above example configuration sets the <tt class="literal">statement-interval</tt> to zero to disable reporting for all statements. It defines a statement group by name <tt class="literal">MyStmtGroup</tt> and specifies a 2-second interval. The example sets the <tt class="literal">default-include</tt> flag to true (by default false) to include all statements in the statement group. The example also sets <tt class="literal">report-inactive</tt> to true (by default false) to report inactive statements.
			</p><p>
			  The <tt class="literal">exclude-regex</tt> element may be used to specify a regular expression that serves to exclude statements from the group. Any statement whose statement name matches the exclude regular expression is not included in the group. In the above example, all statements with the characters 'test' inside their statement name are excluded from the group.
			</p><p>
			  Any statement not belonging to any of the statement groups follow the configured statement interval. 
			</p><p>
			 There are additional elements available to include and exclude statements: <tt class="literal">include-regex</tt>, <tt class="literal">include-like</tt> and <tt class="literal">exclude-like</tt>. The latter two apply SQL-like matching. All patterns are case-sensitive.
			</p><p>
			 Here is a further example of a possible statement group definition, which includes statements whose statement name have the characters <tt class="literal">@REPORT</tt> or <tt class="literal">@STREAM</tt>, and excludes statements whose statement name have the characters <tt class="literal">@IGNORE</tt> or <tt class="literal">@METRICS</tt> inside.
			</p><pre class="programlisting">&lt;metrics-reporting enabled="true"&gt;
  &lt;stmtgroup name="MyStmtGroup" interval="1000"&gt;
    &lt;include-like&gt;%@REPORT%&lt;/include-like&gt;
    &lt;include-regex&gt;.*@STREAM.*&lt;/include-like&gt;
    &lt;exclude-like&gt;%@IGNORE%&lt;/exclude-like&gt;
    &lt;exclude-regex&gt;.*@METRICS.*&lt;/exclude-regex&gt;
  &lt;/stmtgroup&gt;
&lt;/metrics-reporting&gt;</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="config-engine-language"></a>10.4.17.&nbsp;Engine Settings related to Language and Locale</h3></div></div><div></div></div><p>
				Locale-dependence in Esper can be present in the sort order of string values by the <tt class="literal">order by</tt> clause and by the sort view.
			</p><p>
				By default, Esper sorts string values using the <tt class="literal">compare</tt> method that is not locale dependent. To enable local dependent sorting you must set the configuration flag as described below.
			</p><p>
			 The XML configuration sets the locale dependent sorting as shown below:
			</p><pre class="programlisting">&lt;engine-settings&gt;
  &lt;defaults&gt;
    &lt;language sort-using-collator="true"/&gt;
  &lt;/defaults&gt;
&lt;/engine-settings&gt;</pre><p>
			 The API to change the setting:
			</p><pre class="programlisting">Configuration config = new Configuration();
config.getEngineDefaults().getLanguage().setSortUsingCollator(true);</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="config-engine-expression"></a>10.4.18.&nbsp;Engine Settings related to Expression Evaluation</h3></div></div><div></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="config-engine-expression-division"></a>10.4.18.1.&nbsp;Integer Division and Division by Zero</h4></div></div><div></div></div><p>
					By default Esper returns double-typed values for divisions regardless of operand types. Division by zero returns positive or negative double infinity.
				</p><p>
					To have Esper use Java-standard integer division instead, use this setting as described here. In Java integer division, when dividing integer types, the result is an integer type. This means that if you divide an integer unevenly by another integer, it returns the whole number part of the result, does not perform any rounding and the fraction part is dropped. If Java-standard integer division is enabled, when dividing an integer numerator by an integer denominator, the result is an integer number. Thus the expression <tt class="literal">1 / 4</tt> results in an integer zero. Your EPL must then convert at least one of the numbers to a double value before the division, for example by specifying <tt class="literal">1.0 / 4</tt> or by using <tt class="literal">cast(myint, double)</tt>.
				</p><p>
					When using Java integer division, division by zero for integer-typed operands always returns null. However division by zero for double-type operands still returns positive or negative double infinity. To also return null upon division by zero for double-type operands, set the flag to true as below (default is false).
				</p><p>
				 The XML configuration is as follows:
				</p><pre class="programlisting">&lt;engine-settings&gt;
  &lt;defaults&gt;
    &lt;expression integer-division="false" division-by-zero-is-null="false"/&gt;
  &lt;/defaults&gt;
&lt;/engine-settings&gt;</pre><p>
				 The API to change the setting:
				</p><pre class="programlisting">Configuration config = new Configuration();
config.getEngineDefaults().getExpression().setIntegerDivision(true);
config.getEngineDefaults().getExpression().setDivisionByZeroReturnsNull(true);</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="config-engine-expression-subselecteval"></a>10.4.18.2.&nbsp;Subselect Evaluation Order</h4></div></div><div></div></div><p>
					By default Esper updates sub-selects with new events before evaluating the enclosing statement. This is relevant for statements that look for the same event in both the <tt class="literal">from</tt> clause and subselects.
				</p><p>
					To have Esper evaluate the enclosing clauses before updating the subselect in a subselect expression, set the flag as indicated herein.
				</p><p>
					 The XML configuration as below sets the same as the default value:
				</p><pre class="programlisting">&lt;engine-settings&gt;
  &lt;defaults&gt;
    &lt;expression self-subselect-preeval="true"/&gt;
  &lt;/defaults&gt;
&lt;/engine-settings&gt;</pre><p>
					 Here is a sample statement that utilitzes a sub-select against the same-events:
				</p><pre class="programlisting">select * from MyEvent where prop not in (select prop from MyEvent.std:unique(otherProp))</pre><p>
					 By default the subselect data window updates first before the <tt class="literal">where</tt> clause is evaluated, thereby above statement never returns results.
				</p><p>
					 Changing the setting described here causes the <tt class="literal">where</tt> clause to evaluate before the subselect data window updates, thereby the statement does post results.
				</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="config-engine-expression-udfcache"></a>10.4.18.3.&nbsp;User-Defined Function or Static Method Cache</h4></div></div><div></div></div><p>
					By default Esper caches the result of an user-defined function if the parameter set to that function is empty or all parameters are constant values.
				</p><p>
					To have Esper evaluate the user-defined function regardless of constant parameters, set the flag as indicated herein.
				</p><p>
					 The XML configuration as below sets the same as the default value:
				</p><pre class="programlisting">&lt;engine-settings&gt;
  &lt;defaults&gt;
    &lt;expression udf-cache="true"/&gt;
  &lt;/defaults&gt;
&lt;/engine-settings&gt;</pre></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="config-engine-execution"></a>10.4.19.&nbsp;Engine Settings related to Execution of Statements</h3></div></div><div></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="config-engine-execution-prioritized"></a>10.4.19.1.&nbsp;Prioritized Execution</h4></div></div><div></div></div><p>
					By default Esper ignores @Priority and @Drop annotations and executes unprioritized, that is the engine does not attempt to interpret assigned priorities and reorder executions based on priority. Use this setting if your application requires prioritized execution.
				</p><p>
					By setting this configuration, the engine executes statements, when an event or schedule matches multiple statements, according to the assigned priority, starting from the highest priority value. See built-in EPL annotations in <a href="#epl-syntax-annotation-priority" title="4.2.5.6.&nbsp;@Priority">Section&nbsp;4.2.5.6, &#8220;@Priority&#8221;</a>.
				</p><p>
					By enabling this setting view sharing between statements as described in <a href="#config-engine-viewresources-sharing" title="10.4.11.1.&nbsp;Sharing View Resources between Statements">Section&nbsp;10.4.11.1, &#8220;Sharing View Resources between Statements&#8221;</a> is disabled.
				</p><p>
					 The XML configuration is as follows:
				</p><pre class="programlisting">&lt;engine-settings&gt;
  &lt;defaults&gt;
    &lt;execution prioritized="true"/&gt;
  &lt;/defaults&gt;
&lt;/engine-settings&gt;</pre><p>
				 The API to change the setting:
				</p><pre class="programlisting">Configuration config = new Configuration();
config.getEngineDefaults().getExecution().setPrioritized(true);</pre></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="config-revisionevent"></a>10.4.20.&nbsp;Revision Event Type</h3></div></div><div></div></div><p>
			   Revision event types reflect an update or versioning relationship between events of same or different event types. Please refer to <a href="#eventrep-update" title="2.9.&nbsp;Updating and Versioning Events">Section&nbsp;2.9, &#8220;Updating and Versioning Events&#8221;</a> and <a href="#named_update" title="4.17.8.&nbsp;Updating and Versioning Events in Named Windows">Section&nbsp;4.17.8, &#8220;Updating and Versioning Events in Named Windows&#8221;</a>.
			</p><p>
				The configuration consists of the following:
			</p><div class="itemizedlist"><ul type="disc" compact><li><p>
						An name of an event type whose events are <span class="emphasis"><em>base</em></span> events.
					</p></li><li><p>
						Zero, one or more names of event types whose events are <span class="emphasis"><em>delta</em></span> events.
					</p></li><li><p>
						One or more property names that supply the key values that tie base and delta events to existing revision events. Properties must exist on the event type as simple properties. Nested, indexed or mapped properties are not allowed.
					</p></li><li><p>
						Optionally, a strategy for overlaying or merging properties. The default strategy is <span class="emphasis"><em>Overlay Declared</em></span> as described below.
					</p></li></ul></div><p>
				The XML configuration for this setting is shown below:
			</p><pre class="programlisting">&lt;revision-event-type name="UserProfileRevisions"&gt;
  &lt;base-event-type name="ProfileCreation"/&gt;
  &lt;delta-event-type name="ProfileUpdate"/&gt;
  &lt;key-property name="userid"/&gt;
&lt;/revision-event-type&gt;</pre><p>
				If configuring via runtime or initialization-time API, this code snippet explains how:
			</p><pre class="programlisting">Configuration config = new Configuration();
ConfigurationRevisionEventType configRev = new ConfigurationRevisionEventType();
configRev.setNameBaseEventType("ProfileCreation");
configRev.addNameDeltaEventType("ProfileUpdate");
configRev.setKeyPropertyNames(new String[] {"userid"});
config.addRevisionEventType("UserProfileRevisions", configRev);</pre><p>
				As the configuration provides names of base and delta event types, such names must be configured for JavaBean, Map or XML events as the previous sections outline.
			</p><p>
				The next table outlines the available strategies:
			</p><div class="table"><a name="d0e18646"></a><p class="title"><b>Table&nbsp;10.4.&nbsp;Property Revision Strategies</b></p><table summary="Property Revision Strategies" border="1"><colgroup><col><col></colgroup><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td>Overlay Declared (default)</td><td><p>A fast strategy for revising events that groups properties provided by base and delta events and overlays contributed properties to compute a revision.</p><p>For use when there is a limited number of combinations of properties that change on an event, and such combinations are known in advance.</p><p>The properties available on the output revision events are all properties of the base event type. Delta event types do not add any additional properties that are not present on the base event type.</p><p>Any null values or non-existing property on a delta (or base) event results in a null values for the same property on the output revision event.</p></td></tr><tr><td>Merge Declared</td><td><p>A strategy for revising events by merging properties provided by base and delta events, considering null values and non-existing (dynamic) properties as well.</p><p>For use when there is a limited number of combinations of properties that change on an event, and such combinations are known in advance.</p><p>The properties available on the output revision events are all properties of the base event type plus all additional properties that any of the delta event types provide.</p><p>Any null values or non-existing property on a delta (or base) event results in a null values for the same property on the output revision event.</p></td></tr><tr><td>Merge Non-null</td><td><p>A strategy for revising events by merging properties provided by base and delta events, considering only non-null values.</p><p>For use when there is an unlimited number of combinations of properties that change on an event, or combinations are not known in advance.</p><p>The properties available on the output revision events are all properties of the base event type plus all additional properties that any of the delta event types provide.</p><p>Null values returned by delta (or base) event properties provide no value to output revision events, i.e. null values are not merged.</p></td></tr><tr><td>Merge Exists</td><td><p>A strategy for revising events by merging properties provided by base and delta events, considering only values supplied by event properties that exist.</p><p>For use when there is an unlimited number of combinations of properties that change on an event, or combinations are not known in advance.</p><p>The properties available on the output revision events are all properties of the base event type plus all additional properties that any of the delta event types provide.</p><p>All properties are treated as dynamic properties: If an event property does not exist on a delta event (or base) event the property provides no value to output revision events, i.e. non-existing property values are not merged.</p></td></tr></tbody></table></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="config-variantstream"></a>10.4.21.&nbsp;Variant Stream</h3></div></div><div></div></div><p>
			   A <span class="emphasis"><em>variant stream</em></span> is a predefined stream into which events of multiple disparate event types can be inserted, and which can be selected from in patterns and the <tt class="literal">from</tt> clause.
			</p><p>
				The name of the variant stream and, optionally, the type of events that the stream may accept, are part of the stream definition. By default, the variant stream accepts only the predefined event types. The engine validates your <tt class="literal">insert into</tt> clause which inserts into the variant stream against the predefined types.
			</p><p>
				A variant stream can be set to accept any type of event, in which case all properties of the variant stream are effectively dynamic properties. Set the <tt class="literal">type variance</tt> flag to <tt class="literal">ANY</tt> to indicate the variant stream accepts any type  of event.
			</p><p>
				The following XML configuration defines a variant stream by name <tt class="literal">OrderStream</tt> that carries only <tt class="literal">PartsOrder</tt> and <tt class="literal">ServiceOrder</tt> events:
			</p><pre class="programlisting">&lt;variant-stream name="OrderStream"&gt;
  &lt;variant-event-type name="PartsOrder"/&gt;
  &lt;variant-event-type name="ServiceOrder"/&gt;
&lt;/variant-stream&gt;</pre><p>
				This code snippet sets up a variant stream by name <tt class="literal">OutgoingEvent</tt>:
			</p><pre class="programlisting">Configuration config = new Configuration();
ConfigurationVariantStream variant = new ConfigurationVariantStream();
variant.setTypeVariance(ConfigurationVariantStream.TypeVariance.ANY);
config.addVariantStream("OutgoingEvent", variant);</pre><p>
				If specifying variant event type names, make sure such names have been configured for JavaBean, Map or XML events.
			</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-type-names"></a>10.5.&nbsp;Type Names</h2></div></div><div></div></div><p>
			Certain configuration values accept type names. Type names can occur in the configuration of variable types, Map-event property types as well as XPath cast types, for example. Types names are not case-sensitive.
		</p><p>
			The table below outlines all possible type names:
		</p><div class="table"><a name="d0e18760"></a><p class="title"><b>Table&nbsp;10.5.&nbsp;Variable Type Names</b></p><table summary="Variable Type Names" border="1"><colgroup><col><col></colgroup><thead><tr><th>Type Name</th><th>Type</th></tr></thead><tbody><tr><td><tt class="literal">string</tt>, <tt class="literal">varchar</tt>, <tt class="literal">varchar2</tt> or <tt class="literal">java.lang.String</tt></td><td>A string value</td></tr><tr><td><tt class="literal">int</tt>, <tt class="literal">integer</tt> or <tt class="literal">java.lang.Integer</tt></td><td>An integer value</td></tr><tr><td><tt class="literal">long</tt> or <tt class="literal">java.lang.Long</tt></td><td>A long value</td></tr><tr><td><tt class="literal">bool</tt>, <tt class="literal">boolean</tt> or <tt class="literal">java.lang.Boolean</tt></td><td>A boolean value</td></tr><tr><td><tt class="literal">double</tt> or <tt class="literal">java.lang.Double</tt></td><td>A double value</td></tr><tr><td><tt class="literal">float</tt> or <tt class="literal">java.lang.Float</tt></td><td>A float value</td></tr><tr><td><tt class="literal">short</tt> or <tt class="literal">java.lang.Short</tt></td><td>A short value</td></tr><tr><td><tt class="literal">char</tt>, <tt class="literal">character</tt> or <tt class="literal">java.lang.Character</tt></td><td>A character value</td></tr><tr><td><tt class="literal">byte</tt> or <tt class="literal">java.lang.Byte</tt></td><td>A byte value</td></tr></tbody></table></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-runtime"></a>10.6.&nbsp;Runtime Configuration</h2></div></div><div></div></div><a class="indexterm" name="d0e18872"></a><p>
			Certain configuration changes are available to perform on an engine instance while in operation. Such configuration operations are available via the <tt class="literal">getConfiguration</tt> method on <tt class="literal">EPAdministrator</tt>,
			which returns an <tt class="literal">ConfigurationOperations</tt> object. Please consult the JavaDoc documentation for more detail.
		</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="extension"></a>Chapter&nbsp;11.&nbsp;Extension and Plug-in</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="custom-views"></a>11.1.&nbsp;Custom View Implementation</h2></div></div><div></div></div><a class="indexterm" name="d0e18894"></a><a class="indexterm" name="d0e18899"></a><p>
			Views in Esper are used to derive information from an event stream, and to represent data windows onto an event stream. This chapter describes how to plug-in a new, custom view. 
        </p><p>
			The following steps are required to develop and use a custom view with Esper. 
        </p><div class="orderedlist"><ol type="1" compact><li><p>
					Implement a view factory class. View factories are classes that accept and check view parameters and instantiate the appropriate view class.
				</p></li><li><p>
					Implement a view class. A view class commonly represents a data window or derives new information from a stream.
				</p></li><li><p>
					Configure the view factory class supplying a view namespace and name in the engine configuration file.
				</p></li></ol></div><p>
			The example view factory and view class that are used in this chapter can be found in the examples source folder in the OHLC (open-high-low-close) example. The class names are <tt class="literal">OHLCBarPlugInViewFactory</tt> and <tt class="literal">OHLCBarPlugInView</tt>.
        </p><p>
			Views can make use of the following engine services available via <tt class="literal">StatementServiceContext</tt>:
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
					The <tt class="literal">SchedulingService</tt> interface allows views to schedule timer callbacks to a view
				</p></li><li><p>
					The <tt class="literal">EventAdapterService</tt> interface allows views to create new event types and event instances of a given type. 
				</p></li><li><p>
					The <tt class="literal">StatementStopService</tt> interface allows view to register a callback that the engine invokes to indicate that the view's statement has been stopped
				</p></li></ul></div><p>
			<a href="#custom-views-contract" title="11.1.3.&nbsp;View Contract">Section&nbsp;11.1.3, &#8220;View Contract&#8221;</a> outlines the requirements for correct behavior of a your custom view within the engine.
        </p><p>
			Note that custom views may use engine services and APIs that can be subject to change between major releases. The engine services discussed above and view APIs are considered part of the engine internal public API and are stable. Any changes to such APIs are disclosed through the release change logs and history. Please also consider contributing your custom view to the Esper project team by submitting the view code through the mailing list or via a JIRA issue.
        </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="custom-views-viewfactory"></a>11.1.1.&nbsp;Implementing a View Factory</h3></div></div><div></div></div><p>
				A view factory class is responsible for the following functions:
			</p><div class="itemizedlist"><ul type="disc" compact><li><p>
						Accept zero, one or more view parameters. View parameters are themselves expressions. The view factory must validate and evaluate these expressions.
					</p></li><li><p>
						Instantiate the actual view class.
					</p></li><li><p>
						Provide information about the event type of events posted by the view.
					</p></li></ul></div><p>
				View factory classes simply subclass <tt class="literal">com.espertech.esper.view.ViewFactorySupport</tt>:
			</p><pre class="programlisting">public class OHLCBarPlugInViewFactory extends ViewFactorySupport { ...</pre><p>
				Your view factory class must implement the <tt class="literal">setViewParameters</tt> method to accept and parse view parameters. The next code snippet shows an implementation of this method. The code checks the number of parameters and retains the parameters passed to the method:
			</p><pre class="programlisting">public class OHLCBarPlugInViewFactory extends ViewFactorySupport {
    private ViewFactoryContext viewFactoryContext;
    private List&lt;ExprNode&gt; viewParameters;
    private ExprNode timestampExpression;
    private ExprNode valueExpression;

    public void setViewParameters(ViewFactoryContext viewFactoryContext, 
            List&lt;ExprNode&gt; viewParameters) throws ViewParameterException {
        this.viewFactoryContext = viewFactoryContext;
        if (viewParameters.size() != 2) {
            throw new ViewParameterException(
                "View requires a two parameters: " +
                "the expression returning timestamps and the expression supplying OHLC data points");
        }
        this.viewParameters = viewParameters;
    }
  ...</pre><p>
			After the engine supplied view parameters to the factory, the engine will ask the view to attach to its parent view and validate any parameter expressions against the parent view's event type. If the view will be generating events of a different type then the events generated by the parent view, then the view factory can create the new event type in this method:
		</p><pre class="programlisting">public void attach(EventType parentEventType, 
		StatementContext statementContext, 
		ViewFactory optionalParentFactory, 
		List&lt;ViewFactory&gt; parentViewFactories) throws ViewParameterException {
		
    ExprNode[] validatedNodes = ViewFactorySupport.validate("OHLC view", 
	      parentEventType, statementContext, viewParameters, false);

    timestampExpression = validatedNodes[0];
    valueExpression = validatedNodes[1];

    if ((timestampExpression.getType() != long.class) &amp;&amp; 
        (timestampExpression.getType() != Long.class)) {
        throw new ViewParameterException(
            "View requires long-typed timestamp values in parameter 1");
    }
    if ((valueExpression.getType() != double.class) &amp;&amp; 
        (valueExpression.getType() != Double.class)) {
        throw new ViewParameterException(
            "View requires double-typed values for in parameter 2");
    }
}</pre><p>
			Finally, the engine asks the view factory to create a view instance, and asks for the type of event generated by the view:
		</p><pre class="programlisting">public View makeView(StatementContext statementContext) {
    return new OHLCBarPlugInView(statementContext, timestampExpression, valueExpression);
}

public EventType getEventType() {
    return OHLCBarPlugInView.getEventType(viewFactoryContext.getEventAdapterService());
}</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="custom-views-view"></a>11.1.2.&nbsp;Implementing a View</h3></div></div><div></div></div><p>
				A view class is responsible for:
			</p><div class="itemizedlist"><ul type="disc" compact><li><p>
						The <tt class="literal">setParent</tt> method informs the view of the parent view's event type
					</p></li><li><p>
						The <tt class="literal">update</tt> method receives insert streams and remove stream events from its parent view
					</p></li><li><p>
						The <tt class="literal">iterator</tt> method supplies an (optional) iterator to allow an application to pull or request results from an <tt class="literal">EPStatement</tt>
					</p></li><li><p>
						The <tt class="literal">cloneView</tt> method must make a configured copy of the view to enable the view to work in a grouping context together with a <tt class="literal">std:groupby</tt> parent view
					</p></li></ul></div><p>
				View classes simply subclass <tt class="literal">com.espertech.esper.view.ViewSupport</tt>:
			</p><pre class="programlisting">public class MyTrendSpotterView extends ViewSupport { ...</pre><p>
				Your view's <tt class="literal">update</tt> method will be processing incoming (insert stream) and outgoing (remove stream) events posted by the parent view (if any), as well as providing incoming and outgoing events to child views. The convention required of your update method implementation is that the view releases any insert stream events (EventBean object references) which the view generates as reference-equal remove stream events (EventBean object references) at a later time. 
			</p><p>
				The view implementation must call the <tt class="literal">updateChildren</tt> method to post outgoing insert and remove stream events. Similar to the <tt class="literal">update</tt> method, the <tt class="literal">updateChildren</tt> method takes insert and remove stream events as parameters.
			</p><p>
				A sample <tt class="literal">update</tt> method implementation is provided in the OHLC example.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="custom-views-contract"></a>11.1.3.&nbsp;View Contract</h3></div></div><div></div></div><p>
				The <tt class="literal">update</tt> method must adhere to the following conventions, to prevent memory leaks and to enable correct behavior within the engine:
			</p><div class="itemizedlist"><ul type="disc" compact><li><p>
						A view implementation that posts events to the insert stream must post unique <tt class="literal">EventBean</tt> object references as insert stream events, and cannot post the same <tt class="literal">EventBean</tt> object reference multiple times. The underlying event to the <tt class="literal">EventBean</tt> object reference can be the same object reference, however the <tt class="literal">EventBean</tt> object reference posted by the view into the insert stream must be a new instance for each insert stream event.
					</p></li><li><p>
						If the custom view posts a continuous insert stream, then the views must also post a continuous remove stream (second parameter to the <tt class="literal">updateChildren</tt> method). If the view does not post remove stream events, it assumes unbound keep-all semantics.
					</p></li><li><p>
						<tt class="literal">EventBean</tt> events posted as remove stream events must be the same object reference as the <tt class="literal">EventBean</tt> events posted as insert stream by the view. Thus remove stream events posted by the view (the <tt class="literal">EventBean</tt> instances, does not affect the underlying representation) must be reference-equal to insert stream events posted by the view as part of an earlier invocation of the update method, or the same invocation of the update method.
					</p></li><li><p>
						<tt class="literal">EventBean</tt> events represent a unique observation. The values of the observation can be the same, thus the underlying representation of an <tt class="literal">EventBean</tt> event can be reused, however event property values must be kept immutable and not be subject to change.
					</p></li><li><p>
						Array elements of the insert and remove stream events must not carry null values. Array size must match the number of <tt class="literal">EventBean</tt> instances posted. It is recommended to use a <tt class="literal">null</tt> value for no insert or remove stream events rather then an empty zero-size array. 
					</p></li></ul></div><p>
				The engine can provide a callback to the view indicating when a statement using the view is stopped. The callback is available to the view via the <tt class="literal">com.espertech.esper.view.StatementStopCallback</tt> interface. Your
				view code must subscribe to the stop callback in order for the engine to invoke the callback:
			</p><pre class="programlisting">statementContext.getStatementStopService().addSubscriber(this);</pre><p>
				Please refer to the sample views for a code sample on how to implement <tt class="literal">iterator</tt> and <tt class="literal">cloneView</tt> methods.
			</p><p>
				In terms of multiple threads accessing view state, there is no need for your custom view factory or view implementation to perform any synchronization to protect internal state. The iterator of the custom view implementation does also not need to be thread-safe. The engine ensures the custom view executes in the context of a single thread at a time. If your view uses shared external state, such external state must be still considered for synchronization when using multiple threads.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="custom-views-config"></a>11.1.4.&nbsp;Configuring View Namespace and Name</h3></div></div><div></div></div><p>
				The view factory class name as well as the view namespace and name for the new view must be added to the engine configuration via the configuration API or using the XML configuration file. The configuration shown below is XML however the same options are available through the configuration API:
			</p><pre class="programlisting">&lt;esper-configuration
  &lt;plugin-view namespace="custom" name="trendspotter" 
      factory-class="com.espertech.esper.regression.view.MyTrendSpotterViewFactory" /&gt; 
&lt;/esper-configuration&gt;</pre><p>
				The new view is now ready to use in a statement:
			</p><pre class="programlisting">select * from StockTick.custom:trendspotter(price)</pre><p>
				Note that the view must implement additional interfaces if it acts as a data window view, or works in a grouping context, as discussed in more detail below.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="custom-views-datawin"></a>11.1.5.&nbsp;Requirement for Data Window Views</h3></div></div><div></div></div><p>
				Your custom view may represent an expiry policy and may retain events and thus act as a data window view. In order to allow the engine to validate that your view can be used with named windows, which allow only data window views,
				this section documents any additional requirement that your classes must fulfill.
			</p><p>
				Your view factory class must implement the <tt class="literal">com.espertech.esper.view.DataWindowViewFactory</tt> interface. This marker interface (no methods required) indicates that your view factory provides only data window views.  
			</p><p>
				Your view class must implement the <tt class="literal">com.espertech.esper.view.DataWindowView</tt> interface. This marker interface indicates that your view is a data window view and therefore eligible to be used in any construct that requires a data window  view.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="custom-views-grouped"></a>11.1.6.&nbsp;Requirement for Grouped Views</h3></div></div><div></div></div><p>
				Grouped views are views that operate under the <tt class="literal">std:groupby</tt> view. When operating under one or more <tt class="literal">std:groupby</tt> views, the engine instantiates a single view instance when the statement starts, and a new view instance per group criteria dynamically as new group criteria become known. 
			</p><p>
				The next statement shows EPL for using a view instance per grouping criteria:
			</p><pre class="programlisting">select * from StockTick.std:groupby(symbol).custom:trendspotter(price)</pre><p>
				Your view must implement the <tt class="literal">com.espertech.esper.view.CloneableView</tt> interface to indicate your view may create new views. This code snippet shows a sample implementation of the <tt class="literal">cloneView</tt> method required by the interface:
			</p><pre class="programlisting">public View cloneView(StatementContext statementContext) {
  return new MyPlugInView(statementContext);	// pass any parameters along where
}</pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="custom-aggregation-function"></a>11.2.&nbsp;Custom Aggregation Functions</h2></div></div><div></div></div><a class="indexterm" name="d0e19190"></a><p>
			Aggregation functions aggregate event property values or expression results obtained from one or more streams. Examples for built-in aggregation functions are <tt class="literal">count(*)</tt>, <tt class="literal">sum(price * volume)</tt> or <tt class="literal">avg(distinct volume)</tt>.
        </p><p>
			The optional keyword <tt class="literal">distinct</tt> ensures that only distinct (unique) values are aggregated and duplicate values are ignored by the aggregation function. Custom plug-in aggregation functions do not need to implement the logic to handle <tt class="literal">distinct</tt> values. This is because when the engine encounters the <tt class="literal">distinct</tt> keyword, it eliminates any non-distinct values before passing the value for aggregation to the custom aggregation function.
        </p><p>
			Custom aggregation functions can also be passed multiple parameters, as further discribed in <a href="#custom-aggregation-multiparam" title="11.2.3.&nbsp;Accepting Multiple Parameters">Section&nbsp;11.2.3, &#8220;Accepting Multiple Parameters&#8221;</a>. In the example below the aggregation function accepts a single parameter.
        </p><p>
			The following steps are required to develop and use a custom aggregation function with Esper. 
        </p><div class="orderedlist"><ol type="1" compact><li><p>
					Implement an aggregation function class.
				</p></li><li><p>
					Register the aggregation function class with the engine by supplying a function name, via the engine configuration file or the configuration API.
				</p></li></ol></div><p>
			The code for the example aggregation function as shown in this chapter can be found in the test source folder in the package <tt class="literal">com.espertech.esper.regression.client</tt> by the name <tt class="literal">MyConcatAggregationFunction</tt>. The sample function simply concatenates string-type values.
        </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="custom-aggregation-implementing"></a>11.2.1.&nbsp;Implementing an Aggregation Function</h3></div></div><div></div></div><p>
				An aggregation function class is responsible for the following functions:
			</p><div class="itemizedlist"><ul type="disc" compact><li><p>
						Implement a <tt class="literal">validate</tt> method that validates the value type of the data points that the function must process.
					</p></li><li><p>
						Implement a <tt class="literal">getValueType</tt> method that returns the type of the aggregation value generated by the function. For example, the built-in <tt class="literal">count</tt> aggregation function returns <tt class="literal">Long.class</tt> as it generates <tt class="literal">long</tt> -typed values.
					</p></li><li><p>
						Implement an <tt class="literal">enter</tt> method that the engine invokes to add a data point into the aggregation, when an event enters a data window
					</p></li><li><p>
						Implement a <tt class="literal">leave</tt> method that the engine invokes to remove a data point from the aggregation, when an event leaves a data window
					</p></li><li><p>
						Implement a <tt class="literal">getValue</tt> method that returns the current value of the aggregation. 
					</p></li></ul></div><p>
				Aggregation function classes simply subclass <tt class="literal">com.espertech.esper.epl.agg.AggregationSupport</tt>:
			</p><pre class="programlisting">public class MyConcatAggregationFunction extends AggregationSupport { ...</pre><p>
				The engine generally constructs one instance of the aggregation function class for each time the function is listed in a statement, however the engine may decide to reduce the number of aggregation class instances if it finds equivalent aggregations. The constructor initializes the aggregation function:
			</p><pre class="programlisting">public class MyConcatAggregationFunction extends AggregationSupport {
  private final static char DELIMITER = ' ';
  private StringBuilder builder;
  private String delimiter;

  public MyConcatAggregationFunction()
  {
    super();
    builder = new StringBuilder();
    delimiter = "";
  }
  ...</pre><p>
				An aggregation function must provide an implementation of the <tt class="literal">validate</tt> method that is passed the result type of the expression within the aggregation function. Since the example concatenation function requires string types, it implements a type check:
			</p><pre class="programlisting">public void validate(Class childNodeType) {
  if (childNodeType != String.class) {
    throw new IllegalArgumentException("Concat aggregation requires a String parameter");
  }
}</pre><p>
				The <tt class="literal">enter</tt> method adds a datapoint to the current aggregation value. The example <tt class="literal">enter</tt> method shown below adds a delimiter and the string value to a string buffer:
			</p><pre class="programlisting">public void enter(Object value) {
  if (value != null) {
    builder.append(delimiter);
    builder.append(value.toString());
    delimiter = String.valueOf(DELIMITER);
  }
}</pre><p>
				Conversly, the <tt class="literal">leave</tt> method removes a datapoint from the current aggregation value. The example <tt class="literal">leave</tt> method removes from the string buffer:
			</p><pre class="programlisting">public void leave(Object value) {
  if (value != null) {
    builder.delete(0, value.toString().length() + 1);
  }
}</pre><p>
				In order for the engine to validate the type returned by the aggregation function against the types expected by enclosing expressions, the <tt class="literal">getValueType</tt> must return the result type of any values produced by the aggregation function:
			</p><pre class="programlisting">public Class getValueType() {
  return String.class;
}</pre><p>
				Finally, the engine obtains the current aggregation value by means of the <tt class="literal">getValue</tt> method:
			</p><pre class="programlisting">public Object getValue() {
  return builder.toString();
}</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="custom-aggregation-config"></a>11.2.2.&nbsp;Configuring Aggregation Function Name</h3></div></div><div></div></div><p>
				The aggregation function class name as well as the function name for the new aggregation function must be added to the engine configuration via the configuration API or using the XML configuration file. The configuration shown below is XML however the same options are available through the configuration API:
			</p><pre class="programlisting">&lt;esper-configuration
  &lt;plugin-aggregation-function name="concat" 
    function-class="com.espertech.esper.regression.client.MyConcatAggregationFunction" /&gt;
&lt;/esper-configuration&gt;</pre><p>
				The new aggregation function is now ready to use in a statement:
			</p><pre class="programlisting">select concat(symbol) from StockTick.win:length(3)</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="custom-aggregation-multiparam"></a>11.2.3.&nbsp;Accepting Multiple Parameters</h3></div></div><div></div></div><p>
				Your plug-in aggregation function may accept multiple parameters, simply by casting the Object parameter of the <tt class="literal">enter</tt> and <tt class="literal">leave</tt> method to <tt class="literal">Object[]</tt>.
			</p><p>
				For instance, assume an aggregation function <tt class="literal">rangeCount</tt> that counts all values that fall into a range of values. The EPL that calls this function and provides a lower and upper bounds of 1 and 10 is:
			</p><pre class="programlisting">select rangeCount(1, 10, myValue) from MyEvent</pre><p>
				The <tt class="literal">enter</tt> method of the plug-in aggregation function may look as follows:
			</p><pre class="programlisting">public void enter(Object value)  {
  Object[] params = (Object[]) value;
  int lower = (Integer) params[0];
  int upper = (Integer) params[1];
  int val = (Integer) params[2];
  if ((val &gt;= lower) &amp;&amp; (val &lt;= upper)) {
    count++;
  }
}</pre><p>
				Your plug-in aggregation function may want to validate parameter types or may want to know which parameters are constant-value expressions. Constant-value expressions are evaluated only once by the engine and could
				therefore be cached by your aggregation function for performance reasons.
			</p><p>
				To validate parameter types, or cache constant-value expressions results, override the <tt class="literal">validateMultiParameter</tt> method in your implementation of <tt class="literal">AggregationSupport</tt>. The engine provides the parameter type of each parameter. It also provides a flag indicating that the parameter is the result of a constant-value expression and provides the constant itself (if constant).
			</p><p>
				This sample implementation of <tt class="literal">validateMultiParameter</tt> simply checks that boundary values are of type Integer:
			</p><pre class="programlisting">public void validateMultiParameter(Class[] parameterType, 
  boolean[] isConstantValue, 
  Object[] constantValue) {
  super.validateMultiParameter(childNodeType, isConstantValue, constantValue);
  if ((childNodeType[0] != Integer.class) || (childNodeType[1] != Integer.class)) {
    throw new IllegalArgumentException("Expected integer bounds");        
  }
}</pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="custom-pattern-guard"></a>11.3.&nbsp;Custom Pattern Guard</h2></div></div><div></div></div><a class="indexterm" name="d0e19394"></a><p>
			Pattern guards are pattern objects that control the lifecycle of the guarded sub-expression, and can filter the events fired by the subexpression. 
        </p><p>
			The following steps are required to develop and use a custom guard object with Esper. 
        </p><div class="orderedlist"><ol type="1" compact><li><p>
					Implement a guard factory class, responsible for creating guard object instances.
				</p></li><li><p>
					Implement a guard class.
				</p></li><li><p>
					Register the guard factory class with the engine by supplying a namespace and name, via the engine configuration file or the configuration API.
				</p></li></ol></div><p>
			The code for the example guard object as shown in this chapter can be found in the test source folder in the package <tt class="literal">com.espertech.esper.regression.client</tt> by the name <tt class="literal">MyCountToPatternGuardFactory</tt>. The sample guard discussed here counts the number of events occurring up to a maximum number of events, and end the sub-expression when that maximum is reached.
        </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="custom-pattern-guard-factory-implementing"></a>11.3.1.&nbsp;Implementing a Guard Factory</h3></div></div><div></div></div><p>
				A guard factory class is responsible for the following functions:
			</p><div class="itemizedlist"><ul type="disc" compact><li><p>
						Implement a <tt class="literal">setGuardParameters</tt> method that takes guard parameters, which are themselves expressions.
					</p></li><li><p>
						Implement a <tt class="literal">makeGuard</tt> method that constructs a new guard instance.
					</p></li></ul></div><p>
				Guard factory classes subclass <tt class="literal">com.espertech.esper.pattern.guard.GuardFactorySupport</tt>:
			</p><pre class="programlisting">public class MyCountToPatternGuardFactory extends GuardFactorySupport { ...</pre><p>
				The engine constructs one instance of the guard factory class for each time the guard is listed in a statement. 
			</p><p>
				The guard factory class implements the <tt class="literal">setGuardParameters</tt> method that is passed the parameters to the guard as supplied by the statement. It verifies the guard parameters, similar to the code snippet shown next. Our example counter guard takes a single numeric parameter:
			</p><pre class="programlisting">public void setGuardParameters(List&lt;ExprNode&gt; guardParameters, 
			MatchedEventConvertor convertor) throws GuardParameterException {
    String message = "Count-to guard takes a single integer-value expression as parameter";
    if (guardParameters.size() != 1) {
        throw new GuardParameterException(message);
    }

    if (guardParameters.get(0).getType() != Integer.class) {
        throw new GuardParameterException(message);
    }

    this.numCountToExpr = guardParameters.get(0);
    this.convertor = convertor;
}</pre><p>
				The <tt class="literal">makeGuard</tt> method is called by the engine to create a new guard instance. The example <tt class="literal">makeGuard</tt> method shown below passes the maximum count of events to the guard instance. It also passes a <tt class="literal">Quitable</tt> implementation to the guard instance. The guard uses <tt class="literal">Quitable</tt> to indicate that the sub-expression contained within must stop (quit) listening for events.
			</p><pre class="programlisting">public Guard makeGuard(PatternContext context, 
      MatchedEventMap beginState, 
      Quitable quitable, 
      Object stateNodeId, 
      Object guardState) {
      
    Object parameter = PatternExpressionUtil.evaluate("Count-to guard", 
        beginState, numCountToExpr, convertor);
    if (parameter == null) {
        throw new EPException("Count-to guard parameter evaluated to a null value");
    }

    Integer numCountTo = (Integer) parameter;
    return new MyCountToPatternGuard(numCountTo, quitable);
}</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="custom-pattern-guard-implementing"></a>11.3.2.&nbsp;Implementing a Guard Class</h3></div></div><div></div></div><p>
				A guard class has the following responsibilities:
			</p><div class="itemizedlist"><ul type="disc" compact><li><p>
						Provides a <tt class="literal">startGuard</tt> method that initalizes the guard.
					</p></li><li><p>
						Provides a <tt class="literal">stopGuard</tt> method that stops the guard, called by the engine when the whole pattern is stopped, or the sub-expression containing the guard is stopped.
					</p></li><li><p>
						Provides an <tt class="literal">inspect</tt> method that the pattern engine invokes to determine if the guard lets matching events pass for further evaluation by the containing expression.
					</p></li></ul></div><p>
				Guard classes subclass <tt class="literal">com.espertech.esper.pattern.guard.GuardSupport</tt> as shown here:
			</p><pre class="programlisting">public abstract class GuardSupport implements Guard { ...</pre><p>
				The engine invokes the guard factory class to construct an instance of the guard class for each new sub-expression instance within a statement.
			</p><p>
				A guard class must provide an implementation of the <tt class="literal">startGuard</tt> method that the pattern engine invokes to start a guard instance. In our example, the method resets the guard's counter to zero:
			</p><pre class="programlisting">public void startGuard() {
  counter = 0;
}</pre><p>
				The pattern engine invokes the <tt class="literal">inspect</tt> method for each time the sub-expression indicates a new event result. Our example guard needs to count the number of events matched, and quit if the maximum number is reached:
			</p><pre class="programlisting">public boolean inspect(MatchedEventMap matchEvent) {
  counter++;
  if (counter &gt; numCountTo) {
    quitable.guardQuit();
    return false;
  }
  return true;
}</pre><p>
				The <tt class="literal">inspect</tt> method returns true for events that pass the guard, and false for events that should not pass the guard.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="custom-pattern-guard-config"></a>11.3.3.&nbsp;Configuring Guard Namespace and Name</h3></div></div><div></div></div><p>
				The guard factory class name as well as the namespace and name for the new guard must be added to the engine configuration via the configuration API or using the XML configuration file. The configuration shown below is XML however the same options are available through the configuration API:
			</p><pre class="programlisting">&lt;esper-configuration
  &lt;plugin-pattern-guard namespace="myplugin" name="count_to" 
      factory-class="com.espertech.esper.regression.client.MyCountToPatternGuardFactory"/&gt;
&lt;/esper-configuration&gt;</pre><p>
				The new guard is now ready to use in a statement. The next pattern statement detects the first 10 MyEvent events:
			</p><pre class="programlisting">select * from pattern [(every MyEvent) where myplugin:count_to(10)]</pre><p>
				Note that the <tt class="literal">every</tt> keyword was placed within parentheses to ensure the guard controls the repeated matching of events.
			</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="custom-pattern-observer"></a>11.4.&nbsp;Custom Pattern Observer</h2></div></div><div></div></div><a class="indexterm" name="d0e19542"></a><p>
			Pattern observers are pattern objects that are executed as part of a pattern expression and can observe events or test conditions. Examples for built-in observers are <tt class="literal">timer:at</tt> and <tt class="literal">timer:interval</tt>. Some suggested uses of observer objects are: 
        </p><div class="itemizedlist"><ul type="disc" compact><li><p>
					Implement custom scheduling logic using the engine's own scheduling and timer services
				</p></li><li><p>
					Test conditions related to prior events matching an expression
				</p></li></ul></div><p>
			The following steps are required to develop and use a custom observer object within pattern statements: 
        </p><div class="orderedlist"><ol type="1" compact><li><p>
					Implement an observer factory class, responsible for creating observer object instances.
				</p></li><li><p>
					Implement an observer class.
				</p></li><li><p>
					Register an observer factory class with the engine by supplying a namespace and name, via the engine configuration file or the configuration API.
				</p></li></ol></div><p>
			The code for the example observer object as shown in this chapter can be found in the test source folder in package <tt class="literal">com.espertech.esper.regression.client</tt> by the name <tt class="literal">MyFileExistsObserver</tt>. The sample observer discussed here very simply checks if a file exists, using the filename supplied by the pattern statement, and via the <tt class="literal">java.io.File</tt> class.
        </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="custom-pattern-observer-factory-implementing"></a>11.4.1.&nbsp;Implementing an Observer Factory</h3></div></div><div></div></div><p>
				An observer factory class is responsible for the following functions:
			</p><div class="itemizedlist"><ul type="disc" compact><li><p>
						Implement a <tt class="literal">setObserverParameters</tt> method that takes observer parameters, which are themselves expressions.
					</p></li><li><p>
						Implement a <tt class="literal">makeObserver</tt> method that constructs a new observer instance.
					</p></li></ul></div><p>
				Observer factory classes subclass <tt class="literal">com.espertech.esper.pattern.observer.ObserverFactorySupport</tt>:
			</p><pre class="programlisting">public class MyFileExistsObserverFactory extends ObserverFactorySupport { ...</pre><p>
				The engine constructs one instance of the observer factory class for each time the observer is listed in a statement. 
			</p><p>
				The observer factory class implements the <tt class="literal">setObserverParameters</tt> method that is passed the parameters to the observer as supplied by the statement. It verifies the observer parameters, similar to the code snippet shown next. Our example file-exists observer takes a single string parameter:
			</p><pre class="programlisting">public void setObserverParameters(List&lt;ExprNode&gt; expressionParameters, 
			MatchedEventConvertor convertor) throws ObserverParameterException {
    String message = "File exists observer takes a single string filename parameter";
    if (expressionParameters.size() != 1) {
	    throw new ObserverParameterException(message);
    }
    if (!(expressionParameters.get(0).getType() == String.class)) {
	    throw new ObserverParameterException(message);
    }

    this.filenameExpression = expressionParameters.get(0);
    this.convertor = convertor;
}</pre><p>
				The pattern engine calls the <tt class="literal">makeObserver</tt> method to create a new observer instance. The example <tt class="literal">makeObserver</tt> method shown below passes parameters to the observer instance:
			</p><pre class="programlisting">public EventObserver makeObserver(PatternContext context, 
			MatchedEventMap beginState, 
			ObserverEventEvaluator observerEventEvaluator, 
			Object stateNodeId, 
			Object observerState) {
    Object filename = PatternExpressionUtil.evaluate("File-exists observer ", beginState, filenameExpression, convertor);
    if (filename == null) {
	    throw new EPException("Filename evaluated to null");
    }

    return new MyFileExistsObserver(beginState, observerEventEvaluator, filename.toString());
}</pre><p>
				The <tt class="literal">ObserverEventEvaluator</tt> parameter allows an observer to indicate events, and to indicate change of truth value to permanently false. Use this interface to indicate when your observer has received or witnessed an event, or changed it's truth value to true or permanently false.
			</p><p>
				The <tt class="literal">MatchedEventMap</tt> parameter provides a Map of all matching events for the expression prior to the observer's start. For example, consider a pattern as below:
			</p><pre class="programlisting">a=MyEvent -&gt; myplugin:my_observer(...)</pre><p>
				The above pattern tagged the MyEvent instance with the tag "a". The pattern engine starts an instance of <tt class="literal">my_observer</tt> when it receives the first MyEvent. The observer can query the <tt class="literal">MatchedEventMap</tt> using  "a" as a key and obtain the tagged event.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="custom-pattern-observer-implementing"></a>11.4.2.&nbsp;Implementing an Observer Class</h3></div></div><div></div></div><p>
				An observer class has the following responsibilities:
			</p><div class="itemizedlist"><ul type="disc" compact><li><p>
						Provides a <tt class="literal">startObserve</tt> method that starts the observer.
					</p></li><li><p>
						Provides a <tt class="literal">stopObserve</tt> method that stops the observer, called by the engine when the whole pattern is stopped, or the sub-expression containing the observer is stopped.
					</p></li></ul></div><p>
				Observer classes subclass <tt class="literal">com.espertech.esper.pattern.observer.ObserverSupport</tt> as shown here:
			</p><pre class="programlisting">public class MyFileExistsObserver implements EventObserver { ...</pre><p>
				The engine invokes the observer factory class to construct an instance of the observer class for each new sub-expression instance within a statement.
			</p><p>
				An observer class must provide an implementation of the <tt class="literal">startObserve</tt> method that the pattern engine invokes to start an observer instance. In our example, the observer checks for the presence of a file and indicates the truth value to the remainder of the expression:
			</p><pre class="programlisting">public void startObserve() {
  File file = new File(filename);
  if (file.exists()) {
    observerEventEvaluator.observerEvaluateTrue(beginState);
  } 
  else {
    observerEventEvaluator.observerEvaluateFalse(); 
  }
}</pre><p>
				Note the observer passes the <tt class="literal">ObserverEventEvaluator</tt> an instance of <tt class="literal">MatchedEventMap</tt>. The observer can also create one or more new events and pass these events through the Map to the remaining expressions in the pattern.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="custom-pattern-observer-config"></a>11.4.3.&nbsp;Configuring Observer Namespace and Name</h3></div></div><div></div></div><p>
				The observer factory class name as well as the namespace and name for the new observer must be added to the engine configuration via the configuration API or using the XML configuration file. The configuration shown below is XML however the same options are available through the configuration API:
			</p><pre class="programlisting">&lt;esper-configuration
  &lt;plugin-pattern-observer namespace="myplugin" name="file_exists" 
    factory-class="com.espertech.esper.regression.client.MyFileExistsObserverFactory" /&gt;
&lt;/esper-configuration&gt;</pre><p>
				The new observer is now ready to use in a statement. The next pattern statement checks every 10 seconds if the given file exists, and indicates to the listener when the file is found.
			</p><pre class="programlisting">select * from pattern [every timer:interval(10 sec) -&gt; myplugin:file_exists("myfile.txt")]</pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="custom-event-representation"></a>11.5.&nbsp;Custom Event Representation</h2></div></div><div></div></div><a class="indexterm" name="d0e19705"></a><a class="indexterm" name="d0e19708"></a><p>
			Creating a plug-in event representation can be useful under any of these conditions:
		</p><div class="itemizedlist"><ul type="disc" compact><li><p>
					Your application has existing Java classes that carry event metadata and event property values and your application does not want to (or cannot) extract or transform such event metadata and event data into one of the built-in event representations (POJO Java objects, Map or XML DOM).
				</p></li><li><p>
					Your application wants to provide a faster or short-cut access path to event data, for example to access XML event data through a Streaming API for XML (StAX).
				</p></li><li><p>
					Your application must perform a network lookup or other dynamic resolution of event type and events.
				</p></li></ul></div><p>
			Note that the classes to plug-in custom event representations are held stable between minor releases, but can be subject to change between major releases. 
		</p><p>
			Currently, EsperIO provides the following additional event representations:
		</p><div class="itemizedlist"><ul type="disc" compact><li><p>
					Apache Axiom provides access to XML event data on top of the fast Streaming API for XML (StAX). 
				</p></li></ul></div><p>
			The source code is available for these and they are therefore excellent examples for how to implement a plug-in event representation.
			Please see the EsperIO documentation for usage details.
		</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="custom-eventrep-overview"></a>11.5.1.&nbsp;How It Works</h3></div></div><div></div></div><p>
				Your application provides a plug-in event representation as an implementation of the <tt class="literal">com.espertech.esper.plugin.PlugInEventRepresentation</tt> interface. It registers the implementation class in the
				<tt class="literal">Configuration</tt> and at the same time provides a unique URI. This URI is called the root event representation URI. An example value for a root URI is <tt class="literal">type://xml/apacheaxiom/OMNode</tt>. 
			</p><p>
				One can register multiple plug-in event representations. Each representation has a root URI. The root URI serves to divide the overall space of different event representations and plays a role in resolving event types and event objects.
			</p><p>
				There are two situations in an Esper engine instance asks an event representation for an event type:
			</p><div class="orderedlist"><ol type="1"><li><p>
						When an application registers a new event type using the method <tt class="literal">addPlugInEventType</tt> on <tt class="literal">ConfigurationOperations</tt>, either at runtime or at configuration time.
					</p></li><li><p>
						When an EPL statement is created with a new event type name (a name not seen before) and the URIs for resolving such names are set beforehand via <tt class="literal">setPlugInEventTypeNameResolutionURIs</tt> on <tt class="literal">ConfigurationOperations</tt>.
					</p></li></ol></div><p>
				The implementation of the <tt class="literal">PlugInEventRepresentation</tt> interface must provide implementations for two key interfaces: <tt class="literal">com.espertech.esper.client.EventType</tt> and <tt class="literal">EventBean</tt>. It must also implement several other related interfaces as described below.
			</p><p>
				The <tt class="literal">EventType</tt> methods provide event metadata including property names and property types. They also provide instances of <tt class="literal">EventPropertyGetter</tt> for retrieving event property values. Each instance of <tt class="literal">EventType</tt> represents a distinct type of event.
			</p><p>
				The <tt class="literal">EventBean</tt> implementation is the event itself and encapsulates the underlying event object.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="custom-eventrep-steps"></a>11.5.2.&nbsp;Steps</h3></div></div><div></div></div><p>
				Follow the steps outlined below to process event objects for your event types:
			</p><div class="orderedlist"><ol type="1" compact><li><p>
						Implement the <tt class="literal">EventType</tt>, <tt class="literal">EventPropertyGetter</tt> and <tt class="literal">EventBean</tt> interfaces.
					</p></li><li><p>
						Implement the <tt class="literal">PlugInEventRepresentation</tt> interface, the <tt class="literal">PlugInEventTypeHandler</tt> and <tt class="literal">PlugInEventBeanFactory</tt> interfaces, then add the <tt class="literal">PlugInEventRepresentation</tt> class name to configuration.
					</p></li><li><p>
						Register plug-in event types, and/or set the event type name resolution URIs, via configuration.
					</p></li><li><p>
						Obtain an <tt class="literal">EventSender</tt> from <tt class="literal">EPRuntime</tt> via the <tt class="literal">getEventSender(URI[])</tt> method and use that to send in your event objects.
					</p></li></ol></div><p>
				Please consult the JavaDoc for further information on each of the interfaces and their respective methods. The Apache Axiom event representation is an example implementation that can be found in the 
				EsperIO packages.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="custom-eventrep-uriresolution"></a>11.5.3.&nbsp;URI-based Resolution</h3></div></div><div></div></div><p>
				Assume you have registered event representations using the following URIs:
			</p><div class="orderedlist"><ol type="1" compact><li><p>
						type://myFormat/myProject/myName
					</p></li><li><p>
						type://myFormat/myProject
					</p></li><li><p>
						type://myFormat/myOtherProject
					</p></li></ol></div><p>
				When providing an array of child URIs for resolution, the engine compares each child URI to each of the event representation root URIs, in the order provided. Any event representation root URIs that 
				spans the child URI space becomes a candidate event representation. If multiple root URIs match, the order is defined by the more specific root URI first, to the least specific root URI last.
			</p><p>
				During event type resolution and event sender resolution you provide a child URI. Assuming the child URI provided is <tt class="literal">type://myFormat/myProject/myName/myEvent?param1=abc&amp;param2=true</tt>. In this example both root URIs #1 (the more specific) and #1 (the less specific) match, while root URI #3 is not a match. Thus at the time of type resolution the engine invokes the <tt class="literal">acceptType</tt> method on event presentation for URI #1 first (the more specific), before asking #2 (the less specific) to resolve the type.
			</p><p>			    
				The <tt class="literal">EventSender</tt> returned by the <tt class="literal">getEventSender(URI[])</tt> method follows the same scheme. The event sender instance asks each matching event representation for each URI to resolve the event object in the order of most specific to least specific root URI, and the first event representation to return an instance of <tt class="literal">EventBean</tt> ends the resolution process for event objects.
			</p><p>
				The <tt class="literal">type://</tt> part of the URI is an optional convention for the scheme part of an URI that your application may follow. URIs can also be simple names and can include parameters, as the Java software JavaDoc documents for class <tt class="literal">java.net.URI</tt>.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="custom-eventrep-example"></a>11.5.4.&nbsp;Example</h3></div></div><div></div></div><p>
					This section implements a minimal sample plug-in event representation. For the sake of keeping the example easy to understand, the event representation is rather straightforward: an event is a <tt class="literal">java.util.Properties</tt> object that consists of key-values pairs of type string.
				</p><p>
					The code shown next does not document method footprints. Please consult the JavaDoc API documentation for method details.
				</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="custom-eventrep-example-eventtype"></a>11.5.4.1.&nbsp;Sample Event Type</h4></div></div><div></div></div><p>
					First, the sample shows how to implement the <tt class="literal">EventType</tt> interface. The event type provides information about property names and types, as well as supertypes of the event type.
				</p><p>
					Our <tt class="literal">EventType</tt> takes a set of valid property names:
				</p><pre class="programlisting">public class MyPlugInPropertiesEventType implements EventType {
  private final Set&lt;String&gt; properties;

  public MyPlugInPropertiesEventType(Set&lt;String&gt; properties) {
    this.properties = properties;
  }

  public Class getPropertyType(String property) {
    if (!isProperty(property)) {
      return null;
    }
    return String.class;
  }

  public Class getUnderlyingType() {
    return Properties.class;
  }
  
  //... further methods below
}</pre><p>
					An <tt class="literal">EventType</tt> is responsible for providing implementations of <tt class="literal">EventPropertyGetter</tt> to query actual events. The getter simply
					queries the <tt class="literal">Properties </tt> object underlying each event:
				</p><pre class="programlisting">  public EventPropertyGetter getGetter(String property) {
    final String propertyName = property;
    
    return new EventPropertyGetter() {
      public Object get(EventBean eventBean) throws PropertyAccessException {
        MyPlugInPropertiesEventBean propBean = (MyPlugInPropertiesEventBean) eventBean;
        return propBean.getProperties().getProperty(propertyName);
      }
      
      public boolean isExistsProperty(EventBean eventBean) {
        MyPlugInPropertiesEventBean propBean = (MyPlugInPropertiesEventBean) eventBean;
        return propBean.getProperties().getProperty(propertyName) != null;
      }
      
      public Object getFragment(EventBean eventBean) {
	    return null;	// The property is not a fragment
      }
    };
  }</pre><p>
				  Our sample <tt class="literal">EventType</tt> does not have supertypes. Supertypes represent an extends-relationship between event types, and subtypes are expected to exhibit the same event property names and types as each of their supertypes combined:
				</p><pre class="programlisting">  public EventType[] getSuperTypes() {
    return null;	// no supertype for this example
  }

  public Iterator&lt;EventType&gt; getDeepSuperTypes() {
    return null;
  }
  
  public String getName() {
    return name;
  }

  public EventPropertyDescriptor[] getPropertyDescriptors() {
    Collection&lt;EventPropertyDescriptor&gt; descriptorColl = descriptors.values();
    return descriptorColl.toArray(new EventPropertyDescriptor[descriptors.size()]);
  }

  public EventPropertyDescriptor getPropertyDescriptor(String propertyName) {
    return descriptors.get(propertyName);
  }

  public FragmentEventType getFragmentType(String property) {
    return null;  // sample does not provide any fragments
  }</pre><p>
			The example event type as above does not provide fragments, which are properties of the event that can themselves be represented as an event, to keep the example simple.
		  </p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="custom-eventrep-example-eventbean"></a>11.5.4.2.&nbsp;Sample Event Bean</h4></div></div><div></div></div><p>
					Each <tt class="literal">EventBean</tt> instance represents an event. The interface is straightforward to implement. In this example an event is backed by a <tt class="literal">Properties</tt> object:
				</p><pre class="programlisting">public class MyPlugInPropertiesEventBean implements EventBean {
  private final MyPlugInPropertiesEventType eventType;
  private final Properties properties;

  public MyPlugInPropertiesEventBean(MyPlugInPropertiesEventType eventType, 
        Properties properties) {
    this.eventType = eventType;
    this.properties = properties;
  }

  public EventType getEventType() {
    return eventType;
  }

  public Object get(String property) throws PropertyAccessException {
    EventPropertyGetter getter = eventType.getGetter(property);
    return getter.get(this);
  }

  public Object getFragment(String property) {
    EventPropertyGetter getter = eventType.getGetter(property);
    if (getter != null) {
      return getter.getFragment(this);
    }
    return null;
  }

  public Object getUnderlying() {
    return properties;
  }

  protected Properties getProperties() {
    return properties;
  }    
}</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="custom-eventrep-example-eventrep"></a>11.5.4.3.&nbsp;Sample Event Representation</h4></div></div><div></div></div><p>
					A <tt class="literal">PlugInEventRepresentation</tt> serves to create <tt class="literal">EventType</tt> and <tt class="literal">EventBean</tt> instances through its related interfaces.
				</p><p>
					The sample event representation creates <tt class="literal">MyPlugInPropertiesEventType</tt> and <tt class="literal">MyPlugInPropertiesEventBean</tt> instances. 
					The <tt class="literal">PlugInEventTypeHandler</tt> returns the <tt class="literal">EventType</tt> instance and an <tt class="literal">EventSender</tt> instance.
				</p><p>
					Our sample event representation accepts all requests for event types by returning boolean true on the <tt class="literal">acceptType</tt> method.  When asked for the <tt class="literal">PlugInEventTypeHandler</tt>, it constructs a new <tt class="literal">EventType</tt>. The list of property names for the new type is passed as an initialization value provided through the configuration API or XML, as a comma-separated list of property names:
				</p><pre class="programlisting">public class MyPlugInEventRepresentation implements PlugInEventRepresentation {

  private List&lt;MyPlugInPropertiesEventType&gt; types;

  public void init(PlugInEventRepresentationContext context) {
    types = new ArrayList&lt;MyPlugInPropertiesEventType&gt;();
  }

  public boolean acceptsType(PlugInEventTypeHandlerContext context) {
    return true;
  }

  public PlugInEventTypeHandler getTypeHandler(PlugInEventTypeHandlerContext eventTypeContext) {
    String proplist = (String) eventTypeContext.getTypeInitializer();
    String[] propertyList = proplist.split(",");

    Set&lt;String&gt; typeProps = new HashSet&lt;String&gt;(Arrays.asList(propertyList));

    MyPlugInPropertiesEventType eventType = new MyPlugInPropertiesEventType(typeProps);
    types.add(eventType);

    return new MyPlugInPropertiesEventTypeHandler(eventType);
  }
  // ... more methods below
}</pre><p>
					The <tt class="literal">PlugInEventTypeHandler</tt> simply returns the <tt class="literal">EventType</tt> as well as an implementation of <tt class="literal">EventSender</tt> for processing same-type events:
				</p><pre class="programlisting">public class MyPlugInPropertiesEventTypeHandler implements PlugInEventTypeHandler {
  private final MyPlugInPropertiesEventType eventType;

  public MyPlugInPropertiesEventTypeHandler(MyPlugInPropertiesEventType eventType) {
    this.eventType = eventType;
  }

  public EventSender getSender(EPRuntimeEventSender runtimeEventSender) {
    return new MyPlugInPropertiesEventSender(eventType, runtimeEventSender);
  }

  public EventType getType() {
    return eventType;
  }
}</pre><p>
					The <tt class="literal">EventSender</tt> returned by <tt class="literal">PlugInEventTypeHandler</tt> is expected process events of the same type or any subtype:
				</p><pre class="programlisting">public class MyPlugInPropertiesEventSender implements EventSender {
  private final MyPlugInPropertiesEventType type;
  private final EPRuntimeEventSender runtimeSender;

  public MyPlugInPropertiesEventSender(MyPlugInPropertiesEventType type, 
        EPRuntimeEventSender runtimeSender) {
    this.type = type;
    this.runtimeSender = runtimeSender;
  }

  public void sendEvent(Object event) {
    if (!(event instanceof Properties)) {
       throw new EPException("Sender expects a properties event");
    }
    EventBean eventBean = new MyPlugInPropertiesEventBean(type, (Properties) event);
    runtimeSender.processWrappedEvent(eventBean);
  }
}</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="custom-eventrep-example-eventbeanfac"></a>11.5.4.4.&nbsp;Sample Event Bean Factory</h4></div></div><div></div></div><p>
					The plug-in event representation may optionally provide an implementation of <tt class="literal">PlugInEventBeanFactory</tt>. A <tt class="literal">PlugInEventBeanFactory</tt> may inspect event objects and assign an event type dynamically based on resolution URIs and event properties.
				</p><p>
					Our sample event representation accepts all URIs and returns a <tt class="literal">MyPlugInPropertiesBeanFactory</tt>:
				</p><pre class="programlisting">public class MyPlugInEventRepresentation implements PlugInEventRepresentation {

  // ... methods as seen earlier
  public boolean acceptsEventBeanResolution(
        PlugInEventBeanReflectorContext eventBeanContext) {
    return true;
  }

  public PlugInEventBeanFactory getEventBeanFactory(
        PlugInEventBeanReflectorContext eventBeanContext) {
    return new MyPlugInPropertiesBeanFactory(types);
   }
}</pre><p>
			  Last, the sample <tt class="literal">MyPlugInPropertiesBeanFactory</tt> implements the <tt class="literal">PlugInEventBeanFactory</tt> interface. It inspects incoming events and determines
			  an event type based on whether all properties for that event type are present:
			</p><pre class="programlisting">public class MyPlugInPropertiesBeanFactory implements PlugInEventBeanFactory {
  private final List&lt;MyPlugInPropertiesEventType&gt; knownTypes;

  public MyPlugInPropertiesBeanFactory(List&lt;MyPlugInPropertiesEventType&gt; types) {
    knownTypes = types;
  }

  public EventBean create(Object event, URI resolutionURI) {
    Properties properties = (Properties) event;

    // use the known types to determine the type of the object
    for (MyPlugInPropertiesEventType type : knownTypes) {
      // if there is one property the event does not contain, then its not the right type
      boolean hasAllProperties = true;
      for (String prop : type.getPropertyNames()) {
        if (!properties.containsKey(prop)) {
          hasAllProperties = false;
          break;
        }
      }

      if (hasAllProperties) {
        return new MyPlugInPropertiesEventBean(type, properties);
      }
    }
    return null; // none match, unknown event
  }
}</pre></div></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="examples"></a>Chapter&nbsp;12.&nbsp;Examples, Tutorials, Case Studies</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="examples-overview"></a>12.1.&nbsp;Examples Overview</h2></div></div><div></div></div><p>
			This chapter outlines the examples that come with Esper in the <tt class="literal">examples</tt> folder of the distribution. Each sample is in a separate folder that contains all files needed by the example, excluding jar files.
		</p><p>
			Here is an overview over the examples in alphabetical order:
		</p><div class="table"><a name="d0e20061"></a><p class="title"><b>Table&nbsp;12.1.&nbsp;Examples</b></p><table summary="Examples" border="1"><colgroup><col><col></colgroup><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td><a href="#examples-autoid" title="12.3.&nbsp;AutoID RFID Reader">Section&nbsp;12.3, &#8220;AutoID RFID Reader&#8221;</a></td><td><p>
								An array of RFID readers sense RFID tags as pallets are coming within the range of one of the readers.
							</p><p>
								Shows the use of an XSD schema and XML event representation. A single statement shows a rolling time window, a where-clause filter on a nested property and a group-by.
							</p></td></tr><tr><td><a href="#examples-marketdata-monitor" title="12.5.&nbsp;Market Data Feed Monitor">Section&nbsp;12.5, &#8220;Market Data Feed Monitor&#8221;</a></td><td><p>
								Processes a raw market data feed and reports throughput statistics and detects when the data rate of a feed falls off unexpectedly.
							</p><p>
								Demonstrates a batch time window and a rolling time window with a having-clause. Multi-threaded example with a configurable number of threads and a simulator for generating feed data.
							</p></td></tr><tr><td><a href="#examples-matchmaker" title="12.11.&nbsp;MatchMaker">Section&nbsp;12.11, &#8220;MatchMaker&#8221;</a></td><td><p>
								In the MatchMaker example every mobile user has an X and Y location and the task of the event patterns created by this example is to detect mobile users that are within proximity given a certain range, and for which certain properties match preferences.
							</p><p>
								Dynamically creates and removes event patterns that use range matching based on mobile user events received.
							</p></td></tr><tr><td><a href="#examples-namedwindowquery" title="12.12.&nbsp;Named Window Query">Section&nbsp;12.12, &#8220;Named Window Query&#8221;</a></td><td><p>
								A mini-benchmark that handles temperature sensor events. The sample creates a named window and fills it with a large number of events. It then executes a large number of pre-defined queries as well as fire-and-forget queries and reports times.
							</p><p>
								Study this example if you are interested in named windows, Map event type representation, fire-and-forget queries as well as pre-defined queries via on-select, and the performance aspects.
							</p></td></tr><tr><td><a href="#examples-ohlcpluginview" title="12.6.&nbsp;OHLC Plug-in View">Section&nbsp;12.6, &#8220;OHLC Plug-in View&#8221;</a></td><td><p>
								A plug-in custom view addressing a problem in the financial space: Computes open-high-low-close bars for minute-intervals of events that may arrive late, based on each event's timestamp.
							</p><p>
								A custom plug-in view based on the extension API can be a convenient and reusable way to express a domain-specific analysis problem as a unit, and this example includes the code for the OHLC view factory and view as well as simulator to test the view.
							</p></td></tr><tr><td><a href="#performance-kit" title="13.3.&nbsp;Using the performance kit">Section&nbsp;13.3, &#8220;Using the performance kit&#8221;</a></td><td><p>
								A benchmark that is further described in the performance section of this document under performance kit.
							</p></td></tr><tr><td><a href="#examples-qossla" title="12.13.&nbsp;Quality of Service">Section&nbsp;12.13, &#8220;Quality of Service&#8221;</a></td><td><p>
								This example develops some code for measuring quality-of-service levels such as for a service-level agreement (SLA).
							</p><p>
								This example combines patterns with select-statements, shows the use of the timer <tt class="literal">'at'</tt> operator and followed-by operator <tt class="literal">-&gt;</tt>, and uses the iterator API to poll for current results.
							</p></td></tr><tr><td><a href="#examples-assets-moving" title="12.9.&nbsp;Assets Moving Across Zones - An RFID Example">Section&nbsp;12.9, &#8220;Assets Moving Across Zones - An RFID Example&#8221;</a></td><td><p>
								An example out of the RFID domain processes location report events. The example includes a simple Swing-based GUI for visualization allows moving tags from zone to zone visually. It also a contains comprehensive simulator to generate data for a large number of asset groups and their tracking.
							</p><p>
								The example hooks up statements that aggregate and detect patterns in the aggregated data to determine when an asset group constraint is violated.
							</p></td></tr><tr><td><a href="#examples-servershell" title="12.4.&nbsp;JMS Server Shell and Client">Section&nbsp;12.4, &#8220;JMS Server Shell and Client&#8221;</a></td><td><p>
								The server shell is a Java Messaging Service (JMS) -based server and client that send and listens to messages on a JMS destination. It also demonstrates a simple Java Management Extension (JMX) MBean for remote statement management.
							</p><p>
								A single EPL statement computes an average duration for each IP address on a rolling time window and outputs a snapshot every 2 seconds.
							</p></td></tr><tr><td><a href="#examples-stockticker" title="12.10.&nbsp;StockTicker">Section&nbsp;12.10, &#8220;StockTicker&#8221;</a></td><td><p>
								An example from the financial domain that features event patterns to filter stock tick events based on price and symbol. The example is designed to provide a high volume of events and includes multithreaded unit test code as well as a simulting data generator.
							</p><p>
								Perhaps this is a good example to learn the API and get started with event patterns. The example dynamically creates and removes event patterns based on price limit events received.
							</p></td></tr><tr><td><a href="#examples-terminalsvc-J2EE" title="12.8.&nbsp;Self-Service Terminal">Section&nbsp;12.8, &#8220;Self-Service Terminal&#8221;</a></td><td><p>
								A J2EE-based self-service terminal managing system in an airport that gets a lot of events from connected terminals.
							</p><p>
								Contains a message-driven bean (EJB-MDB) for use in a J2EE container, a client and a simulator, as well as EPL statements for detecting various conditions. A version that runs outside of a J2EE container is also available.
							</p></td></tr></tbody></table></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="examples-running"></a>12.2.&nbsp;Running the Examples</h2></div></div><div></div></div><p>
			In order to compile and run the samples please follow the below instructions:
		</p><div class="orderedlist"><ol type="1"><li><p>
                    Make sure Java 1.5 or greater is installed and the JAVA_HOME environment variable is set.
                </p></li><li><p>
                    Open a console window and change directory to examples/<span class="emphasis"><em>example_name</em></span>/etc.
                </p></li><li><p>
                    Run "setenv.bat" (Windows) or "setenv.sh" (Unix) to verify your environment settings.
                </p></li><li><p>
                    Run "compile.bat" (Windows) or "compile.sh" (Unix) to compile an example.
                </p></li><li><p>
                    Now you are ready to run an example. Some examples require mandatory parameters that are also described in the file "readme.txt" in the "etc" folder.
                </p></li><li><p>
                    Modify the logger logging level in the "log4j.xml" configuration file 
                    changing DEBUG to INFO on a class or package level to control the volume of text output. 
                </p></li></ol></div><p>
			Each example also provides Eclipse project <tt class="literal">.classpath</tt> and <tt class="literal">.project</tt> files. The Eclipse projects expect an <tt class="literal">esper_runtime</tt> user library that includes the runtime dependencies.
		</p><p>
			JUnit tests exist for the example code. The JUnit test source code for the examples can be found in each example's <tt class="literal">src/test</tt> folder. To build and run the example JUnit tests, use the Maven 2 goal <tt class="literal">test</tt>.
		</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="examples-autoid"></a>12.3.&nbsp;AutoID RFID Reader</h2></div></div><div></div></div><p>
			In this example an array of RFID readers sense RFID tags as pallets are coming within the range of one of the readers. 
			A reader generates XML documents with observation information such as reader sensor ID, observation time 
			and tags observed. A statement computes the total number of tags per reader sensor ID within the last 60 seconds.
		</p><p>
			This example demonstrates how XML documents unmarshalled to <tt class="literal">org.w3c.dom.Node</tt> DOM document nodes
			can natively be processed by the engine without requiring Java object event representations. The example uses an XPath
			expression for an event property counting the number of tags observed by a sensor. The XML documents follow the AutoID (<tt class="literal">http://www.autoid.org/</tt>) organization
			standard. 
		</p><p>
			The classes for this example can be found in package <tt class="literal">com.espertech.esper.example.autoid</tt>.
			As events are XML documents with no Java object representation, the example does not have event classes.
		</p><p>
			A simulator that can be run from the command line is also available for this example.
			The simulator generates a number of XML documents as specified by a command line argument and
			prints out the totals per sensor.
			Run "run_autoid.bat" (Windows) or "run_autoid.sh" (Unix) to start the AutoID simulator. 
			Please see the readme file in the same folder for build instructions and command line parameters.
		</p><p>
			The code snippet below shows the simple statement to compute the total number of tags per sensor. The statement is created by class 
			<tt class="literal">com.espertech.esper.example.autoid.RFIDTagsPerSensorStmt</tt>.
		</p><pre class="programlisting">select ID as sensorId, sum(countTags) as numTagsPerSensor
from AutoIdRFIDExample.win:time(60 seconds)
where Observation[0].Command = 'READ_PALLET_TAGS_ONLY'
group by ID</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="examples-servershell"></a>12.4.&nbsp;JMS Server Shell and Client</h2></div></div><div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="examples-servershell-processes"></a>12.4.1.&nbsp;Overview</h3></div></div><div></div></div><p>
				The server shell is a Java Messaging Service (JMS) -based server that listens to messages on a JMS destination, and sends the received events into Esper. The example also demonstrates a Java Management Extension (JMX) MBean that allows remote dynamic statement management. This server has been designed to run with either Tibco (TM) Enterprise Messaging System (Tibco EMS), or with Apache ActiveMQ, controlled by a properties file.			
			</p><p>
				The server shell has been created as an alternative to the EsperIO Spring JMSTemplate adapter.  The server shell is a low-latency processor for byte messages. It employs JMS listeners to process message in multiple threads, this model reduces thread context switching for many JMS providers. The server is configurable and has been tested with two JMS providers. It consists of only 10 classes and is thus easy to understand.
			</p><p>
				The server shell sample comes with a client (server shell client) that sends events into the JMS-based server, and that also creates a statement on the server remotely through a JMX MBean proxy class.
			</p><p>
				The server shell classes for this example live in package <tt class="literal">com.espertech.esper.example.servershell</tt>. 
				Configure the server to point to your JMS provider by changing the properties in the file <tt class="literal">servershell_config.properties</tt> in the <tt class="literal">etc</tt> folder.
				Make sure your JMS provider (ActiveMQ or Tibco EMS) is running, then run "run_servershell.bat" (Windows) or "run_servershell.sh" (Unix) to start the JMS server. 
			</p><p>
				Start the server shell process first before starting the client, since the client also demonstrates remote statement management through JMX by attaching to the server process.
			</p><p>		
				The client classes to the server shell can be found in package <tt class="literal">com.espertech.esper.example.servershellclient</tt>. 
				The client shares the same configuration file as the server shell.
				Run "run_servershellclient.bat" (Windows) or "run_servershellclient.sh" (Unix) to start the JMS producer client  that includes a JMX client as well. 
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="examples-servershell-jmsevents"></a>12.4.2.&nbsp;JMS Messages as Events</h3></div></div><div></div></div><p>
				The server shell starts a configurable number of JMS <tt class="literal">MessageListener</tt> instances that listen to a given JMS destination. The listeners expect a <tt class="literal">BytesMessage</tt> that contain a String payload. The payload consists of an IP address and a double-typed duration value separated by a comma.
			</p><p>
				Each listener extracts the payload of a message, constructs an event object and sends the event into the shared Esper engine instance. 
			</p><p>
				At startup time, the server creates a single EPL statement with the Esper engine that prints out the average duration per IP address for the last 10 seconds of events, and that specifies an output rate of 2 seconds. By running the server and then the client, you can see the output of the averages every 2 seconds.
			</p><p>
				The server shell client acts as a JMS producer that sends 1000 events with random IP addresses and durations.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="examples-servershell-jmx"></a>12.4.3.&nbsp;JMX for Remote Dynamic Statement Management</h3></div></div><div></div></div><p>
				The server shell is also a JMX server providing an RMI-based connector. The server shell exposes a JMX MBean that allows remote statement management. The JMX MBean allows to create a statement remotely, attach a listener to the statement and destroy a statement remotely. 
			</p><p>
				The server shell client, upon startup, obtains a remote instance of the management MBean exposed by the server shell. It creates a statement through the MBean that filters out all durations greater then the value 9.9. 
				After sending 1000 events, the client then destroys the statement remotely on the server.
			</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="examples-marketdata-monitor"></a>12.5.&nbsp;Market Data Feed Monitor</h2></div></div><div></div></div><p>
			This example processes a raw market data feed. It reports throughput statistics and 
			detects when the data rate of a feed falls off unexpectedly. A rate fall-off may mean that the data is stale and 
			we want to alert when there is a possible problem with the feed.
		</p><p>
			The classes for this example live in package <tt class="literal">com.espertech.esper.example.marketdatafeed</tt>. 
			Run "run_mktdatafeed.bat" (Windows) or "run_mktdatafeed.sh" (Unix) in the <tt class="literal">examples/etc</tt> folder 
			to start the market data feed simulator. 			
		</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="examples-marketdata-monitor-input"></a>12.5.1.&nbsp;Input Events</h3></div></div><div></div></div><p>
				The input stream consists of 1 event stream that contains 2 simulated market data feeds. Each individual event in the stream 
				indicates the feed that supplies the market data, the security symbol and some pricing information:
			</p><pre class="programlisting">String symbol;
FeedEnum feed;
double bidPrice;
double askPrice;
</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="examples-marketdata-computing"></a>12.5.2.&nbsp;Computing Rates Per Feed</h3></div></div><div></div></div><p>
				For the throughput statistics and to detect rapid fall-off we calculate a ticks per second rate for each market data feed. 
			</p><p>
				We can use an EPL statement that specifies a view onto the market data event stream that batches together 1 second of events. 
				We specify the feed and a count of events per feed as output values. To make this data available for further processing, we
				insert output events into the TicksPerSecond event stream:
			</p><pre class="programlisting">insert into TicksPerSecond
select feed, count(*) as cnt 
  from MarketDataEvent.win:time_batch(1 second) 
 group by feed</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="examples-marketdata-falloff"></a>12.5.3.&nbsp;Detecting a Fall-off</h3></div></div><div></div></div><p>
				We define a rapid fall-off by alerting when the number of ticks per second for any second falls below 75% of the 
				average number of ticks per second over the last 10 seconds. 
			</p><p>
				We can compute the average number of ticks per second over the last 10 seconds simply by using the TicksPerSecond events computed by the
				prior statement and averaging the last 10 seconds. Next, we compare the current rate with the moving average and
				filter out any rates that fall below 75% of the average:
			</p><pre class="programlisting">select feed, avg(cnt) as avgCnt, cnt as feedCnt 
  from TicksPerSecond.win:time(10 seconds)
 group by feed 
having cnt &lt; avg(cnt) * 0.75</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="examples-marketdata-monitor-sim"></a>12.5.4.&nbsp;Event generator</h3></div></div><div></div></div><p>
				The simulator generates market data events for 2 feeds, feed A and feed B. 
				The first parameter to the simulator is a number of threads. Each thread sends events for each feed in an endless loop.
				Note that as the Java VM garbage collection kicks in, the example generates rate drop-offs during such pauses.
			</p><p>
				The second parameter is a rate drop probability parameter specifies the probability in percent that the simulator drops the rate 
				for a randomly chosen feed to 60% of the target rate for that second. Thus rate fall-off alerts can be generated.
			</p><p>
				The third parameter defines the number of seconds to run the example.
			</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="examples-ohlcpluginview"></a>12.6.&nbsp;OHLC Plug-in View</h2></div></div><div></div></div><p>
			This example contains a fully-functional custom view based on the extension API that computes OHLC open-high-low-close bars for events that provide a long-typed timestamp and a double-typed value.
        </p><p>
			OHLC bar is a problem out of the financial domain. The "Open" refers to the first datapoint and the "Close" to the last datapoint in an interval. The "High" refers to the maximum and the "Low" to the minimum value during each interval. The term "bar" is used to describe each interval results of these 4 values.
        </p><p>
			The example provides an OHLC view that is hardcoded to 1-minute bars. It considers the timestamp value carried by each event, and not the system time. The cutoff time after which an event is no longer considered for a bar is hardcoded to 5 seconds.
        </p><p>
			The view assumes that events arrive in timestamp order: Each event's timestamp value is equal to or higher then the timestamp value provided by the prior event.
        </p><p>
			The view may also be used together with <tt class="literal">std:groupby</tt> to group per criteria, such as symbol. In this case the assumption of timestamp order applies per symbol.
        </p><p>
			The view gracefully handles no-event and late-event scenarios. Interval boundaries are defined by system time, thus event timestamp and system time must roughly be in-sync, unless using external timer events.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="examples-transaction-3-event-challenge"></a>12.7.&nbsp;Transaction 3-Event Challenge</h2></div></div><div></div></div><p>
			The classes for this example live in package <tt class="literal">com.espertech.esper.example.transaction</tt>. 
			Run "run_txnsim.bat" (Windows) or "run_txnsim.sh" (Unix) to start the transaction simulator. 
			Please see the readme file in the same folder for build instructions and command line parameters.
		</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="examples-txn3event-1"></a>12.7.1.&nbsp;The Events</h3></div></div><div></div></div><p>
	The use case involves tracking three components of a transaction. It&#8216;s important that we use at least three components, since some engines have different performance or coding for only two events per transaction. Each component comes to the engine as an event with the following fields:
			</p><div class="itemizedlist"><ul type="disc" compact><li><p>
						Transaction ID
					</p></li><li><p>
						Time stamp
					</p></li></ul></div><p>
				In addition, we have the following extra fields:
			</p><p>
				In event A:
			</p><div class="itemizedlist"><ul type="disc" compact><li><p>
						Customer ID
					</p></li></ul></div><p>
				In event C:
			</p><div class="itemizedlist"><ul type="disc" compact><li><p>
						Supplier ID (the ID of the supplier that the order was filled through)
					</p></li></ul></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="examples-txn3event-2"></a>12.7.2.&nbsp;Combined event</h3></div></div><div></div></div><p>
					We need to take in events A, B and C and produce a single, combined event with the following fields:
			</p><div class="itemizedlist"><ul type="disc" compact><li><p>
						Transaction ID
					</p></li><li><p>
						Customer ID
					</p></li><li><p>
						Time stamp from event A
					</p></li><li><p>
						Time stamp from event B
					</p></li><li><p>
						Time stamp from event C
					</p></li></ul></div><p>
What we&#8216;re doing here is matching the transaction IDs on each event, to form an aggregate event. If all these events were in a relational database, this could be done as a simple SQL join&#8230; except that with 10,000 events per second, you will need some serious database hardware to do it.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="examples-txn3event-3"></a>12.7.3.&nbsp;Real time summary data</h3></div></div><div></div></div><p>
Further, we need to produce the following:
			</p><div class="itemizedlist"><ul type="disc" compact><li><p>
						Min,Max,Average total latency from the events (difference in time between A and C) over the past 30 minutes.
					</p></li><li><p>
						Min,Max,Average latency grouped by (a) customer ID and (b) supplier ID. In other words, metrics on the the latency of the orders coming from each customer and going to each supplier.
					</p></li><li><p>
						Min,Max,Average latency between events A/B (time stamp of B minus A) and B/C (time stamp of C minus B).
					</p></li></ul></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="examples-txn3event-4"></a>12.7.4.&nbsp;Find problems</h3></div></div><div></div></div><p>
We need to detect a transaction that did not make it through all three events. In other words, a transaction with events A or B, but not C. Note that, in this case, what we care about is event C. The lack of events A or B could indicate a failure in the event transport and should be ignored. Although the lack of an event C could also be a transport failure, it merits looking into.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="examples-txn3event-5"></a>12.7.5.&nbsp;Event generator</h3></div></div><div></div></div><p>
To make testing easier, standard and to demonstrate how the example works, the example is including an event generator. The generator generates events for a given number of transactions, using the following rules:
			</p><div class="itemizedlist"><ul type="disc" compact><li><p>
						One in 5,000 transactions will skip event A
					</p></li><li><p>
						One in 1,000 transactions will skip event B
					</p></li><li><p>
						One in 10,000 transactions will skip event C.
					</p></li><li><p>
						Transaction identifiers are randomly generated
					</p></li><li><p>
						Customer and supplier identifiers are randomly chosen from two lists
					</p></li><li><p>
						The time stamp on each event is based on the system time. Between events A and B as well as B and C, between 0 and 999 is added to the time. So, we have an expected time difference of around 500 milliseconds between each event
					</p></li><li><p>
						Events are randomly shuffled as described below
					</p></li></ul></div><p>
	To make things harder, we don&#8216;t want transaction events coming in order. This code ensures that they come completely out of order. To do this, we fill in a bucket with events and, when the bucket is full, we shuffle it. The buckets are sized so that some transactions&#8216; events will be split between buckets. So, you have a fairly randomized flow of events, representing the worst case from a big, distributed infrastructure.
				</p><p>
	The generator lets you change the size of the bucket (small, medium, large, larger, largerer). The larger the bucket size, the more events potentially come in between two events in a given transaction and so, the more the performance characteristics like buffers, hashes/indexes and other structures are put to the test as the bucket size increases.
				</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="examples-terminalsvc-J2EE"></a>12.8.&nbsp;Self-Service Terminal</h2></div></div><div></div></div><p>
			The example is about a J2EE-based self-service terminal managing system in an airport that gets a lot of events from connected terminals. The event rate is around 500 events per second. Some events indicate abnormal situations such as 'paper low' or 'terminal out of order'. Other events observe activity as customers use a terminal to check in and print boarding tickets.
		</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="examples-terminalsvc-events"></a>12.8.1.&nbsp;Events</h3></div></div><div></div></div><p>
				Each self-service terminal can publish any of the 6 events below.
			</p><div class="itemizedlist"><ul type="disc" compact><li><p>
						Checkin - Indicates a customer started a check-in dialog
					</p></li><li><p>
						Cancelled - Indicates a customer cancelled a check-in dialog
					</p></li><li><p>
						Completed	- Indicates a customer completed a check-in dialog
					</p></li><li><p>
						OutOfOrder - Indicates the terminal detected a hardware problem
					</p></li><li><p>
						LowPaper	- Indicates the terminal is low on paper
					</p></li><li><p>
						Status - Indicates terminal status, published every 1 minute regardless of activity as a terminal heartbeat
					</p></li></ul></div><p>
				All events provide information about the terminal that published the event, and a timestamp. The terminal information is held in a property named "term" and provides a terminal id. Since all events carry similar information, we model each event as a subtype to a base class BaseTerminalEvent, which will provide the terminal information that all events share. This enables us to treat all terminal events polymorphically, that is we can treat derived event types just like their parent event types. This helps simplify our queries.
			</p><p>
				All terminals publish Status events every 1 minute. In normal cases, the Status events indicate that a terminal is alive and online. The absence of status events may indicate that a terminal went offline for some reason and that may need to be investigated.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="examples-terminalsvc-pattern1"></a>12.8.2.&nbsp;Detecting Customer Check-in Issues</h3></div></div><div></div></div><p>
				A customer may be in the middle of a check-in when the terminal detects a hardware problem or when the network goes down. In that situation we want to alert a team member to help the customer. When the terminal detects a problem, it issues an OutOfOrder event. A pattern can find situations where the terminal indicates out-of-order and the customer is in the middle of the check-in process:
			</p><pre class="programlisting">select * from pattern [ every a=Checkin -&gt; 
      ( OutOfOrder(term.id=a.term.id) and not 
          (Cancelled(term.id=a.term.id) or Completed(term.id=a.term.id)) )]</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="examples-terminalsvc-pattern2"></a>12.8.3.&nbsp;Absence of Status Events</h3></div></div><div></div></div><p>
				Since Status events arrive in regular intervals of 60 seconds, we can make us of temporal pattern matching using timer to find events that didn't arrive. We can use the every operator and timer:interval() to repeat an action every 60 seconds. Then we combine this with a not operator to check for absence of Status events. A 65 second interval during which we look for Status events allows 5 seconds to account for a possible delay in transmission or processing:
			</p><pre class="programlisting">select 'terminal 1 is offline' from pattern 
  [every timer:interval(60 sec) -&gt; (timer:interval(65 sec) and not Status(term.id = 'T1'))]
output first every 5 minutes</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="examples-terminalsvc-epl1"></a>12.8.4.&nbsp;Activity Summary Data</h3></div></div><div></div></div><p>
				By presenting statistical information about terminal activity to our staff in real-time we enable them to monitor the system and spot problems. The next example query simply gives us a count per event type every 1 minute. We could further use this data, available through the CountPerType event stream, to join and compare against a recorded usage pattern, or to just summarize activity in real-time.
			</p><pre class="programlisting">insert into CountPerType
select type, count(*) as countPerType 
from BaseTerminalEvent.win:time(10 minutes) 
group by type
output all every 1 minutes</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="examples-terminalsvc-j2ee"></a>12.8.5.&nbsp;Sample Application for J2EE Application Server</h3></div></div><div></div></div><p>
				The example code in the distribution package implements a message-driven enterprise java bean (MDB EJB). We used an MDB as a convenient place for processing incoming events via a JMS message queue or topic. The example uses 2 JMS queues: One queue to receive events published by terminals, and a second queue to indicate situations detected via EPL statement and listener back to a receiving process.
			</p><p>
				This example has been packaged for deployment into a JBoss Java application server (see http://www.jboss.org) with default deployment configuration. JBoss is an open-source application server available under LGPL license. Of course the choice of application server does not indicate a requirement or preference for the use of Esper in a J2EE container. Other quality J2EE application servers are available and perhaps more suitable to run this example or a similar application.
			</p><p>
				The complete example code can be found in the "examples/terminalsvc" folder of the distribution. The standalone version that does not require a J2EE container is in "examples/terminalsvc-jse".
			</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="examples-terminalsvc-j2ee-running"></a>12.8.5.1.&nbsp;Running the Example</h4></div></div><div></div></div><p>
					The pre-build EAR file contains the MDB for deployment to a JBoss application server with default deployment options. The JBoss default configuration provides 2 queues that this example utilizes: queue/A and queue/B. The queue/B is used to send events into the MDB, while queue/A is used to indicate back the any data received by listeners to EPL statements.
				</p><p>
					The application can be deployed by copying the ear file in the "examples/terminalsvc/terminalsvc-ear" folder to your JBoss deployment directory located under the JBoss home directory under "server/default/deploy".
				</p><p>
					The example contains an event simulator and an event receiver that can be invoked from the command line. See the folder "examples/terminalsvc/etc" folder readme file and start scripts for Windows and Unix, and the documentation set for further information on the simulator.
				</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="examples-terminalsvc-j2ee-building"></a>12.8.5.2.&nbsp;Building the Example</h4></div></div><div></div></div><p>
					This example requires Maven 2 to build. To build the example, change directory to the folder "examples/terminalsvc" and type "mvn package". The instructions have been tested with JBoss AS 4.0.4.GA and Maven 2.0.4.
				</p><p>
					The Maven build packages the EAR file for deployment to a JBoss application server with default deployment options.
				</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="examples-terminalsvc-j2ee-running-sim"></a>12.8.5.3.&nbsp;Running the Event Simulator and Receiver</h4></div></div><div></div></div><p>
						The example also contains an event simulator that generates meaningful events. The simulator can be run from the directory "examples/terminalsvc/etc" via the command "run_terminalsvc_sender.bat" (Windows) and "run_terminalsvc_sender.sh" (Linux). The event simulator generates a batch of at least 200 events every 1 second. Randomly, with a chance of 1 in 10 for each batch of events, the simulator generates either an OutOfOrder or a LowPaper event for a random terminal. Each batch the simulator generates 100 random terminal ids and generates a Checkin event for each. It then generates either a Cancelled or a Completed event for each. With a chance of 1 in 1000, it generates an OutOfOrder event instead of the Cancelled or Completed event for a terminal.
					</p><p>
						The event receiver listens to the MDB-outcoming queue for alerts and prints these out to console. The receiver can be run from the directory "examples/terminalsvc/etc" via the command "run_terminalsvc_receiver.bat" (Windows) and "run_terminalsvc_receiver.sh" (Linux). 
					</p></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="examples-assets-moving"></a>12.9.&nbsp;Assets Moving Across Zones - An RFID Example</h2></div></div><div></div></div><p>
			This example out of the RFID domain processes location report events. Each location report event indicates an asset id and the current zone of the asset. 
			The example solves the problem that when a given set of assets is not moving together from zone to zone, then an alert must be fired.
		</p><p>
			Each asset group is tracked by 2 statements. The two statements to track a single asset group consisting of assets identified by asset ids {1, 2, 3} are as follows:
		</p><pre class="programlisting">insert into CountZone_G1
select 1 as groupId, zone, count(*) as cnt
from LocationReport(assetId in 1, 2, 3).std:unique(assetId)
group by zone

select Part.zone from pattern [
  every Part=CountZone_G1(cnt in (1,2)) -&gt;
    (timer:interval(10 sec)  and not CountZone_G1(zone=Part.zone, cnt in (0,3)))]</pre><p>
			The classes for this example can be found in package <tt class="literal">com.espertech.esper.example.rfid</tt>.
		</p><p>
			This example provides a Swing-based GUI that can be run from the command line.
			The GUI allows drag-and-drop of three RFID tags that form one asset group from zone to zone. Each time you move an asset across the screen the example sends an
			event into the engine indicating the asset id and current zone. The example detects if within 10 seconds the three assets do not join each other
			within the same zone, but stay split across zones.
			Run "run_rfid_swing.bat" (Windows) or "run_rfid_swing.sh" (Unix) to start the example's Swing GUI. 
		</p><p>
			The example also provides a simulator that can be run from the command line.
			The simulator generates a number of asset groups as specified by a command line argument and starts a number of threads as specified by a command line argument
			to send location report events into the engine.
			Run "run_rfid_sim.bat" (Windows) or "run_rfid_sim.sh" (Unix) to start the RFID location report event simulator. 
			Please see the readme file in the same folder for build instructions and command line parameters.
		</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="examples-stockticker"></a>12.10.&nbsp;StockTicker</h2></div></div><div></div></div><p>
			 The StockTicker example comes from the stock trading domain. The example creates event patterns to filter stock tick events based on price and symbol. 
			 When a stock tick event is encountered that falls outside the lower or upper price limit, the example simply displays that stock tick event.
			 The price range itself is dynamically created and changed. This is accomplished by an event patterns that searches for another event class, the price limit event.			 			 
		</p><p>
			The classes <tt class="literal">com.espertech.esper.example.stockticker.event.StockTick</tt> and <tt class="literal">PriceLimit</tt> represent our events. The event patterns are created by the class <tt class="literal">com.espertech.esper.example.stockticker.monitor.StockTickerMonitor</tt>. 
		</p><p>
			Summary:
		</p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    Good example to learn the API and get started with event patterns
                </p></li><li><p>
                    Dynamically creates and removes event patterns based on price limit events received
                </p></li><li><p>
                    Simple, highly-performant filter expressions for event properties in the stock tick event such as symbol and price
                </p></li></ul></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="examples-matchmaker"></a>12.11.&nbsp;MatchMaker</h2></div></div><div></div></div><p>
			 In the MatchMaker example every mobile user has an X and Y location, a set of properties (gender, hair color, age range) and a set of preferences (one for each property) to match. The task of the event patterns created by this example is to detect mobile users that are within proximity given a certain range, and for which the properties match preferences.
		</p><p>
			The event class representing mobile users is <tt class="literal">com.espertech.esper.example.matchmaker.event.MobileUserBean</tt>. The <tt class="literal">com.espertech.esper.example.matchmaker.monitor.MatchMakingMonitor</tt> class contains the patterns for detecing matches.
		</p><p>
			Summary:
		</p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    Dynamically creates and removes event patterns based on mobile user events received
                </p></li><li><p>
                    Uses range matching for X and Y properties of mobile user events
                </p></li></ul></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="examples-namedwindowquery"></a>12.12.&nbsp;Named Window Query</h2></div></div><div></div></div><p>
			This example handles very minimal temperature sensor events which are represented by <tt class="literal">java.util.Map</tt>. It creates a named window and fills it with a large number of events. It then executes a large number of pre-defined queries via on-select as well as performs a large number of fire-and-forget queries against the named window, and reports execution times.
		</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="examples-qossla"></a>12.13.&nbsp;Quality of Service</h2></div></div><div></div></div><p>
            This example develops some code for measuring quality-of-service levels such as for a service-level agreement (SLA).
            A SLA is a contract between 2 parties that defines service constraints such as maximum latency for service operations or error rates.
        </p><p>                      
            The example measures and monitors operation latency and error counts per customer and operation. When 
            one of our operations oversteps these constraints, we want to be alerted right away. Additionally, we would like to have some monitoring in
            place that checks the health of our service and provides some information on how the operations are used.
        </p><p>                      
            Some of the constraints we need to check are:
         </p><div class="itemizedlist"><ul type="disc" compact><li><p>
					That the latency (time to finish) of some of the operations is always less then X seconds.
				</p></li><li><p>
					That the latency average is always less then Y seconds over Z operation invocations. 
				</p></li></ul></div><p>
			The <tt class="literal">com.espertech.esper.example.qos_sla.events.OperationMeasurement</tt> event class with its latency and status properties is the main event used for the SLA analysis. The other event <tt class="literal">LatencyLimit</tt> serves to set latency limits on the fly.
		</p><p>
			The <tt class="literal">com.espertech.esper.example.qos_sla.monitor.AverageLatencyMonitor</tt> creates an EPL statement that computes latency statistics per customer and operation for the
			last 100 events. The <tt class="literal">DynaLatencySpikeMonitor</tt> uses an event pattern to listen to spikes in latency with dynamically set limits. The <tt class="literal">ErrorRateMonitor</tt> uses the timer <tt class="literal">'at'</tt> operator in an event pattern that wakes up periodically and polls the error rate within the last 10 minutes. The <tt class="literal">ServiceHealthMonitor</tt> simply alerts when 3 errors occur, and the <tt class="literal">SpikeAndErrorMonitor</tt> alerts when a fixed latency is overstepped or an error status is reported.
		</p><p>
			Summary:
		</p><div class="itemizedlist"><ul type="disc" compact><li><p>
                    This example combines event patterns with EPL statements for event stream analysis.
                </p></li><li><p>
                    Shows the use of the timer <tt class="literal">'at'</tt> operator and followed-by operator <tt class="literal">-&gt;</tt> in event patterns.
                </p></li><li><p>
                    Outlines basic EPL statements.
                </p></li><li><p>
                    Shows how to pull data out of EPL statements rather then subscribing to events a statement publishes.
                </p></li></ul></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="performance"></a>Chapter&nbsp;13.&nbsp;Performance</h2></div></div><div></div></div><p>
        Esper has been highly optimized to handle very high throughput streams with very little latency between event receipt and output result posting.
        It is also possible to use Esper on a soft-real-time or hard-real-time JVM to maximize predictability even
        further.
    </p><p>
        This section describes performance best practices and explains how to assess Esper performance by using our
        provided performance kit.
    </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="performance-results"></a>13.1.&nbsp;Performance Results</h2></div></div><div></div></div><p>
            For a complete understanding of those results, consult the next sections.
        </p><p>
            </p><pre class="programlisting">Esper exceeds over 500 000 event/s on a dual CPU 2GHz Intel based hardware,
with engine latency below 3 microseconds average (below 10us with more than 
99% predictability) on a VWAP benchmark with 1000 statements registered in the system 
- this tops at 70 Mbit/s at 85% CPU usage.

Esper also demonstrates linear scalability from 100 000 to 500 000 event/s on this 
hardware, with consistent results accross different statements.

Other tests demonstrate equivalent performance results
(straight through processing, match all, match none, no statement registered,
VWAP with time based window or length based windows).
                
Tests on a laptop demonstrated about 5x time less performance - that is 
between 70 000 event/s and 200 000 event/s - which still gives room for easy 
testing on small configuration.</pre><p>
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="performance-tips"></a>13.2.&nbsp;Performance Tips</h2></div></div><div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="perf-tips-1"></a>13.2.1.&nbsp;Understand how to tune your Java virtual machine</h3></div></div><div></div></div><p>
				Esper runs on a JVM and you need to be familiar with JVM tuning.
				Key parameters to consider include minimum and maximum heap memory and nursery heap sizes.
				Statements with time-based or length-based data windows can consume large amounts of memory as their size or length can be large.
			</p><p>
				For time-based data windows, one needs to be aware that the memory consumed depends on the actual event stream input
				throughput. Event pattern instances also consume memory, especially when using the "every"
				keyword in patterns to repeat pattern sub-expressions - which again will depend on the actual event stream input throughput.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="perf-tips-2"></a>13.2.2.&nbsp;Compare Esper to other solutions</h3></div></div><div></div></div><p>
				If you compare Esper performance to the performance of another solution, you need to ensure that your statements have
				truly equivalent semantics. The is because between different vendors the event processing language can be seem fairly similar 
				whoever may, for all similarities, produce different results.
			</p><p>
				For example some vendor solution mandates the use of "bounded streams". The next statement shows one vendor's event processing syntax:
			</p><pre class="programlisting">// Other (name omitted) vendor solution statement:
select * from (select * from Market where ticker = 'GOOG') retain 1 event
// The above is NOT an Esper statement</pre><p>
				The semantically equivalent statement in Esper is:
			</p><pre class="programlisting">// Esper statement with the same semantics:
select * from MarketData(ticker='$').win:length(1)</pre><p>
				As an example, a NOT semantically equivalent statement in Esper is:
			</p><pre class="programlisting">// Esper statement that DOES ***NOT*** HAVE the same semantics 
// No length window was used
select * from MarketData(ticker='$')</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="perf-tips-3"></a>13.2.3.&nbsp;Input and Output Bottlenecks</h3></div></div><div></div></div><p>
				Your application receives output events from Esper statements through the <tt class="literal">UpdateListener</tt> interface or via the strongly-typed subscriber POJO object. Such output events are delivered by the application or timer thread(s) that sends an input event into the engine instance.
			</p><p>
				The processing of output events that your listener or subscriber performs temporarily blocks the thread until the processing completes, and may thus reduce throughput. It can therefore be beneficial for your application to process output events asynchronously and not block the Esper engine while an output event is being processed by your listener, especially if your listener code performs blocking IO operations.
			</p><p>
				For example, your application may want to send output events to a JMS destination or write output event data to a relational database. For optimal throughput, consider performing such blocking operations in a separate thread.
			</p><p>
				Additionally, when reading input events from a store or network in a performance test, you may find that Esper processes events faster then you are able to feed events into Esper. In such case you may want to consider an in-memory driver for use in performance testing. Also consider decoupling your read operation from the event processing operation (sendEvent method) by having multiple readers or by pre-fetching your data from the store.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="perf-tips-3-a"></a>13.2.4.&nbsp;Advanced Theading</h3></div></div><div></div></div><p>
				Esper provides the configuration option to use engine-level queues and threadpools for inbound, outbound and internal executions. See <a href="#api-threading-advanced" title="9.6.1.&nbsp;Advanced Threading">Section&nbsp;9.6.1, &#8220;Advanced Threading&#8221;</a> for more information.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="perf-tips-4"></a>13.2.5.&nbsp;Select the underlying event rather than individual fields</h3></div></div><div></div></div><p>
				By selecting the underlying event in the select-clause we can reduce load on the engine, since the 
				engine does not need to generate a new output event for each input event.
			</p><p>
				For example, the following statement returns the underlying event to update listeners:
			</p><pre class="programlisting">// Better performance
select * from RFIDEvent</pre><p>
				In comparison, the next statement selects individual properties. This statement requires the engine to generate an output event that 
				contains exactly the required properties:
			</p><pre class="programlisting">// Less good performance
select assetId, zone, xlocation, ylocation from RFIDEvent </pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="perf-tips-5"></a>13.2.6.&nbsp;Prefer stream-level filtering over post-data-window filtering</h3></div></div><div></div></div><p>
				Esper stream-level filtering is very well optimized, while filtering via the where-clause post any data windows is not optimized. 
				In very simple statements that don't have data windows this distinction can make a performance difference.
			</p><p>
				Consider the example below, which performs stream-level filtering:
			</p><pre class="programlisting">// Better performance : stream-level filtering
select * from MarketData(ticker = 'GOOG')</pre><p>
				The example below is the equivalent (same semantics) statement and performs post-data-window filtering without a data window.
				The engine does not optimize statements that filter in the where-clause for the reason that data window views are generally present.
			</p><pre class="programlisting">// Less good performance : post-data-window filtering
select * from Market where ticker = 'GOOG'</pre><p>
				Thus this optimization technique applies to statements without any data window. 
			</p><p>
				When a data window is used, the semantics change. Let's look at an example to better understand the difference:
				In the next statement only GOOG market events enter the length window:
			</p><pre class="programlisting">select avg(price) from MarketData(ticker = 'GOOG').win:length(100)</pre><p>
				The above statement computes the average price of GOOG market data events for the last 100 GOOG market data events. 
			</p><p>
				Compare the filter position to a filter in the where clause. 
				The following statement is NOT equivalent as all events enter the data window (not just GOOG events):
			</p><pre class="programlisting">select avg(price) from Market.win:length(100) where ticker = 'GOOG'</pre><p>
				The statement above computes the average price of all market data events for the last 100 market data events, and outputs results only for GOOG.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="perf-tips-6"></a>13.2.7.&nbsp;Reduce the use of arithmetic in expressions</h3></div></div><div></div></div><p>
				Esper does not yet attempt to pre-evaluate arithmetic expressions that produce constant results.
			</p><p>
				Therefore, a filter expression as below is optimized:
			</p><pre class="programlisting">// Better performance : no arithmetic
select * from MarketData(price&gt;40) </pre><p>
				While the engine cannot currently optimize this expression:
			</p><pre class="programlisting">// Less good performance : with arithmetic
select * from MarketData(price+10&gt;50) </pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="perf-tips-7"></a>13.2.8.&nbsp;Consider using EventPropertyGetter for fast access to event properties</h3></div></div><div></div></div><p>
				The EventPropertyGetter interface is useful for obtaining an event property value without property name table lookup 
				given an EventBean instance that is of the same event type that the property getter was obtained from.
			</p><p>
				When compiling a statement, the EPStatement instance lets us know the EventType via the getEventType() method.
				From the EventType we can obtain EventPropertyGetter instances for named event properties.
			</p><p>
				To demonstrate, consider the following simple statement:
			</p><pre class="programlisting">select symbol, avg(price) from Market group by symbol</pre><p>
				After compiling the statement, obtain the EventType and pass the type to the listener:
			</p><pre class="programlisting">EPStatement stmt = epService.getEPAdministrator().createEPL(stmtText);
MyGetterUpdateListener listener = new MyGetterUpdateListener(stmt.getEventType());</pre><p>
				The listener can use the type to obtain fast getters for property values of events for the same type:
			</p><pre class="programlisting">public class MyGetterUpdateListener implements StatementAwareUpdateListener {
    private final EventPropertyGetter symbolGetter;
    private final EventPropertyGetter avgPriceGetter;

    public MyGetterUpdateListener(EventType eventType) {
        symbolGetter = eventType.getGetter("symbol");
        avgPriceGetter = eventType.getGetter("avg(price)");
    }</pre><p>
				Last, the update method can invoke the getters to obtain event property values:
			</p><pre class="programlisting">    public void update(EventBean[] eventBeans, EventBean[] oldBeans, EPStatement epStatement, EPServiceProvider epServiceProvider) {
        String symbol = (String) symbolGetter.get(eventBeans[0]);
        long volume = (Long) volumeGetter.get(eventBeans[0]);
        // some more logic here
    }</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="perf-tips-8"></a>13.2.9.&nbsp;Consider casting the underlying event</h3></div></div><div></div></div><p>
				When an application requires the value of most or all event properties, it can often be best to simply select the underlying event via wildcard
				and cast the received events.
			</p><p>
				Let's look at the sample statement:
			</p><pre class="programlisting">select * from MarketData(symbol regexp 'E[a-z]')</pre><p>
				An update listener to the statement may want to cast the received events to the expected underlying event class:
			</p><pre class="programlisting">    public void update(EventBean[] eventBeans, EventBean[] eventBeans) {
        MarketData md = (MarketData) eventBeans[0].getUnderlying();
        // some more logic here
    }</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="perf-tips-9"></a>13.2.10.&nbsp;Turn off logging</h3></div></div><div></div></div><p>
	Since Esper 1.10, even if you don't have a log4j configuration file in place, Esper will make sure to minimize execution path logging overhead.
	For prior versions, and to reduce logging overhead overall, we recommend the "WARN" log level or the "INFO" log level.
			</p><p>
	Please see the log4j configuration file in "etc/infoonly_log4j.xml" for example log4j settings.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="perf-tips-10"></a>13.2.11.&nbsp;Disable view sharing</h3></div></div><div></div></div><p>
				By default, Esper compares streams and views in use with existing statement's streams and views, and then reuses views to efficiently share resources between statements. The benefit is reduced resources usage, however the potential cost is that in multithreaded applications a shared view may mean excessive locking of multiple processing threads.
			</p><p>
				Consider disabling view sharing for better threading performance if your application overall uses fewer statements and statements have very similar streams, filters and views. 
			</p><p>
				View sharing can be disabled via XML configuration or API, and the next code snippet shows how, using the API:
			</p><pre class="programlisting">Configuration config = new Configuration();
config.getEngineDefaults().getViewResources().setShareViews(false);</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="perf-tips-11"></a>13.2.12.&nbsp;Tune or disable delivery order guarantees</h3></div></div><div></div></div><p>
				If your application is not a multithreaded application, or you application is not sensitive to the order of delivery of result events to your application listeners, then consider disabling the delivery order guarantees the engine makes towards ordered delivery of results to listeners:
			</p><pre class="programlisting">Configuration config = new Configuration();
config.getEngineDefaults().getThreading().setListenerDispatchPreserveOrder(false);</pre><p>
				If your application is not a multithreaded application, or your application uses the <tt class="literal">insert into</tt> clause to make results of one statement available for further consuming statements but does not require ordered delivery of results from producing statements to consuming statements, you may disable delivery order guarantees between statements: 
			</p><pre class="programlisting">Configuration config = new Configuration();
config.getEngineDefaults().getThreading().setInsertIntoDispatchPreserveOrder(false);</pre><p>
				Additional configuration options are available and described in the configuration section that specify timeout values and spin or thread context switching.
			</p><p>
				Esper logging will log the following informational message when guaranteed delivery order to listeners is enabled and spin lock times exceed the default or configured timeout : <tt class="literal">Spin wait timeout exceeded in listener dispatch</tt>.
				The respective message for delivery from <tt class="literal">insert into</tt> statements to consuming statements is <tt class="literal">Spin wait timeout exceeded in insert-into dispatch</tt>.
			</p><p>
				If your application sees messages that spin lock times are exceeded, your application has several options: First, disabling preserve order is an option. Second, ensure your listener does not perform (long-running) blocking operations before returning, for example by performing output event processing in a separate thread. Third, change the timeout value to a larger number to block longer without logging the message.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="perf-tips-12"></a>13.2.13.&nbsp;Use a Subscriber Object to Receive Events</h3></div></div><div></div></div><p>
				The subscriber object is a technique for receive result data that has performance advantages over the <tt class="literal">UpdateListener</tt> interface. Please refer to <a href="#api-admin-subscriber" title="9.3.3.&nbsp;Setting a Subscriber Object">Section&nbsp;9.3.3, &#8220;Setting a Subscriber Object&#8221;</a>.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="perf-tips-13"></a>13.2.14.&nbsp;High-Arrival-Rate Streams and Single Statements</h3></div></div><div></div></div><p>
				A statement is associated with certain statement state that consists of current aggregation values, partial pattern matches, data windows or other view state depending on whether your statement uses such constructs. When an engine receives events it updates statement state under locking such that statement state remains consistent under concurrent multi-threaded access.
			</p><p>
				For high-volume streams, the locking required to protected statement state may slow down or introduce blocking for very high arrival rates of events that apply to the very same statement and its state. You may want to consider splitting a single statement into multiple statements that each look for a certain subset of the high-arrival-rate stream. There is very little cost in terms of memory or CPU resources per statement, the engine can handle larger number of statements usually as efficiently as single statements.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="perf-tips-14"></a>13.2.15.&nbsp;Performance, JVM, OS and hardware</h3></div></div><div></div></div><p>
				Performance will also depend on your JVM (Sun HotSpot, BEA JRockit, IBM J9), your operating system and your hardware.
				A JVM performance index such as specJBB at <a href="http://www.spec.org" target="_top">spec.org</a> can be used. For memory intensive statement, you may want
				to consider 64bit architecture that can address more than 2GB or 3GB of memory, although a 64bit JVM usually comes with a slow performance penalty due to
				more complex pointer address management.
			</p><p>
				The choice of JVM, OS and hardware depends on a number of factors and therefore a definite suggestion is hard to make.
				The choice depends on the number of statements, and number of threads.
				A larger number of threads would benefit of more CPU and cores. If you have very low latency requirements, you should consider
				getting more GHz per core, and possibly soft real-time JVM to enforce GC determinism at the JVM level, or even consider dedicated hardware such as Azul.
				If your statements utilize large data windows, more RAM and heap space will be utilized hence you should clearly plan and account for that and possibly consider 64bit architectures or consider
				<a href="http://www.espertech.com/products/" target="_top">EsperHA</a>.
			</p><p>
				The number and type of statements is a factor that cannot be generically accounted for.
				The benchmark kit can help test out some requirements and establish baselines, and for more complex use cases
				a simulation or proof of concept would certainly works best.
				<a href="http://www.espertech.com/support/services.php" target="_top">EsperTech' experts</a> can be available to help write interfaces in a consulting relationship.
			</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="performance-kit"></a>13.3.&nbsp;Using the performance kit</h2></div></div><div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="how-to-kit"></a>13.3.1.&nbsp;How to use the performance kit</h3></div></div><div></div></div><p>
            The benchmark application is basically an Esper event server build with Esper that listens to remote clients
            over TCP.
            Remote clients send MarketData(ticker, price, volume) streams to the event server.
            The Esper event server is started with 1000 statements of one single kind (unless otherwise written),
            with one statement per ticker symbol, unless the statement kind does not depend on the symbol.
            The statement prototype is provided along the results with a '$' instead of the actual ticker symbol value.
            The Esper event server is entirely multithreaded and can leverage the full power of 32bit or 64bit
            underlying hardware multi-processor multi-core architecture.
        </p><p>
                The kit also prints out when starting up the event size and the theoretical maximal throughput you can get on a
                100 Mbit/s and 1 Gbit/s network. Keep in mind a 100 Mbit/s network will be overloaded at about 400 000 event/s when using our kit despite
                the small size of events.
            </p><p>
            Results are posted on our Wiki page at <a href="http://docs.codehaus.org/display/ESPER/Esper+performance" target="_top">http://docs.codehaus.org/display/ESPER/Esper+performance</a>.
            Reported results do not represent best ever obtained results. Reported results may help you better compare
            Esper to other solutions (for latency, throughput and CPU utilization) and also assess your target hardware and JVMs.
        </p><p>
                The Esper event server, client and statement prototypes are provided in the source repository
                <tt class="literal">esper/trunk/examples/benchmark/</tt>
                . Refer to <a href="http://xircles.codehaus.org/projects/esper/repo" target="_top">http://xircles.codehaus.org/projects/esper/repo</a>
                for source access.
            </p><p>
                A built is provided for convenience (without sources) as an attachment to the Wiki page
                at <a href="http://docs.codehaus.org/pages/viewpageattachments.action?pageId=8356191" target="_top">http://docs.codehaus.org/pages/viewpageattachments.action?pageId=8356191</a>.
                It contains Ant script to start client, server in simulation mode and server. For real measurement we
                advise
                to start from a shell script (because Ant is pipelining stdout/stderr when you invoke a JVM from Ant -
                which
                is costly). Sample scripts are provided for you to edit and customize.
            </p><p>
                If you use the kit you should:
            </p><div class="orderedlist"><ol type="1"><li><p>
                        Choose the statement you want to benchmark, add it to
                        <tt class="literal">etc/statements.properties</tt>
                        under
                        your own KEY and use the
                        <tt class="literal">-mode KEY</tt>
                        when you start the Esper event server.
                    </p></li><li><p>
                        Prepare your runServer.sh/runServer.cmd and runClient.sh/runclient.cmd scripts. You'll need to
                        drop required
                        jar libraries in
                        <tt class="literal">lib/</tt>
                        , make sure the classpath is configured in those script to include
                        <tt class="literal">build</tt>
                        and
                        <tt class="literal">etc</tt>
                        . The required libraries are Esper (any compatible version, we have tested started with Esper
                        1.7.0)
                        and its dependencies as in the sample below (with Esper 2.1) :
                        </p><pre class="programlisting"># classpath on Unix/Linux (on one single line)
etc:build:lib/esper-3.1.0.jar:lib/commons-logging-1.1.1.jar:lib/cglib-nodep-2.2.jar
   :lib/antlr-runtime-3.1.1.jar:lib/log4j-1.2.15.jar
@rem  classpath on Windows (on one single line)
etc;build;lib\esper-3.1.0.jar;lib\commons-logging-1.1.1.jar;lib\cglib-nodep-2.2.jar
   ;lib\antlr-runtime-3.1.1.jar;lib\log4j-1.2.15.jar</pre><p>
                        Note that <tt class="literal">./etc</tt> and <tt class="literal">./build</tt> have to be in the classpath.
                        At that stage you should also start to set min and max JVM heap. A good start is 1GB as in
                        <tt class="literal">-Xms1g -Xmx1g</tt>
                    </p></li><li><p>
                        Write the statement you want to benchmark given that client will send a stream MarketData(String
                        ticker, int volume, double price), add it to
                        <tt class="literal">etc/statements.properties</tt>
                        under
                        your own KEY and use the
                        <tt class="literal">-mode KEY</tt>
                        when you start the Esper event server.
                        Use <tt class="literal">'$'</tt> in the statement to create a prototype. For every symbol, a statement
                        will get registered with all <tt class="literal">'$'</tt> replaced by the actual symbol value (f.e. <tt class="literal">'GOOG'</tt>)
                    </p></li><li><p>
                        Ensure client and server are using the same
                        <tt class="literal">-Desper.benchmark.symbol=1000</tt> value.
                        This sets the number of symbol to use (thus may set the number of statement if you are using
                        a statement prototype, and governs how MarketData event are represented over the network.
                        Basically all events will have the same size over the network to ensure predictability and will be ranging
                        between <tt class="literal">S0AA</tt> and <tt class="literal">S999A</tt> if you use 1000 as a value here (prefix with S and padded with A up to
                        a fixed length string. Volume and price attributes will be randomized.
                    </p></li><li><p>
                        By default the benchmark registers a subscriber to the statement(s). Use <tt class="literal">-Desper.benchmark.ul</tt> to use
                        an UpdateListener instead. Note that the subscriber contains suitable update(..) methods for the default
                        proposed statement in the <tt class="literal">etc/statements.properties</tt> file but might not be suitable if you change statements due
                        to the strong binding with statement results. Refer to <a href="#api-receive-results" title="9.3.2.&nbsp;Receiving Statement Results">Section&nbsp;9.3.2, &#8220;Receiving Statement Results&#8221;</a>.
                    </p></li><li><p>
                        Establish a performance baseline in simulation mode (without clients). Use the
                        <tt class="literal">-rate 1x5000</tt>
                        option
                        to simulate one client (one thread) sending 5000 evt/s. You can ramp up both the number of client simulated
                        thread and their emission rate to maximize CPU
                        utilization.
                        The right number should mimic the client emission rate you will use in the client/server benchmark
                        and should thus be
                        consistent with what your client machine and network will be able to send.
                        On small hardware, having a lot of thread with slow rate will not help getting high throughput in this
                        simulation mode.
                    </p></li><li><p>
                        Do performance runs with client/server mode. Remove the
                        <tt class="literal">-rate NxM</tt>
                        option from the runServer script or Ant task.
                        Start the server with
                        <tt class="literal">-help</tt>
                        to display the possible server options (listen port, statistics, fan out options etc).
                        On the remote machine, start one or more client. Use
                        <tt class="literal">-help</tt>
                        to display the possible client options (remote port, host,
                        emission rate). The client will output the actual number of event it is sending to the server.
                        If the server gets overloaded (or if you turned on
                        <tt class="literal">-queue</tt>
                        options on the server) the client will likely
                        not be able to reach its target rate.
                    </p><p>
                        Usually you will get better performance by using server side <tt class="literal">-queue -1</tt> option so as to have
                        each client connection handled by a single thread pipeline. If you change to 0 or more, there will be
                        intermediate structures to pass the event stream in an asynchronous fashion. This will increase context
                        switching, although if you are using many clients, or are using the <tt class="literal">-sleep xxx</tt> (xxx in
                        milliseconds) to simulate a listener delay you may get better performance.
                    </p><p>
                        The most important server side option is <tt class="literal">-stat xxx</tt> (xxx in seconds) to print out
                        throughput and latency statistics aggregated over the last xxx seconds (and reset every time).
                        It will produce both internal Esper latency (in nanosecond) and also end to end latency (in millisecond, including network time).
                        If you are measuring end to end latency you should make sure your server and client machine(s) are having the same time
                        with f.e. ntpd with a good enough precision.
                        The stat format is like:
                        </p><pre class="programlisting">---Stats - engine (unit: ns)
  Avg: 2528 #4101107
        0 &lt;    5000:  97.01%  97.01% #3978672
     5000 &lt;   10000:   2.60%  99.62% #106669
    10000 &lt;   15000:   0.35%  99.97% #14337
    15000 &lt;   20000:   0.02%  99.99% #971
    20000 &lt;   25000:   0.00%  99.99% #177
    25000 &lt;   50000:   0.00% 100.00% #89
    50000 &lt;  100000:   0.00% 100.00% #41
   100000 &lt;  500000:   0.00% 100.00% #120
   500000 &lt; 1000000:   0.00% 100.00% #2
  1000000 &lt; 2500000:   0.00% 100.00% #7
  2500000 &lt; 5000000:   0.00% 100.00% #5
  5000000 &lt;    more:   0.00% 100.00% #18
---Stats - endToEnd (unit: ms)
  Avg: -2704829444341073400 #4101609
        0 &lt;       1:  75.01%  75.01% #3076609
        1 &lt;       5:   0.00%  75.01% #0
        5 &lt;      10:   0.00%  75.01% #0
       10 &lt;      50:   0.00%  75.01% #0
       50 &lt;     100:   0.00%  75.01% #0
      100 &lt;     250:   0.00%  75.01% #0
      250 &lt;     500:   0.00%  75.01% #0
      500 &lt;    1000:   0.00%  75.01% #0
     1000 &lt;    more:  24.99% 100.00% #1025000
Throughput 412503 (active 0 pending 0 cnx 4)</pre><p>
                        This one reads as:
</p><pre class="programlisting">"Throughput is 412 503 event/s with 4 client connected. No -queue options 
was used thus no event is pending at the time the statistics are printed. 
Esper latency average is at 2528 ns (that is 2.5 us) for 4 101 107 events 
(which means we have 10 seconds stats here). Less than 10us latency 
was achieved for 106 669 events that is 99.62%. Latency between 5us 
and 10us was achieved for those 2.60% of all the events in the interval."

"End to end latency was ... in this case likely due to client clock difference
we ended up with unusable end to end statistics."</pre><p>

	</p><p>
		Consider the second output paragraph on end-to-end latency:
	</p><p>
                        
      </p><pre class="programlisting">---Stats - endToEnd (unit: ms)
  Avg: 15 #863396
        0 &lt;       1:   0.75%   0.75% #6434
        1 &lt;       5:   0.99%   1.74% #8552
        5 &lt;      10:   2.12%   3.85% #18269
       10 &lt;      50:  91.27%  95.13% #788062
       50 &lt;     100:   0.10%  95.22% #827
      100 &lt;     250:   4.36%  99.58% #37634
      250 &lt;     500:   0.42% 100.00% #3618
      500 &lt;    1000:   0.00% 100.00% #0
     1000 &lt;    more:   0.00% 100.00% #0</pre><p>
     
     </p><p>
		 This would read:
     </p><p>
                        
</p><pre class="programlisting">"End to end latency average is at 15 milliseconds for the 863 396 events 
considered for this statistic report. 95.13% ie 788 062 events were handled 
(end to end) below 50ms, and 91.27% were handled between 10ms and 50ms."</pre><p>

                    </p></li></ol></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="how-we-kit"></a>13.3.2.&nbsp;How we use the performance kit</h3></div></div><div></div></div><p>
                We use the performance kit to track performance progress across Esper versions, as well as to implement
                optimizations. You can track our work on the Wiki at <a href=" http://docs.codehaus.org/display/ESPER/Home" target="_top"> http://docs.codehaus.org/display/ESPER/Home</a>
            </p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="references"></a>Chapter&nbsp;14.&nbsp;References</h2></div></div><div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="references-listing"></a>14.1.&nbsp;Reference List</h2></div></div><div></div></div><div class="itemizedlist"><ul type="disc" compact><li><p>
					Luckham, David. 2002. <span class="emphasis"><em>The Power of Events.</em></span> Addison-Wesley.
				</p></li><li><p>
					The Stanford Rapide (TM) Project. <span class="emphasis"><em>http://pavg.stanford.edu/rapide</em></span>.
				</p></li><li><p>
					Arasu, Arvind, et.al.. 2004. Linear Road: A Stream Data Management Benchmark, Stanford University <span class="emphasis"><em>http://www.cs.brown.edu/research/aurora/Linear_Road_Benchmark_Homepage.html</em></span>.
				</p></li></ul></div></div></div><div class="appendix" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="appendix_outputspec"></a>Appendix&nbsp;A.&nbsp;Output Reference and Samples</h2></div></div><div></div></div><p>
		This section specifies the output of a subset of EPL continuous queries, for two purposes: First, to help application developers understand streaming engine output in response to incoming events and in response to time passing. Second, to document and standardize output for EPL queries in a testable and trackable fashion. 
    </p><p>
		The section focuses on a subset of features, namely the time window, aggregation, grouping, and output rate limiting. The section does not currently provide examples for many of the other language features, thus there is no example for other data windows (the time window is used here), joins, sub-selects or named windows etc.
    </p><p>
		Rather then just describe syntax and output, this section provides detailed examples for each of the types of queries presented. The input for each type of query is always the same set of events, and the same timing. Each event has three properties: symbol, volume and price. The property types are string, long and double, respectively.
    </p><p>
		The chapters are organized by the type of query: The presence or absence of aggregation functions, as well as the presence or absence of a <tt class="literal">group by</tt> clause change statement output as 
		described in <a href="#processingmodel_aggregation_output" title="3.7.2.&nbsp;Output for Aggregation and Group-By">Section&nbsp;3.7.2, &#8220;Output for Aggregation and Group-By&#8221;</a>.
	</p><p>
		You will notice that some queries utilize the <tt class="literal">order by</tt> clause for sorting output. The reason is that when multiple output rows are produced at once, the output can be easier to read if it is sorted.
	</p><p>
	    With output rate limiting, the engine invokes your listener even if there are no results to indicate when the output condition has been reached. Such is indicated as <tt class="literal">(empty result)</tt> in the output result columns.
	</p><p>
	    The output columns show both insert and remove stream events. Insert stream events are delivered as an array of <tt class="literal">EventBean</tt> instances to listeners in the <tt class="literal">newData</tt> parameter, while remove stream events are delivered to the <tt class="literal">oldData</tt> parameter of listeners. Delivery to observers follows similar rules.
	</p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="outputspec-intro"></a>A.1.&nbsp;Introduction and Sample Data</h2></div></div><div></div></div><p>
			For the purpose of illustration and documentation, the example data set demonstrates input and remove streams based on a time window of a 5.5 second interval. The statement utilizing the time window 
			could look as follows:
		</p><pre class="programlisting">select symbol, volume, price from MarketData.win:time(5.5 sec)</pre><p>
			We have picked a time window to demonstrate the output for events entering and leaving a data window with an expiration policy. The time window provides a simple expiration policy based on time: if an event resides in the time window more then 5.5 seconds, the engine expires the event from the time window.
		</p><p>
			The input events and their timing are below. The table should be read, starting from top, as "The time starts at 0.2 seconds. Event E1 arrives at 0.2 seconds with properties [S1, 100, 25]. At 0.8 second event E2 arrives with properties [S2, 5000, 9.0]" and so on.
		</p><pre class="programlisting">
                       Input                                 
-----------------------------------------------  
 Time Symbol  Volume   Price
  0.2                          
          S1     100    25.0   Event E1 arrives
  0.8                          
          S2    5000     9.0   Event E2 arrives
  1.0                          
  1.2                          
  1.5                          
          S1     150    24.0   Event E3 arrives
          S3   10000     1.0   Event E4 arrives
  2.0                          
  2.1                          
          S1     155    26.0   Event E5 arrives
  2.2                          
  2.5                          
  3.0                          
  3.2                          
  3.5                          
          S3   11000     2.0   Event E6 arrives
  4.0                          
  4.2                          
  4.3                          
          S1     150    22.0   Event E7 arrives
  4.9                          
          S3   11500     3.0   Event E8 arrives
  5.0                          
  5.2                          
  5.7                          Event E1 leaves the time window
  5.9                          
          S3   10500     1.0   Event E9 arrives
  6.0                          
  6.2                          
  6.3                          Event E2 leaves the time window
  7.0                          Event E3 and E4 leave the time window
  7.2                          </pre><p>
			  The event data set assumes a time window of 5.5 seconds. Thus at time 5.7 seconds the first arriving event (E1) leaves the time window.
		  </p><p>
			The data set as above shows times between 0.2 seconds and 7.2 seconds. Only a couple of time points have been picked for the table to keep the set of time points constant between statements, and thus make the test data and output easier to understand. 
			</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="outputspec-simple"></a>A.2.&nbsp;Output for Un-aggregated and Un-grouped Queries</h2></div></div><div></div></div><p>
			This chapter provides sample output for queries that do not have aggregation functions and do not have a <tt class="literal">group by</tt> clause.
        </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="outputspec-simple-none"></a>A.2.1.&nbsp;No Output Rate Limiting</h3></div></div><div></div></div><p>
				Without an <tt class="literal">output</tt> clause, the engine dispatches to listeners as soon as events arrive, or as soon as time passes such that events leave data windows.
			</p><p>
				The statement for this sample reads:
			</p><pre class="programlisting">select irstream symbol, volume, price from MarketData.win:time(5.5 sec)</pre><p>
				The output is as follows:
			</p><pre class="programlisting">                       Input                                  Output
                                                 Insert Stream    Remove Stream
-----------------------------------------------  ----------------------------------
 Time Symbol  Volume   Price
  0.2                          
         IBM     100    25.0   Event E1 arrives
                                                 [IBM, 100, 25.0]                       
  0.8                          
        MSFT    5000     9.0   Event E2 arrives
                                                 [MSFT, 5000, 9.0]                      
  1.0                          
  1.2                          
  1.5                          
         IBM     150    24.0   Event E3 arrives
                                                 [IBM, 150, 24.0]                       
         YAH   10000     1.0   Event E4 arrives
                                                 [YAH, 10000, 1.0]                      
  2.0                          
  2.1                          
         IBM     155    26.0   Event E5 arrives
                                                 [IBM, 155, 26.0]                       
  2.2                          
  2.5                          
  3.0                          
  3.2                          
  3.5                          
         YAH   11000     2.0   Event E6 arrives
                                                 [YAH, 11000, 2.0]                      
  4.0                          
  4.2                          
  4.3                          
         IBM     150    22.0   Event E7 arrives
                                                 [IBM, 150, 22.0]                       
  4.9                          
         YAH   11500     3.0   Event E8 arrives
                                                 [YAH, 11500, 3.0]                      
  5.0                          
  5.2                          
  5.7                          Event E1 leaves the time window
                                                                    [IBM, 100, 25.0]    
  5.9                          
         YAH   10500     1.0   Event E9 arrives
                                                 [YAH, 10500, 1.0]                      
  6.0                          
  6.2                          
  6.3                          Event E2 leaves the time window
                                                                    [MSFT, 5000, 9.0]   
  7.0                          Event E3 and E4 leave the time window
                                                                    [IBM, 150, 24.0]    
                                                                    [YAH, 10000, 1.0]   
  7.2                          </pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="outputspec-simple-default"></a>A.2.2.&nbsp;Output Rate Limiting - Default</h3></div></div><div></div></div><p>
				With an <tt class="literal">output</tt> clause, the engine dispatches to listeners when the output condition occurs. Here, the output condition is a 1-second time interval. The engine thus outputs every 1 second, starting from the first event, even if there are no new events or no expiring events to output.
			</p><p>
				The default (no keyword) and the <tt class="literal">ALL</tt> keyword result in the same output.
			</p><p>
				The statement for this sample reads:
			</p><pre class="programlisting">select irstream symbol, volume, price from MarketData.win:time(5.5 sec) 
output every 1 seconds</pre><p>
				The output is as follows:
			</p><pre class="programlisting">                       Input                                  Output
                                                 Insert Stream    Remove Stream
-----------------------------------------------  ----------------------------------
 Time Symbol  Volume   Price
  0.2                          
         IBM     100    25.0   Event E1 arrives
  0.8                          
        MSFT    5000     9.0   Event E2 arrives
  1.0                          
  1.2                          
                                                 [IBM, 100, 25.0]                       
                                                 [MSFT, 5000, 9.0]                      
  1.5                          
         IBM     150    24.0   Event E3 arrives
         YAH   10000     1.0   Event E4 arrives
  2.0                          
  2.1                          
         IBM     155    26.0   Event E5 arrives
  2.2                          
                                                 [IBM, 150, 24.0]                       
                                                 [YAH, 10000, 1.0]                      
                                                 [IBM, 155, 26.0]                       
  2.5                          
  3.0                          
  3.2                          
                                                 (empty result)     (empty result)      
  3.5                          
         YAH   11000     2.0   Event E6 arrives
  4.0                          
  4.2                          
                                                 [YAH, 11000, 2.0]                      
  4.3                          
         IBM     150    22.0   Event E7 arrives
  4.9                          
         YAH   11500     3.0   Event E8 arrives
  5.0                          
  5.2                          
                                                 [IBM, 150, 22.0]                       
                                                 [YAH, 11500, 3.0]                      
  5.7                          Event E1 leaves the time window
  5.9                          
         YAH   10500     1.0   Event E9 arrives
  6.0                          
  6.2                          
                                                 [YAH, 10500, 1.0]  [IBM, 100, 25.0]    
  6.3                          Event E2 leaves the time window
  7.0                          Event E3 and E4 leave the time window
  7.2                          
                                                                    [MSFT, 5000, 9.0]   
                                                                    [IBM, 150, 24.0]    
                                                                    [YAH, 10000, 1.0] </pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="outputspec-simple-last"></a>A.2.3.&nbsp;Output Rate Limiting - Last</h3></div></div><div></div></div><p>
				Using the <tt class="literal">LAST</tt> keyword in the <tt class="literal">output</tt> clause, the engine dispatches to listeners only the last event of each insert and remove stream.
			</p><p>
				The statement for this sample reads:
			</p><pre class="programlisting">select irstream symbol, volume, price from MarketData.win:time(5.5 sec) 
output last every 1 seconds</pre><p>
				The output is as follows:
			</p><pre class="programlisting">                       Input                                  Output
                                                 Insert Stream    Remove Stream
-----------------------------------------------  ----------------------------------
 Time Symbol  Volume   Price
  0.2                          
         IBM     100    25.0   Event E1 arrives
  0.8                          
        MSFT    5000     9.0   Event E2 arrives
  1.0                          
  1.2                          
                                                 [MSFT, 5000, 9.0]                      
  1.5                          
         IBM     150    24.0   Event E3 arrives
         YAH   10000     1.0   Event E4 arrives
  2.0                          
  2.1                          
         IBM     155    26.0   Event E5 arrives
  2.2                          
                                                 [IBM, 155, 26.0]                       
  2.5                          
  3.0                          
  3.2                          
                                                 (empty result)     (empty result)      
  3.5                          
         YAH   11000     2.0   Event E6 arrives
  4.0                          
  4.2                          
                                                 [YAH, 11000, 2.0]                      
  4.3                          
         IBM     150    22.0   Event E7 arrives
  4.9                          
         YAH   11500     3.0   Event E8 arrives
  5.0                          
  5.2                          
                                                 [YAH, 11500, 3.0]                      
  5.7                          Event E1 leaves the time window
  5.9                          
         YAH   10500     1.0   Event E9 arrives
  6.0                          
  6.2                          
                                                 [YAH, 10500, 1.0]  [IBM, 100, 25.0]    
  6.3                          Event E2 leaves the time window
  7.0                          Event E3 and E4 leave the time window
  7.2                          
                                                                    [YAH, 10000, 1.0] </pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="outputspec-simple-first"></a>A.2.4.&nbsp;Output Rate Limiting - First</h3></div></div><div></div></div><p>
				Using the <tt class="literal">FIRST</tt> keyword in the <tt class="literal">output</tt> clause, the engine dispatches to listeners only the first event of each insert or remove stream, and does not output further
				events until the output condition is reached.
			</p><p>
				The statement for this sample reads:
			</p><pre class="programlisting">select irstream symbol, volume, price from MarketData.win:time(5.5 sec)
output first every 1 seconds</pre><p>
				The output is as follows:
			</p><pre class="programlisting">                      Input                                  Output
                                                 Insert Stream    Remove Stream
-----------------------------------------------  ----------------------------------
 Time Symbol  Volume   Price
  0.2                          
         IBM     100    25.0   Event E1 arrives
                                                 [IBM, 100, 25.0]                       
  0.8                          
        MSFT    5000     9.0   Event E2 arrives
  1.0                          
  1.2                          
  1.5                          
         IBM     150    24.0   Event E3 arrives
                                                 [IBM, 150, 24.0]                       
         YAH   10000     1.0   Event E4 arrives
  2.0                          
  2.1                          
         IBM     155    26.0   Event E5 arrives
  2.2                          
  2.5                          
  3.0                          
  3.2                          
                                                 (empty result)     (empty result)      
  3.5                          
         YAH   11000     2.0   Event E6 arrives
                                                 [YAH, 11000, 2.0]                      
  4.0                          
  4.2                          
  4.3                          
         IBM     150    22.0   Event E7 arrives
                                                 [IBM, 150, 22.0]                       
  4.9                          
         YAH   11500     3.0   Event E8 arrives
  5.0                          
  5.2                          
  5.7                          Event E1 leaves the time window
                                                                    [IBM, 100, 25.0]    
  5.9                          
         YAH   10500     1.0   Event E9 arrives
  6.0                          
  6.2                          
  6.3                          Event E2 leaves the time window
                                                                    [MSFT, 5000, 9.0]   
  7.0                          Event E3 and E4 leave the time window
  7.2                          			</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="outputspec-simple-snapshot"></a>A.2.5.&nbsp;Output Rate Limiting - Snapshot</h3></div></div><div></div></div><p>
				Using the <tt class="literal">SNAPSHOT</tt> keyword in the <tt class="literal">output</tt> clause, the engine posts data window contents when the output condition is reached.
			</p><p>
				The statement for this sample reads:
			</p><pre class="programlisting">select irstream symbol, volume, price from MarketData.win:time(5.5 sec)
output snapshot every 1 seconds</pre><p>
				The output is as follows:
			</p><pre class="programlisting">                       Input                                  Output
                                                 Insert Stream    Remove Stream
-----------------------------------------------  ----------------------------------
 Time Symbol  Volume   Price
  0.2                          
         IBM     100    25.0   Event E1 arrives
  0.8                          
        MSFT    5000     9.0   Event E2 arrives
  1.0                          
  1.2                          
                                                 [IBM, 100, 25.0]                       
                                                 [MSFT, 5000, 9.0]                      
  1.5                          
         IBM     150    24.0   Event E3 arrives
         YAH   10000     1.0   Event E4 arrives
  2.0                          
  2.1                          
         IBM     155    26.0   Event E5 arrives
  2.2                          
                                                 [IBM, 100, 25.0]                       
                                                 [MSFT, 5000, 9.0]                      
                                                 [IBM, 150, 24.0]                       
                                                 [YAH, 10000, 1.0]                      
                                                 [IBM, 155, 26.0]                       
  2.5                          
  3.0                          
  3.2                          
                                                 [IBM, 100, 25.0]                       
                                                 [MSFT, 5000, 9.0]                      
                                                 [IBM, 150, 24.0]                       
                                                 [YAH, 10000, 1.0]                      
                                                 [IBM, 155, 26.0]                       
  3.5                          
         YAH   11000     2.0   Event E6 arrives
  4.0                          
  4.2                          
                                                 [IBM, 100, 25.0]                       
                                                 [MSFT, 5000, 9.0]                      
                                                 [IBM, 150, 24.0]                       
                                                 [YAH, 10000, 1.0]                      
                                                 [IBM, 155, 26.0]                       
                                                 [YAH, 11000, 2.0]                      
  4.3                          
         IBM     150    22.0   Event E7 arrives
  4.9                          
         YAH   11500     3.0   Event E8 arrives
  5.0                          
  5.2                          
                                                 [IBM, 100, 25.0]                       
                                                 [MSFT, 5000, 9.0]                      
                                                 [IBM, 150, 24.0]                       
                                                 [YAH, 10000, 1.0]                      
                                                 [IBM, 155, 26.0]                       
                                                 [YAH, 11000, 2.0]                      
                                                 [IBM, 150, 22.0]                       
                                                 [YAH, 11500, 3.0]                      
  5.7                          Event E1 leaves the time window
  5.9                          
         YAH   10500     1.0   Event E9 arrives
  6.0                          
  6.2                          
                                                 [MSFT, 5000, 9.0]                      
                                                 [IBM, 150, 24.0]                       
                                                 [YAH, 10000, 1.0]                      
                                                 [IBM, 155, 26.0]                       
                                                 [YAH, 11000, 2.0]                      
                                                 [IBM, 150, 22.0]                       
                                                 [YAH, 11500, 3.0]                      
                                                 [YAH, 10500, 1.0]                      
  6.3                          Event E2 leaves the time window
  7.0                          Event E3 and E4 leave the time window
  7.2                          
                                                 [IBM, 155, 26.0]                       
                                                 [YAH, 11000, 2.0]                      
                                                 [IBM, 150, 22.0]                       
                                                 [YAH, 11500, 3.0]                      
                                                 [YAH, 10500, 1.0] 			</pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="outputspec-rowforall"></a>A.3.&nbsp;Output for Fully-aggregated and Un-grouped Queries</h2></div></div><div></div></div><p>
			This chapter provides sample output for queries that have aggregation functions, and that do not have a <tt class="literal">group by</tt> clause, and in which all event properties are under aggregation.
        </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="outputspec-rowforall-none"></a>A.3.1.&nbsp;No Output Rate Limiting</h3></div></div><div></div></div><p>
				The statement for this sample reads:
			</p><pre class="programlisting">select irstream sum(price) from MarketData.win:time(5.5 sec)</pre><p>
				The output is as follows:
			</p><pre class="programlisting">                       Input                                  Output
                                                 Insert Stream    Remove Stream
-----------------------------------------------  ----------------------------------
 Time Symbol  Volume   Price
  0.2                          
         IBM     100    25.0   Event E1 arrives
                                                 [25.0]             [null]              
  0.8                          
        MSFT    5000     9.0   Event E2 arrives
                                                 [34.0]             [25.0]              
  1.0                          
  1.2                          
  1.5                          
         IBM     150    24.0   Event E3 arrives
                                                 [58.0]             [34.0]              
         YAH   10000     1.0   Event E4 arrives
                                                 [59.0]             [58.0]              
  2.0                          
  2.1                          
         IBM     155    26.0   Event E5 arrives
                                                 [85.0]             [59.0]              
  2.2                          
  2.5                          
  3.0                          
  3.2                          
  3.5                          
         YAH   11000     2.0   Event E6 arrives
                                                 [87.0]             [85.0]              
  4.0                          
  4.2                          
  4.3                          
         IBM     150    22.0   Event E7 arrives
                                                 [109.0]            [87.0]              
  4.9                          
         YAH   11500     3.0   Event E8 arrives
                                                 [112.0]            [109.0]             
  5.0                          
  5.2                          
  5.7                          Event E1 leaves the time window
                                                 [87.0]             [112.0]             
  5.9                          
         YAH   10500     1.0   Event E9 arrives
                                                 [88.0]             [87.0]              
  6.0                          
  6.2                          
  6.3                          Event E2 leaves the time window
                                                 [79.0]             [88.0]              
  7.0                          Event E3 and E4 leave the time window
                                                 [54.0]             [79.0]              
  7.2                         			</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="outputspec-rowforall-default"></a>A.3.2.&nbsp;Output Rate Limiting - Default</h3></div></div><div></div></div><p>
				Output occurs when the output condition is reached after each 1-second time interval. For each event arriving, the new aggregation value is output as part of the insert stream. As part of the remove stream, the prior aggregation value is output. This is useful for getting a delta-change for each event or group. If there is a <tt class="literal">having</tt> clause, the filter expression applies to each row.
			</p><p>
				Here also the default (no keyword) and the <tt class="literal">ALL</tt> keyword result in the same output.
			</p><p>
				The statement for this sample reads:
			</p><pre class="programlisting">select irstream sum(price) from MarketData.win:time(5.5 sec)
output every 1 seconds</pre><p>
				The output is as follows:
			</p><pre class="programlisting">                       Input                                  Output
                                                 Insert Stream    Remove Stream
-----------------------------------------------  ----------------------------------
 Time Symbol  Volume   Price
  0.2                          
         IBM     100    25.0   Event E1 arrives
  0.8                          
        MSFT    5000     9.0   Event E2 arrives
  1.0                          
  1.2                          
                                                 [25.0]             [null]              
                                                 [34.0]             [25.0]              
  1.5                          
         IBM     150    24.0   Event E3 arrives
         YAH   10000     1.0   Event E4 arrives
  2.0                          
  2.1                          
         IBM     155    26.0   Event E5 arrives
  2.2                          
                                                 [58.0]             [34.0]              
                                                 [59.0]             [58.0]              
                                                 [85.0]             [59.0]              
  2.5                          
  3.0                          
  3.2                          
                                                 [85.0]             [85.0]              
  3.5                          
         YAH   11000     2.0   Event E6 arrives
  4.0                          
  4.2                          
                                                 [87.0]             [85.0]              
  4.3                          
         IBM     150    22.0   Event E7 arrives
  4.9                          
         YAH   11500     3.0   Event E8 arrives
  5.0                          
  5.2                          
                                                 [109.0]            [87.0]              
                                                 [112.0]            [109.0]             
  5.7                          Event E1 leaves the time window
  5.9                          
         YAH   10500     1.0   Event E9 arrives
  6.0                          
  6.2                          
                                                 [87.0]             [112.0]             
                                                 [88.0]             [87.0]              
  6.3                          Event E2 leaves the time window
  7.0                          Event E3 and E4 leave the time window
  7.2                          
                                                 [79.0]             [88.0]              
                                                 [54.0]             [79.0] 			</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="outputspec-rowforall-last"></a>A.3.3.&nbsp;Output Rate Limiting - Last</h3></div></div><div></div></div><p>
				With the <tt class="literal">LAST</tt> keyword, the insert stream carries one event that holds the last aggregation value, and the remove stream carries the prior aggregation value.
			</p><p>
				The statement for this sample reads:
			</p><pre class="programlisting">select irstream sum(price) from MarketData.win:time(5.5 sec) 
output last every 1 seconds</pre><p>
				The output is as follows:
			</p><pre class="programlisting">                       Input                                  Output
                                                 Insert Stream    Remove Stream
-----------------------------------------------  ----------------------------------
 Time Symbol  Volume   Price
  0.2                          
         IBM     100    25.0   Event E1 arrives
  0.8                          
        MSFT    5000     9.0   Event E2 arrives
  1.0                          
  1.2                          
                                                 [34.0]             [null]              
  1.5                          
         IBM     150    24.0   Event E3 arrives
         YAH   10000     1.0   Event E4 arrives
  2.0                          
  2.1                          
         IBM     155    26.0   Event E5 arrives
  2.2                          
                                                 [85.0]             [34.0]              
  2.5                          
  3.0                          
  3.2                          
                                                 [85.0]             [85.0]              
  3.5                          
         YAH   11000     2.0   Event E6 arrives
  4.0                          
  4.2                          
                                                 [87.0]             [85.0]              
  4.3                          
         IBM     150    22.0   Event E7 arrives
  4.9                          
         YAH   11500     3.0   Event E8 arrives
  5.0                          
  5.2                          
                                                 [112.0]            [87.0]              
  5.7                          Event E1 leaves the time window
  5.9                          
         YAH   10500     1.0   Event E9 arrives
  6.0                          
  6.2                          
                                                 [88.0]             [112.0]             
  6.3                          Event E2 leaves the time window
  7.0                          Event E3 and E4 leave the time window
  7.2                          
                                                 [54.0]             [88.0]  			 </pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="outputspec-rowforall-first"></a>A.3.4.&nbsp;Output Rate Limiting - First</h3></div></div><div></div></div><p>
				The statement for this sample reads:
			</p><pre class="programlisting">select irstream sum(price) from MarketData.win:time(5.5 sec)
output first every 1 seconds</pre><p>
				The output is as follows:
			</p><pre class="programlisting">                       Input                                  Output
                                                 Insert Stream    Remove Stream
-----------------------------------------------  ----------------------------------
 Time Symbol  Volume   Price
  0.2                          
         IBM     100    25.0   Event E1 arrives
                                                 [25.0]             [null]              
  0.8                          
        MSFT    5000     9.0   Event E2 arrives
  1.0                          
  1.2                          
  1.5                          
         IBM     150    24.0   Event E3 arrives
                                                 [58.0]             [34.0]              
         YAH   10000     1.0   Event E4 arrives
  2.0                          
  2.1                          
         IBM     155    26.0   Event E5 arrives
  2.2                          
  2.5                          
  3.0                          
  3.2                          
                                                 [85.0]             [85.0]              
  3.5                          
         YAH   11000     2.0   Event E6 arrives
                                                 [87.0]             [85.0]              
  4.0                          
  4.2                          
  4.3                          
         IBM     150    22.0   Event E7 arrives
                                                 [109.0]            [87.0]              
  4.9                          
         YAH   11500     3.0   Event E8 arrives
  5.0                          
  5.2                          
  5.7                          Event E1 leaves the time window
                                                 [87.0]             [112.0]             
  5.9                          
         YAH   10500     1.0   Event E9 arrives
  6.0                          
  6.2                          
  6.3                          Event E2 leaves the time window
                                                 [79.0]             [88.0]              
  7.0                          Event E3 and E4 leave the time window
  7.2                          </pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="outputspec-rowforall-snapshot"></a>A.3.5.&nbsp;Output Rate Limiting - Snapshot</h3></div></div><div></div></div><p>
				The statement for this sample reads:
			</p><pre class="programlisting">select irstream sum(price) from MarketData.win:time(5.5 sec)
output snapshot every 1 seconds</pre><p>
				The output is as follows:
			</p><pre class="programlisting">                       Input                                  Output
                                                 Insert Stream    Remove Stream
-----------------------------------------------  ----------------------------------
 Time Symbol  Volume   Price
  0.2                          
         IBM     100    25.0   Event E1 arrives
  0.8                          
        MSFT    5000     9.0   Event E2 arrives
  1.0                          
  1.2                          
                                                 [34.0]                                 
  1.5                          
         IBM     150    24.0   Event E3 arrives
         YAH   10000     1.0   Event E4 arrives
  2.0                          
  2.1                          
         IBM     155    26.0   Event E5 arrives
  2.2                          
                                                 [85.0]                                 
  2.5                          
  3.0                          
  3.2                          
                                                 [85.0]                                 
  3.5                          
         YAH   11000     2.0   Event E6 arrives
  4.0                          
  4.2                          
                                                 [87.0]                                 
  4.3                          
         IBM     150    22.0   Event E7 arrives
  4.9                          
         YAH   11500     3.0   Event E8 arrives
  5.0                          
  5.2                          
                                                 [112.0]                                
  5.7                          Event E1 leaves the time window
  5.9                          
         YAH   10500     1.0   Event E9 arrives
  6.0                          
  6.2                          
                                                 [88.0]                                 
  6.3                          Event E2 leaves the time window
  7.0                          Event E3 and E4 leave the time window
  7.2                          
                                                 [54.0]                			</pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="outputspec-aggregateall"></a>A.4.&nbsp;Output for Aggregated and Un-grouped Queries</h2></div></div><div></div></div><p>
			This chapter provides sample output for queries that have aggregation functions, and that do not have a <tt class="literal">group by</tt> clause, and in which there are event properties that are not under aggregation.
        </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="outputspec-aggregateall-none"></a>A.4.1.&nbsp;No Output Rate Limiting</h3></div></div><div></div></div><p>
				The statement for this sample reads:
			</p><pre class="programlisting">select irstream symbol, sum(price) from MarketData.win:time(5.5 sec)</pre><p>
				The output is as follows:
			</p><pre class="programlisting">                       Input                                  Output
                                                 Insert Stream    Remove Stream
-----------------------------------------------  ----------------------------------
 Time Symbol  Volume   Price
  0.2                          
         IBM     100    25.0   Event E1 arrives
                                                 [IBM, 25.0]                            
  0.8                          
        MSFT    5000     9.0   Event E2 arrives
                                                 [MSFT, 34.0]                           
  1.0                          
  1.2                          
  1.5                          
         IBM     150    24.0   Event E3 arrives
                                                 [IBM, 58.0]                            
         YAH   10000     1.0   Event E4 arrives
                                                 [YAH, 59.0]                            
  2.0                          
  2.1                          
         IBM     155    26.0   Event E5 arrives
                                                 [IBM, 85.0]                            
  2.2                          
  2.5                          
  3.0                          
  3.2                          
  3.5                          
         YAH   11000     2.0   Event E6 arrives
                                                 [YAH, 87.0]                            
  4.0                          
  4.2                          
  4.3                          
         IBM     150    22.0   Event E7 arrives
                                                 [IBM, 109.0]                           
  4.9                          
         YAH   11500     3.0   Event E8 arrives
                                                 [YAH, 112.0]                           
  5.0                          
  5.2                          
  5.7                          Event E1 leaves the time window
                                                                    [IBM, 87.0]         
  5.9                          
         YAH   10500     1.0   Event E9 arrives
                                                 [YAH, 88.0]                            
  6.0                          
  6.2                          
  6.3                          Event E2 leaves the time window
                                                                    [MSFT, 79.0]        
  7.0                          Event E3 and E4 leave the time window
                                                                    [IBM, 54.0]         
                                                                    [YAH, 54.0]         
  7.2                          			</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="outputspec-aggregateall-default"></a>A.4.2.&nbsp;Output Rate Limiting - Default</h3></div></div><div></div></div><p>
				The statement for this sample reads:
			</p><pre class="programlisting">select irstream symbol, sum(price) from MarketData.win:time(5.5 sec)
output every 1 seconds</pre><p>
				The output is as follows:
			</p><pre class="programlisting">                       Input                                  Output
                                                 Insert Stream    Remove Stream
-----------------------------------------------  ----------------------------------
 Time Symbol  Volume   Price
  0.2                          
         IBM     100    25.0   Event E1 arrives
  0.8                          
        MSFT    5000     9.0   Event E2 arrives
  1.0                          
  1.2                          
                                                 [IBM, 25.0]                            
                                                 [MSFT, 34.0]                           
  1.5                          
         IBM     150    24.0   Event E3 arrives
         YAH   10000     1.0   Event E4 arrives
  2.0                          
  2.1                          
         IBM     155    26.0   Event E5 arrives
  2.2                          
                                                 [IBM, 58.0]                            
                                                 [YAH, 59.0]                            
                                                 [IBM, 85.0]                            
  2.5                          
  3.0                          
  3.2                          
                                                 (empty result)     (empty result)      
  3.5                          
         YAH   11000     2.0   Event E6 arrives
  4.0                          
  4.2                          
                                                 [YAH, 87.0]                            
  4.3                          
         IBM     150    22.0   Event E7 arrives
  4.9                          
         YAH   11500     3.0   Event E8 arrives
  5.0                          
  5.2                          
                                                 [IBM, 109.0]                           
                                                 [YAH, 112.0]                           
  5.7                          Event E1 leaves the time window
  5.9                          
         YAH   10500     1.0   Event E9 arrives
  6.0                          
  6.2                          
                                                 [YAH, 88.0]        [IBM, 87.0]         
  6.3                          Event E2 leaves the time window
  7.0                          Event E3 and E4 leave the time window
  7.2                          
                                                                    [MSFT, 79.0]        
                                                                    [IBM, 54.0]         
                                                                    [YAH, 54.0] 			</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="outputspec-aggregateall-last"></a>A.4.3.&nbsp;Output Rate Limiting - Last</h3></div></div><div></div></div><p>
				The statement for this sample reads:
			</p><pre class="programlisting">select irstream symbol, sum(price) from MarketData.win:time(5.5 sec) 
output last every 1 seconds</pre><p>
				The output is as follows:
			</p><pre class="programlisting">                       Input                                  Output
                                                 Insert Stream    Remove Stream
-----------------------------------------------  ----------------------------------
 Time Symbol  Volume   Price
  0.2                          
         IBM     100    25.0   Event E1 arrives
  0.8                          
        MSFT    5000     9.0   Event E2 arrives
  1.0                          
  1.2                          
                                                 [MSFT, 34.0]                           
  1.5                          
         IBM     150    24.0   Event E3 arrives
         YAH   10000     1.0   Event E4 arrives
  2.0                          
  2.1                          
         IBM     155    26.0   Event E5 arrives
  2.2                          
                                                 [IBM, 85.0]                            
  2.5                          
  3.0                          
  3.2                          
                                                 (empty result)     (empty result)      
  3.5                          
         YAH   11000     2.0   Event E6 arrives
  4.0                          
  4.2                          
                                                 [YAH, 87.0]                            
  4.3                          
         IBM     150    22.0   Event E7 arrives
  4.9                          
         YAH   11500     3.0   Event E8 arrives
  5.0                          
  5.2                          
                                                 [YAH, 112.0]                           
  5.7                          Event E1 leaves the time window
  5.9                          
         YAH   10500     1.0   Event E9 arrives
  6.0                          
  6.2                          
                                                 [YAH, 88.0]        [IBM, 87.0]         
  6.3                          Event E2 leaves the time window
  7.0                          Event E3 and E4 leave the time window
  7.2                          
                                                                    [YAH, 54.0] 			 </pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="outputspec-aggregateall-first"></a>A.4.4.&nbsp;Output Rate Limiting - First</h3></div></div><div></div></div><p>
				The statement for this sample reads:
			</p><pre class="programlisting">select symbol, sum(price) from MarketData.win:time(5.5 sec)
output first every 1 seconds</pre><p>
				The output is as follows:
			</p><pre class="programlisting">                       Input                                  Output
                                                 Insert Stream    Remove Stream
-----------------------------------------------  ----------------------------------
 Time Symbol  Volume   Price
  0.2                          
         IBM     100    25.0   Event E1 arrives
                                                 [IBM, 25.0]                            
  0.8                          
        MSFT    5000     9.0   Event E2 arrives
  1.0                          
  1.2                          
  1.5                          
         IBM     150    24.0   Event E3 arrives
                                                 [IBM, 58.0]                            
         YAH   10000     1.0   Event E4 arrives
  2.0                          
  2.1                          
         IBM     155    26.0   Event E5 arrives
  2.2                          
  2.5                          
  3.0                          
  3.2                          
                                                 (empty result)     (empty result)      
  3.5                          
         YAH   11000     2.0   Event E6 arrives
                                                 [YAH, 87.0]                            
  4.0                          
  4.2                          
  4.3                          
         IBM     150    22.0   Event E7 arrives
                                                 [IBM, 109.0]                           
  4.9                          
         YAH   11500     3.0   Event E8 arrives
  5.0                          
  5.2                          
  5.7                          Event E1 leaves the time window
                                                                    [IBM, 87.0]         
  5.9                          
         YAH   10500     1.0   Event E9 arrives
  6.0                          
  6.2                          
  6.3                          Event E2 leaves the time window
                                                                    [MSFT, 79.0]        
  7.0                          Event E3 and E4 leave the time window
  7.2     			</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="outputspec-aggregateall-snapshot"></a>A.4.5.&nbsp;Output Rate Limiting - Snapshot</h3></div></div><div></div></div><p>
				The statement for this sample reads:
			</p><pre class="programlisting">select irstream symbol, sum(price) from MarketData.win:time(5.5 sec)
output snapshot every 1 seconds</pre><p>
				The output is as follows:
			</p><pre class="programlisting">                       Input                                  Output
                                                 Insert Stream    Remove Stream
-----------------------------------------------  ----------------------------------
 Time Symbol  Volume   Price
  0.2                          
         IBM     100    25.0   Event E1 arrives
  0.8                          
        MSFT    5000     9.0   Event E2 arrives
  1.0                          
  1.2                          
                                                 [IBM, 34.0]                            
                                                 [MSFT, 34.0]                           
  1.5                          
         IBM     150    24.0   Event E3 arrives
         YAH   10000     1.0   Event E4 arrives
  2.0                          
  2.1                          
         IBM     155    26.0   Event E5 arrives
  2.2                          
                                                 [IBM, 85.0]                            
                                                 [MSFT, 85.0]                           
                                                 [IBM, 85.0]                            
                                                 [YAH, 85.0]                            
                                                 [IBM, 85.0]                            
  2.5                          
  3.0                          
  3.2                          
                                                 [IBM, 85.0]                            
                                                 [MSFT, 85.0]                           
                                                 [IBM, 85.0]                            
                                                 [YAH, 85.0]                            
                                                 [IBM, 85.0]                            
  3.5                          
         YAH   11000     2.0   Event E6 arrives
  4.0                          
  4.2                          
                                                 [IBM, 87.0]                            
                                                 [MSFT, 87.0]                           
                                                 [IBM, 87.0]                            
                                                 [YAH, 87.0]                            
                                                 [IBM, 87.0]                            
                                                 [YAH, 87.0]                            
  4.3                          
         IBM     150    22.0   Event E7 arrives
  4.9                          
         YAH   11500     3.0   Event E8 arrives
  5.0                          
  5.2                          
                                                 [IBM, 112.0]                           
                                                 [MSFT, 112.0]                          
                                                 [IBM, 112.0]                           
                                                 [YAH, 112.0]                           
                                                 [IBM, 112.0]                           
                                                 [YAH, 112.0]                           
                                                 [IBM, 112.0]                           
                                                 [YAH, 112.0]                           
  5.7                          Event E1 leaves the time window
  5.9                          
         YAH   10500     1.0   Event E9 arrives
  6.0                          
  6.2                          
                                                 [MSFT, 88.0]                           
                                                 [IBM, 88.0]                            
                                                 [YAH, 88.0]                            
                                                 [IBM, 88.0]                            
                                                 [YAH, 88.0]                            
                                                 [IBM, 88.0]                            
                                                 [YAH, 88.0]                            
                                                 [YAH, 88.0]                            
  6.3                          Event E2 leaves the time window
  7.0                          Event E3 and E4 leave the time window
  7.2                          
                                                 [IBM, 54.0]                            
                                                 [YAH, 54.0]                            
                                                 [IBM, 54.0]                            
                                                 [YAH, 54.0]                            
                                                 [YAH, 54.0]           			</pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="outputspec-groupedrowpergroup"></a>A.5.&nbsp;Output for Fully-aggregated and Grouped Queries</h2></div></div><div></div></div><p>
			This chapter provides sample output for queries that have aggregation functions, and that have a <tt class="literal">group by</tt> clause, and in which all event properties are under aggregation or appear in the <tt class="literal">group by</tt> clause.
        </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="outputspec-groupedrowpergroup-none"></a>A.5.1.&nbsp;No Output Rate Limiting</h3></div></div><div></div></div><p>
				The statement for this sample reads:
			</p><pre class="programlisting">select irstream symbol, sum(price) from MarketData.win:time(5.5 sec) 
group by symbol
order by symbol</pre><p>
				The output is as follows:
			</p><pre class="programlisting">                       Input                                  Output
                                                 Insert Stream    Remove Stream
-----------------------------------------------  ----------------------------------
 Time Symbol  Volume   Price
  0.2                          
         IBM     100    25.0   Event E1 arrives
                                                 [IBM, 25.0]        [IBM, null]         
  0.8                          
        MSFT    5000     9.0   Event E2 arrives
                                                 [MSFT, 9.0]        [MSFT, null]        
  1.0                          
  1.2                          
  1.5                          
         IBM     150    24.0   Event E3 arrives
                                                 [IBM, 49.0]        [IBM, 25.0]         
         YAH   10000     1.0   Event E4 arrives
                                                 [YAH, 1.0]         [YAH, null]         
  2.0                          
  2.1                          
         IBM     155    26.0   Event E5 arrives
                                                 [IBM, 75.0]        [IBM, 49.0]         
  2.2                          
  2.5                          
  3.0                          
  3.2                          
  3.5                          
         YAH   11000     2.0   Event E6 arrives
                                                 [YAH, 3.0]         [YAH, 1.0]          
  4.0                          
  4.2                          
  4.3                          
         IBM     150    22.0   Event E7 arrives
                                                 [IBM, 97.0]        [IBM, 75.0]         
  4.9                          
         YAH   11500     3.0   Event E8 arrives
                                                 [YAH, 6.0]         [YAH, 3.0]          
  5.0                          
  5.2                          
  5.7                          Event E1 leaves the time window
                                                 [IBM, 72.0]        [IBM, 97.0]         
  5.9                          
         YAH   10500     1.0   Event E9 arrives
                                                 [YAH, 7.0]         [YAH, 6.0]          
  6.0                          
  6.2                          
  6.3                          Event E2 leaves the time window
                                                 [MSFT, null]       [MSFT, 9.0]         
  7.0                          Event E3 and E4 leave the time window
                                                 [IBM, 48.0]        [IBM, 72.0]         
                                                 [YAH, 6.0]         [YAH, 7.0]          
  7.2                          		</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="outputspec-groupedrowpergroup-default"></a>A.5.2.&nbsp;Output Rate Limiting - Default</h3></div></div><div></div></div><p>
				The default (no keyword) and the <tt class="literal">ALL</tt> keyword do not result in the same output. The default generates an output row per input event, while the <tt class="literal">ALL</tt> keyword
				generates a row for all groups.
			</p><p>
				The statement for this sample reads:
			</p><pre class="programlisting">select irstream symbol, sum(price) from MarketData.win:time(5.5 sec) 
group by symbol 
output every 1 seconds</pre><p>
				The output is as follows:
			</p><pre class="programlisting">			                       Input                                  Output
                                                 Insert Stream    Remove Stream
-----------------------------------------------  ----------------------------------
 Time Symbol  Volume   Price
  0.2                          
         IBM     100    25.0   Event E1 arrives
  0.8                          
        MSFT    5000     9.0   Event E2 arrives
  1.0                          
  1.2                          
                                                 [IBM, 25.0]        [IBM, null]         
                                                 [MSFT, 9.0]        [MSFT, null]        
  1.5                          
         IBM     150    24.0   Event E3 arrives
         YAH   10000     1.0   Event E4 arrives
  2.0                          
  2.1                          
         IBM     155    26.0   Event E5 arrives
  2.2                          
                                                 [IBM, 49.0]        [IBM, 25.0]         
                                                 [YAH, 1.0]         [YAH, null]         
                                                 [IBM, 75.0]        [IBM, 49.0]         
  2.5                          
  3.0                          
  3.2                          
                                                 (empty result)     (empty result)      
  3.5                          
         YAH   11000     2.0   Event E6 arrives
  4.0                          
  4.2                          
                                                 [YAH, 3.0]         [YAH, 1.0]          
  4.3                          
         IBM     150    22.0   Event E7 arrives
  4.9                          
         YAH   11500     3.0   Event E8 arrives
  5.0                          
  5.2                          
                                                 [IBM, 97.0]        [IBM, 75.0]         
                                                 [YAH, 6.0]         [YAH, 3.0]          
  5.7                          Event E1 leaves the time window
  5.9                          
         YAH   10500     1.0   Event E9 arrives
  6.0                          
  6.2                          
                                                 [IBM, 72.0]        [IBM, 97.0]         
                                                 [YAH, 7.0]         [YAH, 6.0]          
  6.3                          Event E2 leaves the time window
  7.0                          Event E3 and E4 leave the time window
  7.2                          
                                                 [MSFT, null]       [MSFT, 9.0]         
                                                 [YAH, 6.0]         [YAH, 7.0]          
                                                 [IBM, 48.0]        [IBM, 72.0]  </pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="outputspec-groupedrowpergroup-all"></a>A.5.3.&nbsp;Output Rate Limiting - All</h3></div></div><div></div></div><p>
				The statement for this sample reads:
			</p><pre class="programlisting">select irstream symbol, sum(price) from MarketData.win:time(5.5 sec) 
group by symbol 
output all every 1 seconds 
order by symbol</pre><p>
				The output is as follows:
			</p><pre class="programlisting">                       Input                                  Output
                                                 Insert Stream    Remove Stream
-----------------------------------------------  ----------------------------------
 Time Symbol  Volume   Price
  0.2                          
         IBM     100    25.0   Event E1 arrives
  0.8                          
        MSFT    5000     9.0   Event E2 arrives
  1.0                          
  1.2                          
                                                 [IBM, 25.0]        [IBM, null]         
                                                 [MSFT, 9.0]        [MSFT, null]        
  1.5                          
         IBM     150    24.0   Event E3 arrives
         YAH   10000     1.0   Event E4 arrives
  2.0                          
  2.1                          
         IBM     155    26.0   Event E5 arrives
  2.2                          
                                                 [IBM, 75.0]        [IBM, 25.0]         
                                                 [MSFT, 9.0]        [MSFT, 9.0]         
                                                 [YAH, 1.0]         [YAH, null]         
  2.5                          
  3.0                          
  3.2                          
                                                 [IBM, 75.0]        [IBM, 75.0]         
                                                 [MSFT, 9.0]        [MSFT, 9.0]         
                                                 [YAH, 1.0]         [YAH, 1.0]          
  3.5                          
         YAH   11000     2.0   Event E6 arrives
  4.0                          
  4.2                          
                                                 [IBM, 75.0]        [IBM, 75.0]         
                                                 [MSFT, 9.0]        [MSFT, 9.0]         
                                                 [YAH, 3.0]         [YAH, 1.0]          
  4.3                          
         IBM     150    22.0   Event E7 arrives
  4.9                          
         YAH   11500     3.0   Event E8 arrives
  5.0                          
  5.2                          
                                                 [IBM, 97.0]        [IBM, 75.0]         
                                                 [MSFT, 9.0]        [MSFT, 9.0]         
                                                 [YAH, 6.0]         [YAH, 3.0]          
  5.7                          Event E1 leaves the time window
  5.9                          
         YAH   10500     1.0   Event E9 arrives
  6.0                          
  6.2                          
                                                 [IBM, 72.0]        [IBM, 97.0]         
                                                 [MSFT, 9.0]        [MSFT, 9.0]         
                                                 [YAH, 7.0]         [YAH, 6.0]          
  6.3                          Event E2 leaves the time window
  7.0                          Event E3 and E4 leave the time window
  7.2                          
                                                 [IBM, 48.0]        [IBM, 72.0]         
                                                 [MSFT, null]       [MSFT, 9.0]         
                                                 [YAH, 6.0]         [YAH, 7.0]  			 </pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="outputspec-groupedrowpergroup-last"></a>A.5.4.&nbsp;Output Rate Limiting - Last</h3></div></div><div></div></div><p>
				The statement for this sample reads:
			</p><pre class="programlisting">select irstream symbol, sum(price) from MarketData.win:time(5.5 sec)
group by symbol 
output last every 1 seconds 
order by symbol</pre><p>
				The output is as follows:
			</p><pre class="programlisting">                       Input                                  Output
                                                 Insert Stream    Remove Stream
-----------------------------------------------  ----------------------------------
 Time Symbol  Volume   Price
  0.2                          
         IBM     100    25.0   Event E1 arrives
  0.8                          
        MSFT    5000     9.0   Event E2 arrives
  1.0                          
  1.2                          
                                                 [IBM, 25.0]        [IBM, null]         
                                                 [MSFT, 9.0]        [MSFT, null]        
  1.5                          
         IBM     150    24.0   Event E3 arrives
         YAH   10000     1.0   Event E4 arrives
  2.0                          
  2.1                          
         IBM     155    26.0   Event E5 arrives
  2.2                          
                                                 [IBM, 75.0]        [IBM, 25.0]         
                                                 [YAH, 1.0]         [YAH, null]         
  2.5                          
  3.0                          
  3.2                          
                                                 (empty result)     (empty result)      
  3.5                          
         YAH   11000     2.0   Event E6 arrives
  4.0                          
  4.2                          
                                                 [YAH, 3.0]         [YAH, 1.0]          
  4.3                          
         IBM     150    22.0   Event E7 arrives
  4.9                          
         YAH   11500     3.0   Event E8 arrives
  5.0                          
  5.2                          
                                                 [IBM, 97.0]        [IBM, 75.0]         
                                                 [YAH, 6.0]         [YAH, 3.0]          
  5.7                          Event E1 leaves the time window
  5.9                          
         YAH   10500     1.0   Event E9 arrives
  6.0                          
  6.2                          
                                                 [IBM, 72.0]        [IBM, 97.0]         
                                                 [YAH, 7.0]         [YAH, 6.0]          
  6.3                          Event E2 leaves the time window
  7.0                          Event E3 and E4 leave the time window
  7.2                          
                                                 [IBM, 48.0]        [IBM, 72.0]         
                                                 [MSFT, null]       [MSFT, 9.0]         
                                                 [YAH, 6.0]         [YAH, 7.0]     			 </pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="outputspec-groupedrowpergroup-first"></a>A.5.5.&nbsp;Output Rate Limiting - First</h3></div></div><div></div></div><p>
				The statement for this sample reads:
			</p><pre class="programlisting">select irstream symbol, sum(price) from MarketData.win:time(5.5 sec)
group by symbol
output first every 1 seconds
			</pre><p>
				The output is as follows:
			</p><pre class="programlisting">                       Input                                  Output
                                                 Insert Stream    Remove Stream
-----------------------------------------------  ----------------------------------
 Time Symbol  Volume   Price
  0.2                          
         IBM     100    25.0   Event E1 arrives
                                                 [IBM, 25.0]        [IBM, null]         
  0.8                          
        MSFT    5000     9.0   Event E2 arrives
  1.0                          
  1.2                          
  1.5                          
         IBM     150    24.0   Event E3 arrives
                                                 [IBM, 49.0]        [IBM, 25.0]         
         YAH   10000     1.0   Event E4 arrives
  2.0                          
  2.1                          
         IBM     155    26.0   Event E5 arrives
  2.2                          
  2.5                          
  3.0                          
  3.2                          
                                                 (empty result)     (empty result)      
  3.5                          
         YAH   11000     2.0   Event E6 arrives
                                                 [YAH, 3.0]         [YAH, 1.0]          
  4.0                          
  4.2                          
  4.3                          
         IBM     150    22.0   Event E7 arrives
                                                 [IBM, 97.0]        [IBM, 75.0]         
  4.9                          
         YAH   11500     3.0   Event E8 arrives
  5.0                          
  5.2                          
  5.7                          Event E1 leaves the time window
                                                 [IBM, 72.0]        [IBM, 97.0]         
  5.9                          
         YAH   10500     1.0   Event E9 arrives
  6.0                          
  6.2                          
  6.3                          Event E2 leaves the time window
                                                 [MSFT, null]       [MSFT, 9.0]         
  7.0                          Event E3 and E4 leave the time window
  7.2                          			</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="outputspec-groupedrowpergroup-snapshot"></a>A.5.6.&nbsp;Output Rate Limiting - Snapshot</h3></div></div><div></div></div><p>
				The statement for this sample reads:
			</p><pre class="programlisting">select irstream symbol, sum(price) from MarketData.win:time(5.5 sec) 
group by symbol 
output snapshot every 1 seconds 
order by symbol</pre><p>
				The output is as follows:
			</p><pre class="programlisting">                       Input                                  Output
                                                 Insert Stream    Remove Stream
-----------------------------------------------  ----------------------------------
 Time Symbol  Volume   Price
  0.2                          
         IBM     100    25.0   Event E1 arrives
  0.8                          
        MSFT    5000     9.0   Event E2 arrives
  1.0                          
  1.2                          
                                                 [IBM, 25.0]                            
                                                 [MSFT, 9.0]                            
  1.5                          
         IBM     150    24.0   Event E3 arrives
         YAH   10000     1.0   Event E4 arrives
  2.0                          
  2.1                          
         IBM     155    26.0   Event E5 arrives
  2.2                          
                                                 [IBM, 75.0]                            
                                                 [MSFT, 9.0]                            
                                                 [YAH, 1.0]                             
  2.5                          
  3.0                          
  3.2                          
                                                 [IBM, 75.0]                            
                                                 [MSFT, 9.0]                            
                                                 [YAH, 1.0]                             
  3.5                          
         YAH   11000     2.0   Event E6 arrives
  4.0                          
  4.2                          
                                                 [IBM, 75.0]                            
                                                 [MSFT, 9.0]                            
                                                 [YAH, 3.0]                             
  4.3                          
         IBM     150    22.0   Event E7 arrives
  4.9                          
         YAH   11500     3.0   Event E8 arrives
  5.0                          
  5.2                          
                                                 [IBM, 97.0]                            
                                                 [MSFT, 9.0]                            
                                                 [YAH, 6.0]                             
  5.7                          Event E1 leaves the time window
  5.9                          
         YAH   10500     1.0   Event E9 arrives
  6.0                          
  6.2                          
                                                 [IBM, 72.0]                            
                                                 [MSFT, 9.0]                            
                                                 [YAH, 7.0]                             
  6.3                          Event E2 leaves the time window
  7.0                          Event E3 and E4 leave the time window
  7.2                          
                                                 [IBM, 48.0]                            
                                                 [YAH, 6.0]    			</pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="outputspec-aggregategrouped"></a>A.6.&nbsp;Output for Aggregated and Grouped Queries</h2></div></div><div></div></div><p>
			This chapter provides sample output for queries that have aggregation functions, and that have a <tt class="literal">group by</tt> clause, and in which some event properties are not under aggregation.
        </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="outputspec-aggregategrouped-none"></a>A.6.1.&nbsp;No Output Rate Limiting</h3></div></div><div></div></div><p>
				The statement for this sample reads:
			</p><pre class="programlisting">select irstream symbol, volume, sum(price) from MarketData.win:time(5.5 sec) group by symbol</pre><p>
				The output is as follows:
			</p><pre class="programlisting">                       Input                                  Output
                                                 Insert Stream    Remove Stream
-----------------------------------------------  ----------------------------------
 Time Symbol  Volume   Price
  0.2                          
         IBM     100    25.0   Event E1 arrives
                                                 [IBM, 100, 25.0]                       
  0.8                          
        MSFT    5000     9.0   Event E2 arrives
                                                 [MSFT, 5000, 9.0]                      
  1.0                          
  1.2                          
  1.5                          
         IBM     150    24.0   Event E3 arrives
                                                 [IBM, 150, 49.0]                       
         YAH   10000     1.0   Event E4 arrives
                                                 [YAH, 10000, 1.0]                      
  2.0                          
  2.1                          
         IBM     155    26.0   Event E5 arrives
                                                 [IBM, 155, 75.0]                       
  2.2                          
  2.5                          
  3.0                          
  3.2                          
  3.5                          
         YAH   11000     2.0   Event E6 arrives
                                                 [YAH, 11000, 3.0]                      
  4.0                          
  4.2                          
  4.3                          
         IBM     150    22.0   Event E7 arrives
                                                 [IBM, 150, 97.0]                       
  4.9                          
         YAH   11500     3.0   Event E8 arrives
                                                 [YAH, 11500, 6.0]                      
  5.0                          
  5.2                          
  5.7                          Event E1 leaves the time window
                                                                    [IBM, 100, 72.0]    
  5.9                          
         YAH   10500     1.0   Event E9 arrives
                                                 [YAH, 10500, 7.0]                      
  6.0                          
  6.2                          
  6.3                          Event E2 leaves the time window
                                                                    [MSFT, 5000, null]  
  7.0                          Event E3 and E4 leave the time window
                                                                    [IBM, 150, 48.0]    
                                                                    [YAH, 10000, 6.0]   
  7.2                          			</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="outputspec-aggregategrouped-default"></a>A.6.2.&nbsp;Output Rate Limiting - Default</h3></div></div><div></div></div><p>
				The default (no keyword) and the <tt class="literal">ALL</tt> keyword do not result in the same output. The default generates an output row per input event, while the <tt class="literal">ALL</tt> keyword
				generates a row for all groups based on the last new event for each group.
			</p><p>
				The statement for this sample reads:
			</p><pre class="programlisting">select irstream symbol, volume, sum(price) from MarketData.win:time(5.5 sec) 
group by symbol 
output every 1 seconds</pre><p>
				The output is as follows:
			</p><pre class="programlisting">                       Input                                  Output
                                                 Insert Stream    Remove Stream
-----------------------------------------------  ----------------------------------
 Time Symbol  Volume   Price
  0.2                          
         IBM     100    25.0   Event E1 arrives
  0.8                          
        MSFT    5000     9.0   Event E2 arrives
  1.0                          
  1.2                          
                                                 [IBM, 100, 25.0]                       
                                                 [MSFT, 5000, 9.0]                      
  1.5                          
         IBM     150    24.0   Event E3 arrives
         YAH   10000     1.0   Event E4 arrives
  2.0                          
  2.1                          
         IBM     155    26.0   Event E5 arrives
  2.2                          
                                                 [IBM, 150, 49.0]                       
                                                 [YAH, 10000, 1.0]                      
                                                 [IBM, 155, 75.0]                       
  2.5                          
  3.0                          
  3.2                          
                                                 (empty result)     (empty result)      
  3.5                          
         YAH   11000     2.0   Event E6 arrives
  4.0                          
  4.2                          
                                                 [YAH, 11000, 3.0]                      
  4.3                          
         IBM     150    22.0   Event E7 arrives
  4.9                          
         YAH   11500     3.0   Event E8 arrives
  5.0                          
  5.2                          
                                                 [IBM, 150, 97.0]                       
                                                 [YAH, 11500, 6.0]                      
  5.7                          Event E1 leaves the time window
  5.9                          
         YAH   10500     1.0   Event E9 arrives
  6.0                          
  6.2                          
                                                 [YAH, 10500, 7.0]  [IBM, 100, 72.0]    
  6.3                          Event E2 leaves the time window
  7.0                          Event E3 and E4 leave the time window
  7.2                          
                                                                    [MSFT, 5000, null]  
                                                                    [IBM, 150, 48.0]    
                                                                    [YAH, 10000, 6.0]   			</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="outputspec-aggregategrouped-all"></a>A.6.3.&nbsp;Output Rate Limiting - All</h3></div></div><div></div></div><p>
				The statement for this sample reads:
			</p><pre class="programlisting">select irstream symbol, volume, sum(price) from MarketData.win:time(5.5 sec) 
group by symbol 
output all every 1 seconds 
order by symbol</pre><p>
				The output is as follows:
			</p><pre class="programlisting">                       Input                                  Output
                                                 Insert Stream    Remove Stream
-----------------------------------------------  ----------------------------------
 Time Symbol  Volume   Price
  0.2                          
         IBM     100    25.0   Event E1 arrives
  0.8                          
        MSFT    5000     9.0   Event E2 arrives
  1.0                          
  1.2                          
                                                 [IBM, 100, 25.0]                       
                                                 [MSFT, 5000, 9.0]                      
  1.5                          
         IBM     150    24.0   Event E3 arrives
         YAH   10000     1.0   Event E4 arrives
  2.0                          
  2.1                          
         IBM     155    26.0   Event E5 arrives
  2.2                          
                                                 [IBM, 150, 49.0]                       
                                                 [IBM, 155, 75.0]                       
                                                 [MSFT, 5000, 9.0]                      
                                                 [YAH, 10000, 1.0]                      
  2.5                          
  3.0                          
  3.2                          
                                                 [IBM, 155, 75.0]                       
                                                 [MSFT, 5000, 9.0]                      
                                                 [YAH, 10000, 1.0]                      
  3.5                          
         YAH   11000     2.0   Event E6 arrives
  4.0                          
  4.2                          
                                                 [IBM, 155, 75.0]                       
                                                 [MSFT, 5000, 9.0]                      
                                                 [YAH, 11000, 3.0]                      
  4.3                          
         IBM     150    22.0   Event E7 arrives
  4.9                          
         YAH   11500     3.0   Event E8 arrives
  5.0                          
  5.2                          
                                                 [IBM, 150, 97.0]                       
                                                 [MSFT, 5000, 9.0]                      
                                                 [YAH, 11500, 6.0]                      
  5.7                          Event E1 leaves the time window
  5.9                          
         YAH   10500     1.0   Event E9 arrives
  6.0                          
  6.2                          
                                                 [IBM, 150, 72.0]   [IBM, 100, 72.0]    
                                                 [MSFT, 5000, 9.0]                      
                                                 [YAH, 10500, 7.0]                      
  6.3                          Event E2 leaves the time window
  7.0                          Event E3 and E4 leave the time window
  7.2                          
                                                 [IBM, 150, 48.0]   [IBM, 150, 48.0]    
                                                 [MSFT, 5000, null] [MSFT, 5000, null]  
                                                 [YAH, 10500, 6.0]  [YAH, 10000, 6.0]   </pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="outputspec-aggregategrouped-last"></a>A.6.4.&nbsp;Output Rate Limiting - Last</h3></div></div><div></div></div><p>
				The statement for this sample reads:
			</p><pre class="programlisting">select irstream symbol, volume, sum(price) from MarketData.win:time(5.5 sec)
group by symbol 
output last every 1 seconds 
order by symbol</pre><p>
				The output is as follows:
			</p><pre class="programlisting">                       Input                                  Output
                                                 Insert Stream    Remove Stream
-----------------------------------------------  ----------------------------------
 Time Symbol  Volume   Price
  0.2                          
         IBM     100    25.0   Event E1 arrives
  0.8                          
        MSFT    5000     9.0   Event E2 arrives
  1.0                          
  1.2                          
                                                 [IBM, 100, 25.0]                       
                                                 [MSFT, 5000, 9.0]                      
  1.5                          
         IBM     150    24.0   Event E3 arrives
         YAH   10000     1.0   Event E4 arrives
  2.0                          
  2.1                          
         IBM     155    26.0   Event E5 arrives
  2.2                          
                                                 [IBM, 155, 75.0]                       
                                                 [YAH, 10000, 1.0]                      
  2.5                          
  3.0                          
  3.2                          
                                                 (empty result)     (empty result)      
  3.5                          
         YAH   11000     2.0   Event E6 arrives
  4.0                          
  4.2                          
                                                 [YAH, 11000, 3.0]                      
  4.3                          
         IBM     150    22.0   Event E7 arrives
  4.9                          
         YAH   11500     3.0   Event E8 arrives
  5.0                          
  5.2                          
                                                 [IBM, 150, 97.0]                       
                                                 [YAH, 11500, 6.0]                      
  5.7                          Event E1 leaves the time window
  5.9                          
         YAH   10500     1.0   Event E9 arrives
  6.0                          
  6.2                          
                                                 [YAH, 10500, 7.0]  [IBM, 100, 72.0]    
  6.3                          Event E2 leaves the time window
  7.0                          Event E3 and E4 leave the time window
  7.2                          
                                                                    [IBM, 150, 48.0]    
                                                                    [MSFT, 5000, null]  
                                                                    [YAH, 10000, 6.0] </pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="outputspec-aggregategrouped-first"></a>A.6.5.&nbsp;Output Rate Limiting - First</h3></div></div><div></div></div><p>
				The statement for this sample reads:
			</p><pre class="programlisting">select irstream symbol, volume, sum(price) from MarketData.win:time(5.5 sec) 
group by symbol 
output first every 1 seconds</pre><p>
				The output is as follows:
			</p><pre class="programlisting">                       Input                                  Output
                                                 Insert Stream    Remove Stream
-----------------------------------------------  ----------------------------------
 Time Symbol  Volume   Price
  0.2                          
         IBM     100    25.0   Event E1 arrives
                                                 [IBM, 100, 25.0]                       
  0.8                          
        MSFT    5000     9.0   Event E2 arrives
  1.0                          
  1.2                          
  1.5                          
         IBM     150    24.0   Event E3 arrives
                                                 [IBM, 150, 49.0]                       
         YAH   10000     1.0   Event E4 arrives
  2.0                          
  2.1                          
         IBM     155    26.0   Event E5 arrives
  2.2                          
  2.5                          
  3.0                          
  3.2                          
                                                 (empty result)     (empty result)      
  3.5                          
         YAH   11000     2.0   Event E6 arrives
                                                 [YAH, 11000, 3.0]                      
  4.0                          
  4.2                          
  4.3                          
         IBM     150    22.0   Event E7 arrives
                                                 [IBM, 150, 97.0]                       
  4.9                          
         YAH   11500     3.0   Event E8 arrives
  5.0                          
  5.2                          
  5.7                          Event E1 leaves the time window
                                                                    [IBM, 100, 72.0]    
  5.9                          
         YAH   10500     1.0   Event E9 arrives
  6.0                          
  6.2                          
  6.3                          Event E2 leaves the time window
                                                                    [MSFT, 5000, null]  
  7.0                          Event E3 and E4 leave the time window
  7.2                          		 </pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="outputspec-aggregategrouped-snapshot"></a>A.6.6.&nbsp;Output Rate Limiting - Snapshot</h3></div></div><div></div></div><p>
				The statement for this sample reads:
			</p><pre class="programlisting">select irstream symbol, volume, sum(price) from MarketData.win:time(5.5 sec) 
group by symbol 
output snapshot every 1 seconds</pre><p>
				The output is as follows:
			</p><pre class="programlisting">                       Input                                  Output
                                                 Insert Stream    Remove Stream
-----------------------------------------------  ----------------------------------
 Time Symbol  Volume   Price
  0.2                          
         IBM     100    25.0   Event E1 arrives
  0.8                          
        MSFT    5000     9.0   Event E2 arrives
  1.0                          
  1.2                          
                                                 [IBM, 100, 25.0]                       
                                                 [MSFT, 5000, 9.0]                      
  1.5                          
         IBM     150    24.0   Event E3 arrives
         YAH   10000     1.0   Event E4 arrives
  2.0                          
  2.1                          
         IBM     155    26.0   Event E5 arrives
  2.2                          
                                                 [IBM, 100, 75.0]                       
                                                 [MSFT, 5000, 9.0]                      
                                                 [IBM, 150, 75.0]                       
                                                 [YAH, 10000, 1.0]                      
                                                 [IBM, 155, 75.0]                       
  2.5                          
  3.0                          
  3.2                          
                                                 [IBM, 100, 75.0]                       
                                                 [MSFT, 5000, 9.0]                      
                                                 [IBM, 150, 75.0]                       
                                                 [YAH, 10000, 1.0]                      
                                                 [IBM, 155, 75.0]                       
  3.5                          
         YAH   11000     2.0   Event E6 arrives
  4.0                          
  4.2                          
                                                 [IBM, 100, 75.0]                       
                                                 [MSFT, 5000, 9.0]                      
                                                 [IBM, 150, 75.0]                       
                                                 [YAH, 10000, 3.0]                      
                                                 [IBM, 155, 75.0]                       
                                                 [YAH, 11000, 3.0]                      
  4.3                          
         IBM     150    22.0   Event E7 arrives
  4.9                          
         YAH   11500     3.0   Event E8 arrives
  5.0                          
  5.2                          
                                                 [IBM, 100, 97.0]                       
                                                 [MSFT, 5000, 9.0]                      
                                                 [IBM, 150, 97.0]                       
                                                 [YAH, 10000, 6.0]                      
                                                 [IBM, 155, 97.0]                       
                                                 [YAH, 11000, 6.0]                      
                                                 [IBM, 150, 97.0]                       
                                                 [YAH, 11500, 6.0]                      
  5.7                          Event E1 leaves the time window
  5.9                          
         YAH   10500     1.0   Event E9 arrives
  6.0                          
  6.2                          
                                                 [MSFT, 5000, 9.0]                      
                                                 [IBM, 150, 72.0]                       
                                                 [YAH, 10000, 7.0]                      
                                                 [IBM, 155, 72.0]                       
                                                 [YAH, 11000, 7.0]                      
                                                 [IBM, 150, 72.0]                       
                                                 [YAH, 11500, 7.0]                      
                                                 [YAH, 10500, 7.0]                      
  6.3                          Event E2 leaves the time window
  7.0                          Event E3 and E4 leave the time window
  7.2                          
                                                 [IBM, 155, 48.0]                       
                                                 [YAH, 11000, 6.0]                      
                                                 [IBM, 150, 48.0]                       
                                                 [YAH, 11500, 6.0]                      
                                                 [YAH, 10500, 6.0]  </pre></div></div></div><div class="appendix" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="appendix_keywords"></a>Appendix&nbsp;B.&nbsp;Reserved Keywords</h2></div></div><div></div></div><p>
		The words in the following table are explicitly reserved in EPL, however certain keywords are allowed as event property names in expressions and as column names in the rename syntax of the <tt class="literal">select</tt> clause. 
	</p><p>
		Most of the words in the table are forbidden by standard SQL as well. A few are reserved because EPL needs them.
	</p><p>
		Names of built-in functions and certain auxiliary keywords are permitted as identifiers for use either as event property names in expressions and for the column rename syntax. The second column in the table below indicates which keywords are acceptable. For example, <tt class="literal">count</tt> is acceptable.
	</p><p>
		An example of permitted use is:
	</p><pre class="programlisting">select last, count(*) as count from MyEvent</pre><p>
		This example shows an incorrect use of a reserved keyword:
	</p><pre class="programlisting">// incorrect
select insert from MyEvent</pre><p>
		The table of explicitly reserved keywords and permitted keywords:
	</p><div class="table"><a name="d0e21608"></a><p class="title"><b>Table&nbsp;B.1.&nbsp;Reserved Keywords</b></p><table summary="Reserved Keywords" border="1"><colgroup><col><col></colgroup><thead><tr><th>Keyword</th><th>Property Name and Rename Syntax</th></tr></thead><tbody><tr><td>all</td><td>-</td></tr><tr><td>and</td><td>-</td></tr><tr><td>as</td><td>-</td></tr><tr><td>at</td><td>yes</td></tr><tr><td>asc</td><td>-</td></tr><tr><td>avedev</td><td>yes</td></tr><tr><td>avg</td><td>yes</td></tr><tr><td>between</td><td>-</td></tr><tr><td>by</td><td>-</td></tr><tr><td>case</td><td>-</td></tr><tr><td>cast</td><td>yes</td></tr><tr><td>coalesce</td><td>yes</td></tr><tr><td>count</td><td>yes</td></tr><tr><td>create</td><td>-</td></tr><tr><td>current_timestamp</td><td>-</td></tr><tr><td>day</td><td>-</td></tr><tr><td>days</td><td>-</td></tr><tr><td>delete</td><td>-</td></tr><tr><td>desc</td><td>-</td></tr><tr><td>distinct</td><td>-</td></tr><tr><td>else</td><td>-</td></tr><tr><td>end</td><td>-</td></tr><tr><td>escape</td><td>yes</td></tr><tr><td>events</td><td>yes</td></tr><tr><td>every</td><td>yes</td></tr><tr><td>exists</td><td>-</td></tr><tr><td>false</td><td>yes</td></tr><tr><td>first</td><td>yes</td></tr><tr><td>from</td><td>-</td></tr><tr><td>full</td><td>yes</td></tr><tr><td>group</td><td>-</td></tr><tr><td>having</td><td>-</td></tr><tr><td>hour</td><td>-</td></tr><tr><td>hours</td><td>-</td></tr><tr><td>in</td><td>-</td></tr><tr><td>inner</td><td>-</td></tr><tr><td>insert</td><td>-</td></tr><tr><td>instanceof</td><td>yes</td></tr><tr><td>into</td><td>-</td></tr><tr><td>irstream</td><td>-</td></tr><tr><td>is</td><td>-</td></tr><tr><td>istream</td><td>-</td></tr><tr><td>join</td><td>yes</td></tr><tr><td>last</td><td>yes</td></tr><tr><td>lastweekday</td><td>yes</td></tr><tr><td>left</td><td>yes</td></tr><tr><td>limit</td><td>-</td></tr><tr><td>like</td><td>-</td></tr><tr><td>max</td><td>yes</td></tr><tr><td>median</td><td>yes</td></tr><tr><td>metadatasql</td><td>yes</td></tr><tr><td>min</td><td>yes</td></tr><tr><td>minute</td><td>yes</td></tr><tr><td>minutes</td><td>yes</td></tr><tr><td>msec</td><td>yes</td></tr><tr><td>millisecond</td><td>yes</td></tr><tr><td>milliseconds</td><td>yes</td></tr><tr><td>not</td><td>-</td></tr><tr><td>null</td><td>-</td></tr><tr><td>offset</td><td>-</td></tr><tr><td>on</td><td>-</td></tr><tr><td>or</td><td>-</td></tr><tr><td>order</td><td>-</td></tr><tr><td>outer</td><td>yes</td></tr><tr><td>output</td><td>-</td></tr><tr><td>pattern</td><td>yes</td></tr><tr><td>prev</td><td>yes</td></tr><tr><td>prior</td><td>yes</td></tr><tr><td>regexp</td><td>-</td></tr><tr><td>retain-union</td><td>yes</td></tr><tr><td>retain-intersection</td><td>yes</td></tr><tr><td>right</td><td>yes</td></tr><tr><td>rstream</td><td>-</td></tr><tr><td>sec</td><td>-</td></tr><tr><td>second</td><td>-</td></tr><tr><td>seconds</td><td>-</td></tr><tr><td>select</td><td>-</td></tr><tr><td>set</td><td>-</td></tr><tr><td>snapshot</td><td>yes</td></tr><tr><td>sql</td><td>yes</td></tr><tr><td>stddev</td><td>yes</td></tr><tr><td>sum</td><td>yes</td></tr><tr><td>then</td><td>-</td></tr><tr><td>true</td><td>-</td></tr><tr><td>unidirectional</td><td>yes</td></tr><tr><td>until</td><td>yes</td></tr><tr><td>variable</td><td>yes</td></tr><tr><td>weekday</td><td>yes</td></tr><tr><td>when</td><td>-</td></tr><tr><td>where</td><td>-</td></tr><tr><td>window</td><td>yes</td></tr></tbody></table></div></div><div class="index"><div class="titlepage"><div><div><h2 class="title"><a name="d0e22076"></a>Index</h2></div></div><div></div></div><div class="index"><div class="indexdiv"><h3>Symbols</h3><dl><dt>-&gt; pattern operator, <a href="#pattern-temporal-followed-by">Followed-by</a></dt></dl></div><div class="indexdiv"><h3>A</h3><dl><dt>aggregation functions</dt><dd><dl><dt>custom plug-in, <a href="#custom-aggregation-function">Custom Aggregation Functions</a></dt><dt>overview, <a href="#epl-function-aggregation">Aggregate Functions</a></dt></dl></dd><dt>and pattern operator, <a href="#pattern-logical-and">And</a></dt><dt>annotation, <a href="#epl-syntax-annotation">Annotation</a></dt><dd><dl><dt>application-provided, <a href="#epl-syntax-annotation-application">Application-Provided Annotations</a></dt><dt>builtin, <a href="#epl-syntax-annotation-builtin">Built-In Annotations</a></dt></dl></dd><dt>arithmetic operators, <a href="#epl-operator-ref-arithmetic">Arithmetic Operators</a></dt><dt>array definition operator, <a href="#epl-operator-ref-array">Array Definition Operator</a></dt></dl></div><div class="indexdiv"><h3>B</h3><dl><dt>between operator, <a href="#epl-operator-ref-keyword-between">The 'between' Keyword</a></dt><dt>binary operators, <a href="#epl-operator-ref-binary">Binary Operators</a></dt></dl></div><div class="indexdiv"><h3>C</h3><dl><dt>case control flow function, <a href="#epl-single-row-function-ref-case">The Case Control Flow Function</a></dt><dt>cast function, <a href="#epl-single-row-function-cast">The Cast Function</a></dt><dt>coalesce function, <a href="#epl-single-row-function-ref-coalesce">The Coalesce Function</a></dt><dt>concatenation operators, <a href="#epl-operator-ref-string">Concatenation Operators</a></dt><dt>configuration</dt><dd><dl><dt>items to configure, <a href="#configuration-items">Configuration Items</a></dt><dt>overview, <a href="#configuration">Configuration</a></dt><dt>programmatic, <a href="#configuration-programmatic">Programmatic Configuration</a></dt><dt>runtime, <a href="#api-admin-runtime-config">Runtime Configuration</a>, <a href="#configuration-runtime">Runtime Configuration</a></dt><dt>via XML, <a href="#configuration-via-xml">Configuration via XML File</a></dt></dl></dd><dt>Configuration class, <a href="#configuration">Configuration</a></dt><dt>constants, <a href="#event-properties-const">Constants and Enumeration</a>, <a href="#epl-syntax-datatype-constants">Data Type of Constants</a></dt><dt>correlation view, <a href="#view-stat-correl">Correlation (stat:correl)</a></dt><dt>create window, insert, <a href="#named_populate_named">Populating a Named Window from an Existing Named Window</a></dt><dt>current_timestamp function, <a href="#epl-single-row-function-ref-currenttime">The Current_Timestamp Function</a></dt></dl></div><div class="indexdiv"><h3>D</h3><dl><dt>data types, <a href="#epl-syntax-datatype">Data Types</a></dt><dt>data window views</dt><dd><dl><dt>custom plug-in view, <a href="#custom-views">Custom View Implementation</a></dt><dt>externally-timed window, <a href="#view-win-ext_time">Externally-timed window (win:ext_timed)</a></dt><dt>group-by window, <a href="#view-std-groupby">Group-By (std:groupby)</a></dt><dt>keep-all window, <a href="#view-win-keepall">Keep-All window (win:keepall)</a></dt><dt>last event window, <a href="#view-std-last">Last Event (std:lastevent)</a></dt><dt>length batch window, <a href="#view-win-length-batch">Length batch window (win:length_batch)</a></dt><dt>length window, <a href="#view-win-length">Length window (win:length)</a></dt><dt>overview, <a href="#epl-views">EPL Reference: Views</a></dt><dt>size window, <a href="#view-std-size">Size (std:size)</a></dt><dt>sorted window, <a href="#view-ext-sort">Sorted Window View (ext:sort)</a></dt><dt>time batch window, <a href="#view-win-time-batch">Time batch window (win:time_batch)</a></dt><dt>time length batch window, <a href="#view-win-time-length-batch">Time-Length combination batch window (win:time_length_batch)</a></dt><dt>time window, <a href="#view-win-time">Time window (win:time)</a></dt><dt>time-accumulating window, <a href="#view-win-time-accumulating">Time-Accumulating window (win:time_accum)</a></dt><dt>time-order window, <a href="#view-time-order">Time-Order View (ext:time_order)</a></dt><dt>unique window, <a href="#view-std-unique">Unique (std:unique)</a></dt></dl></dd><dt>decorated event, <a href="#insert-into-decorated">Decorated Events</a></dt><dt>derived-value views</dt><dd><dl><dt>correlation, <a href="#view-stat-correl">Correlation (stat:correl)</a></dt><dt>overview, <a href="#epl-views">EPL Reference: Views</a></dt><dt>regression, <a href="#view-stat-linest">Regression (stat:linest)</a></dt><dt>univariate statistics, <a href="#view-stat-uni">Univariate statistics (stat:uni)</a></dt><dt>weighted average, <a href="#view-stat-weightedavg">Weighted average (stat:weighted_avg)</a></dt></dl></dd><dt>dynamic event properties, <a href="#eventrep-dyncproperties">Dynamic Event Properties</a></dt></dl></div><div class="indexdiv"><h3>E</h3><dl><dt>enumeration, <a href="#event-properties-const">Constants and Enumeration</a></dt><dt>EPAdministrator interface, <a href="#api-administrative">The Administrative Interface</a></dt><dt>EPL</dt><dd><dl><dt>from clause, <a href="#epl-from-clause">Specifying Event Streams: the From Clause</a></dt><dt>group by clause, <a href="#epl-grouping-group-by">Organizing statement results into groups: the Group-by clause</a></dt><dt>having clause, <a href="#epl-grouping-having">Selecting groups of events: the Having clause</a></dt><dt>inner join, <a href="#epl-outerjoin">Outer and Inner Joins</a></dt><dt>insert into clause, <a href="#epl-insert-into">Merging Streams and Continuous Insertion: the Insert Into Clause</a></dt><dt>join, <a href="#epl-join">Joining Event Streams</a></dt><dt>join, unidirectional, <a href="#epl-unidirectional">Unidirectional Joins</a></dt><dt>joining non-relational data via method invocation, <a href="#joining_method">Accessing Non-Relational Data via Method Invocation</a></dt><dt>joining relational data via SQL, <a href="#histdata_overview">Accessing Relational Data via SQL</a></dt><dt>limit clause, <a href="#epl-limit">Limiting Row Count: the Limit Clause</a></dt><dt>named window, <a href="#named_overview">Creating and Using Named Windows</a></dt><dd><dl><dt>deleting from, <a href="#named_delete">Deleting From Named Windows: the On Delete clause</a></dt><dt>inserting into, <a href="#named_inserting">Inserting Into Named Windows</a></dt><dt>populating from a named window, <a href="#named_populate_named">Populating a Named Window from an Existing Named Window</a></dt><dt>selecting from, <a href="#named_selecting">Selecting From Named Windows</a></dt><dt>triggered playback using On Insert, <a href="#named_playback">Triggered Playback from Named Windows: the On Insert clause</a></dt><dt>triggered select using On Select, <a href="#named_querying">Triggered Select on Named Windows: the On Select clause</a></dt></dl></dd><dt>order by clause, <a href="#epl-order-by">Sorting Output: the Order By Clause</a></dt><dt>outer join, <a href="#epl-outerjoin">Outer and Inner Joins</a></dt><dt>outer join, unidirectional, <a href="#epl-unidirectional">Unidirectional Joins</a></dt><dt>output control and stabilizing, <a href="#epl-output-rate">Stabilizing and Controlling Output: the Output Clause</a></dt><dt>select clause, <a href="#epl-select-list">Choosing Event Properties And Events: the Select Clause</a></dt><dt>subqueries, <a href="#epl-subqueries">Subqueries</a></dt><dt>variable, <a href="#variables_overview">Variables</a></dt><dt>where clause, <a href="#epl-where-clause">Specifying Search Conditions: the Where Clause</a></dt></dl></dd><dt>EPRuntime interface, <a href="#api-runtime">The Runtime Interface</a></dt><dt>EPServiceProviderManager class, <a href="#api-engine-instances">The Service Provider Interface</a></dt><dt>EPStatement interface, <a href="#api-administrative">The Administrative Interface</a></dt><dt>EPStatementObjectModel interface, <a href="#api-soda">Statement Object Model</a></dt><dt>event</dt><dd><dl><dt>additional representations, <a href="#eventrep-plug-in">Additional Event Representations</a></dt><dt>bulk, <a href="#eventrep-coarse">Coarse-Grained Events</a></dt><dt>coarse, <a href="#eventrep-coarse">Coarse-Grained Events</a></dt><dt>dynamic properties, <a href="#eventrep-dyncproperties">Dynamic Event Properties</a></dt><dt>insert into, <a href="#eventrep-insertinto">Event Objects Populated by Insert Into</a></dt><dt>Java object, <a href="#eventrep-javabean">Plain-Old Java Object Events</a></dt><dt>Map representation, <a href="#eventrep-java-util-map">java.util.Map Events</a></dt><dt>properties, <a href="#eventrep-properties">Event Properties</a></dt><dt>underlying representation, <a href="#eventrep_intro">Event Underlying Java Objects</a></dt><dt>update, <a href="#eventrep-update">Updating and Versioning Events</a></dt><dt>version, <a href="#eventrep-update">Updating and Versioning Events</a></dt><dt>XML representation, <a href="#eventrep-xml-dom">org.w3c.dom.Node XML Events</a></dt></dl></dd><dt>event as a property, <a href="#insert-into-eventasproperty">Event as a Property</a></dt><dt>event representation</dt><dd><dl><dt>custom, <a href="#custom-event-representation">Custom Event Representation</a></dt></dl></dd><dt>EventBean interface, <a href="#processingmodel_intro">Introduction</a>, <a href="#api-event">Event and Event Type</a></dt><dt>EventType interface, <a href="#api-event">Event and Event Type</a></dt><dt>every pattern operator, <a href="#pattern-logical-every">Every</a></dt><dt>every-distinct pattern operator, <a href="#pattern-logical-everydistinct">Every-Distinct</a></dt><dt>exists function, <a href="#epl-single-row-function-exists">The Exists Function</a></dt><dt>external time, <a href="#api-controlling-time">Controlling Time-Keeping</a></dt><dt>externally-timed window, <a href="#view-win-ext_time">Externally-timed window (win:ext_timed)</a></dt></dl></div><div class="indexdiv"><h3>F</h3><dl><dt>first event, <a href="#view-std-first">First Event (std:firstevent)</a></dt><dt>first length window, <a href="#view-win-firstlength">First Length (win:firstlength)</a></dt><dt>first time window, <a href="#view-win-firsttime">First Time (win:firsttime)</a></dt><dt>first unique window, <a href="#view-std-firstunique">First Unique (std:firstunique)</a></dt><dt>followed-by pattern operator, <a href="#pattern-temporal-followed-by">Followed-by</a></dt><dt>from clause, <a href="#epl-from-clause">Specifying Event Streams: the From Clause</a></dt><dt>functions</dt><dd><dl><dt>case control flow, <a href="#epl-single-row-function-ref-case">The Case Control Flow Function</a></dt><dt>cast, <a href="#epl-single-row-function-cast">The Cast Function</a></dt><dt>coalesce, <a href="#epl-single-row-function-ref-coalesce">The Coalesce Function</a></dt><dt>current_timestamp, <a href="#epl-single-row-function-ref-currenttime">The Current_Timestamp Function</a></dt><dt>exists, <a href="#epl-single-row-function-exists">The Exists Function</a></dt><dt>instance-of, <a href="#epl-single-row-function-instanceof">The Instance-Of Function</a></dt><dt>max, <a href="#epl-single-row-function-ref-minmax">The Min and Max Functions</a></dt><dt>min, <a href="#epl-single-row-function-ref-minmax">The Min and Max Functions</a></dt><dt>previous, <a href="#epl-single-row-function-ref-previous">The Previous Function</a></dt><dt>prior, <a href="#epl-single-row-function-ref-prior">The Prior Function</a></dt><dt>user-defined, <a href="#epl-single-row-function-ref">Single-row Function Reference</a>, <a href="#epl-function-user-defined">User-Defined Functions</a></dt></dl></dd></dl></div><div class="indexdiv"><h3>G</h3><dl><dt>group by clause, <a href="#epl-grouping-group-by">Organizing statement results into groups: the Group-by clause</a></dt><dt>group-by window, <a href="#view-std-groupby">Group-By (std:groupby)</a></dt></dl></div><div class="indexdiv"><h3>H</h3><dl><dt>having clause, <a href="#epl-grouping-having">Selecting groups of events: the Having clause</a></dt></dl></div><div class="indexdiv"><h3>I</h3><dl><dt>in set operator, <a href="#epl-operator-ref-keyword-in">The 'in' Keyword</a></dt><dt>inner join, <a href="#epl-outerjoin">Outer and Inner Joins</a></dt><dt>insert into clause, <a href="#epl-insert-into">Merging Streams and Continuous Insertion: the Insert Into Clause</a></dt><dt>insert stream, <a href="#processingmodel_nowindow">Insert Stream</a></dt><dt>instance-of function, <a href="#epl-single-row-function-instanceof">The Instance-Of Function</a></dt><dt>iterator, <a href="#api-admin-iterators">Using Iterators</a></dt></dl></div><div class="indexdiv"><h3>J</h3><dl><dt>join, <a href="#epl-join">Joining Event Streams</a></dt><dd><dl><dt>from clause, <a href="#epl-from-clause">Specifying Event Streams: the From Clause</a></dt><dt>non-relational data via method invocation, <a href="#joining_method">Accessing Non-Relational Data via Method Invocation</a></dt><dt>relational data via SQL, <a href="#histdata_overview">Accessing Relational Data via SQL</a></dt></dl></dd></dl></div><div class="indexdiv"><h3>K</h3><dl><dt>keep-all window, <a href="#view-win-keepall">Keep-All window (win:keepall)</a></dt><dt>keywords, <a href="#epl-syntax-keywords">Reserved Keywords</a></dt></dl></div><div class="indexdiv"><h3>L</h3><dl><dt>last event window, <a href="#view-std-last">Last Event (std:lastevent)</a></dt><dt>length batch window, <a href="#view-win-length-batch">Length batch window (win:length_batch)</a></dt><dt>length window, <a href="#view-win-length">Length window (win:length)</a></dt><dt>like operator, <a href="#epl-operator-ref-keyword-like">The 'like' Keyword</a></dt><dt>limit clause, <a href="#epl-limit">Limiting Row Count: the Limit Clause</a></dt><dt>limiting output row count, <a href="#epl-limit">Limiting Row Count: the Limit Clause</a></dt><dt>literals, <a href="#epl-syntax-datatype-constants">Data Type of Constants</a></dt><dt>logical and comparison operators, <a href="#epl-operator-ref-logical">Logical And Comparsion Operators</a></dt></dl></div><div class="indexdiv"><h3>M</h3><dl><dt>map event representation, <a href="#eventrep-java-util-map">java.util.Map Events</a></dt><dt>max function, <a href="#epl-single-row-function-ref-minmax">The Min and Max Functions</a></dt><dt>min function, <a href="#epl-single-row-function-ref-minmax">The Min and Max Functions</a></dt></dl></div><div class="indexdiv"><h3>N</h3><dl><dt>named window, <a href="#named_overview">Creating and Using Named Windows</a></dt><dd><dl><dt>deleting from, <a href="#named_delete">Deleting From Named Windows: the On Delete clause</a></dt><dt>inserting into, <a href="#named_inserting">Inserting Into Named Windows</a></dt><dt>populating from a named window, <a href="#named_populate_named">Populating a Named Window from an Existing Named Window</a></dt><dt>selecting from, <a href="#named_selecting">Selecting From Named Windows</a></dt><dt>triggered playback using On Insert, <a href="#named_playback">Triggered Playback from Named Windows: the On Insert clause</a></dt><dt>triggered select using On Select, <a href="#named_querying">Triggered Select on Named Windows: the On Select clause</a></dt><dt>updating events, <a href="#named_update">Updating and Versioning Events in Named Windows</a></dt></dl></dd><dt>not pattern operator, <a href="#pattern-logical-not">Not</a></dt></dl></div><div class="indexdiv"><h3>O</h3><dl><dt>on-delete, <a href="#named_delete">Deleting From Named Windows: the On Delete clause</a></dt><dt>on-insert, <a href="#named_playback">Triggered Playback from Named Windows: the On Insert clause</a></dt><dt>on-select, <a href="#named_querying">Triggered Select on Named Windows: the On Select clause</a></dt><dt>operators</dt><dd><dl><dt>arithmetic, <a href="#epl-operator-ref-arithmetic">Arithmetic Operators</a></dt><dt>array definition, <a href="#epl-operator-ref-array">Array Definition Operator</a></dt><dt>between, <a href="#epl-operator-ref-keyword-between">The 'between' Keyword</a></dt><dt>binary, <a href="#epl-operator-ref-binary">Binary Operators</a></dt><dt>concatenation, <a href="#epl-operator-ref-string">Concatenation Operators</a></dt><dt>in, <a href="#epl-operator-ref-keyword-in">The 'in' Keyword</a></dt><dt>like, <a href="#epl-operator-ref-keyword-like">The 'like' Keyword</a></dt><dt>logical and comparison, <a href="#epl-operator-ref-logical">Logical And Comparsion Operators</a></dt><dt>regexp, <a href="#epl-operator-ref-keyword-regexp">The 'regexp' Keyword</a></dt></dl></dd><dt>or pattern operator, <a href="#pattern-logical-or">Or</a></dt><dt>order by clause, <a href="#epl-order-by">Sorting Output: the Order By Clause</a></dt><dt>ordering output, <a href="#epl-order-by">Sorting Output: the Order By Clause</a></dt><dt>outer join, <a href="#epl-outerjoin">Outer and Inner Joins</a></dt><dt>output control and stabilizing clause, <a href="#epl-output-rate">Stabilizing and Controlling Output: the Output Clause</a></dt><dt>output ordering, <a href="#epl-order-by">Sorting Output: the Order By Clause</a></dt><dt>output row count, <a href="#epl-limit">Limiting Row Count: the Limit Clause</a></dt><dt>output when, <a href="#epl-output-expression">Controlling Output Using an Expression</a></dt></dl></div><div class="indexdiv"><h3>P</h3><dl><dt>pattern</dt><dd><dl><dt>filter expressions, <a href="#pattern-filter">Filter Expressions In Patterns</a></dt><dt>operator precedences, <a href="#pattern-op-precedence">Operator Precedence</a></dt><dt>overview, <a href="#event-pattern-intro">Event Pattern Overview</a></dt></dl></dd><dt>pattern atom, <a href="#pattern-atoms">Pattern Atoms</a></dt><dt>pattern guard, <a href="#pattern-guards">Pattern Guards</a></dt><dd><dl><dt>custom plug-in, <a href="#custom-pattern-guard">Custom Pattern Guard</a></dt><dt>timer-within, <a href="#pattern-timer-within">timer:within</a></dt></dl></dd><dt>pattern observer</dt><dd><dl><dt>custom plug-in, <a href="#custom-pattern-observer">Custom Pattern Observer</a></dt><dt>timer-at, <a href="#pattern-timer-at">timer:at</a></dt><dt>timer-interval, <a href="#pattern-timer-interval">timer:interval</a></dt></dl></dd><dt>pattern operator</dt><dd><dl><dt>and, <a href="#pattern-logical-and">And</a></dt><dt>every, <a href="#pattern-logical-every">Every</a></dt><dt>every-distinct, <a href="#pattern-logical-everydistinct">Every-Distinct</a></dt><dt>followed-by, <a href="#pattern-temporal-followed-by">Followed-by</a></dt><dt>not, <a href="#pattern-logical-not">Not</a></dt><dt>or, <a href="#pattern-logical-or">Or</a></dt></dl></dd><dt>plug-in event representation, <a href="#custom-event-representation">Custom Event Representation</a></dt><dt>previous function, <a href="#epl-single-row-function-ref-previous">The Previous Function</a></dt><dt>prior function, <a href="#epl-single-row-function-ref-prior">The Prior Function</a></dt><dt>pull API, <a href="#api-admin-iterators">Using Iterators</a></dt></dl></div><div class="indexdiv"><h3>R</h3><dl><dt>regexp operator, <a href="#epl-operator-ref-keyword-regexp">The 'regexp' Keyword</a></dt><dt>regression view, <a href="#view-stat-linest">Regression (stat:linest)</a></dt><dt>relational databases, <a href="#histdata_overview">Accessing Relational Data via SQL</a></dt><dt>remove stream, <a href="#processingmodel_lengthwindow">Insert and Remove Stream</a></dt></dl></div><div class="indexdiv"><h3>S</h3><dl><dt>safe iterator, <a href="#api-admin-iterators">Using Iterators</a></dt><dt>select clause, <a href="#epl-select-list">Choosing Event Properties And Events: the Select Clause</a></dt><dt>size window, <a href="#view-std-size">Size (std:size)</a></dt><dt>sorted window, <a href="#view-ext-sort">Sorted Window View (ext:sort)</a></dt><dt>SQL, <a href="#histdata_overview">Accessing Relational Data via SQL</a></dt><dt>statement</dt><dd><dl><dt>receiving results, <a href="#api-receive-results">Receiving Statement Results</a></dt><dt>subscriber object, <a href="#api-admin-subscriber">Setting a Subscriber Object</a></dt></dl></dd><dt>StatementAwareUpdateListener interface, <a href="#api-admin-listeners">Adding Listeners</a></dt><dt>static Java methods, <a href="#epl-single-row-function-ref">Single-row Function Reference</a></dt><dt>subqueries, <a href="#epl-subqueries">Subqueries</a></dt><dt>subscriber object, <a href="#api-admin-subscriber">Setting a Subscriber Object</a></dt><dd><dl><dt>multi-row, <a href="#api-admin-subscriber-multirow">Multi-Row Delivery</a></dt><dt>row-by-row, <a href="#api-admin-subscriber-rowbyrow">Row-By-Row Delivery</a></dt></dl></dd></dl></div><div class="indexdiv"><h3>T</h3><dl><dt>threading, <a href="#api-threading">Engine Threading and Concurrency</a></dt><dt>time</dt><dd><dl><dt>controlling, <a href="#api-controlling-time">Controlling Time-Keeping</a></dt><dt>resolution, <a href="#api-time-resolution">Time Resolution</a></dt></dl></dd><dt>time batch window, <a href="#processingmodel_time_batch_1">Time Batch</a>, <a href="#view-win-time-batch">Time batch window (win:time_batch)</a></dt><dt>time length batch window, <a href="#view-win-time-length-batch">Time-Length combination batch window (win:time_length_batch)</a></dt><dt>time window, <a href="#processingmodel_time_window_1">Time Window</a>, <a href="#view-win-time">Time window (win:time)</a></dt><dt>time-accumulating window, <a href="#view-win-time-accumulating">Time-Accumulating window (win:time_accum)</a></dt><dt>time-order window, <a href="#view-time-order">Time-Order View (ext:time_order)</a></dt><dt>timer-at pattern observer, <a href="#pattern-timer-at">timer:at</a></dt><dt>timer-interval pattern observer, <a href="#pattern-timer-interval">timer:interval</a></dt><dt>timer-within pattern guard, <a href="#pattern-timer-within">timer:within</a></dt></dl></div><div class="indexdiv"><h3>U</h3><dl><dt>UDF</dt><dd><dl><dt>user-defined function, <a href="#epl-function-user-defined">User-Defined Functions</a></dt></dl></dd><dt>unidirectional joins, <a href="#epl-unidirectional">Unidirectional Joins</a></dt><dt>unique window, <a href="#view-std-unique">Unique (std:unique)</a></dt><dt>univariate statistics view, <a href="#view-stat-uni">Univariate statistics (stat:uni)</a></dt><dt>UnmatchedListener interface, <a href="#api-runtime-unmatched">Receiving Unmatched Events</a></dt><dt>update, <a href="#named_update">Updating and Versioning Events in Named Windows</a></dt><dt>UpdateListener interface, <a href="#api-admin-listeners">Adding Listeners</a></dt><dt>user-defined function, <a href="#epl-function-user-defined">User-Defined Functions</a></dt><dt>user-defined single-row function, <a href="#epl-single-row-function-ref">Single-row Function Reference</a></dt></dl></div><div class="indexdiv"><h3>V</h3><dl><dt>variable, <a href="#variables_overview">Variables</a></dt><dt>variant stream, <a href="#insert-into-merging-types">Merging Disparate Types of Events: Variant Streams</a></dt><dt>views</dt><dd><dl><dt>batch window processing, <a href="#processingmodel_batch">Batch Windows</a></dt><dt>correlation, <a href="#view-stat-correl">Correlation (stat:correl)</a></dt><dt>custom plug-in view, <a href="#custom-views">Custom View Implementation</a></dt><dt>externally-timed window, <a href="#view-win-ext_time">Externally-timed window (win:ext_timed)</a></dt><dt>first event, <a href="#view-std-first">First Event (std:firstevent)</a></dt><dt>first length window, <a href="#view-win-firstlength">First Length (win:firstlength)</a></dt><dt>first time window, <a href="#view-win-firsttime">First Time (win:firsttime)</a></dt><dt>first unique window, <a href="#view-std-firstunique">First Unique (std:firstunique)</a></dt><dt>group-by window, <a href="#view-std-groupby">Group-By (std:groupby)</a></dt><dt>keep-all window, <a href="#view-win-keepall">Keep-All window (win:keepall)</a></dt><dt>last event window, <a href="#view-std-last">Last Event (std:lastevent)</a></dt><dt>length batch window, <a href="#view-win-length-batch">Length batch window (win:length_batch)</a></dt><dt>length window, <a href="#view-win-length">Length window (win:length)</a></dt><dt>overview, <a href="#epl-views">EPL Reference: Views</a></dt><dt>regression, <a href="#view-stat-linest">Regression (stat:linest)</a></dt><dt>size window, <a href="#view-std-size">Size (std:size)</a></dt><dt>sorted window, <a href="#view-ext-sort">Sorted Window View (ext:sort)</a></dt><dt>time batch window, <a href="#view-win-time-batch">Time batch window (win:time_batch)</a></dt><dt>time length batch window, <a href="#view-win-time-length-batch">Time-Length combination batch window (win:time_length_batch)</a></dt><dt>time window, <a href="#view-win-time">Time window (win:time)</a></dt><dt>time-accumulating window, <a href="#view-win-time-accumulating">Time-Accumulating window (win:time_accum)</a></dt><dt>time-order window, <a href="#view-time-order">Time-Order View (ext:time_order)</a></dt><dt>unique window, <a href="#view-std-unique">Unique (std:unique)</a></dt><dt>univariate statistics, <a href="#view-stat-uni">Univariate statistics (stat:uni)</a></dt><dt>weighted average, <a href="#view-stat-weightedavg">Weighted average (stat:weighted_avg)</a></dt></dl></dd></dl></div><div class="indexdiv"><h3>W</h3><dl><dt>weighted average view, <a href="#view-stat-weightedavg">Weighted average (stat:weighted_avg)</a></dt><dt>where clause, <a href="#epl-where-clause">Specifying Search Conditions: the Where Clause</a></dt></dl></div><div class="indexdiv"><h3>X</h3><dl><dt>XML event representation, <a href="#eventrep-xml-dom">org.w3c.dom.Node XML Events</a></dt></dl></div></div></div></div><hr xmlns="http://www.w3.org/TR/xhtml1/transitional"><center xmlns="http://www.w3.org/TR/xhtml1/transitional">&copy; 2009 EsperTech Inc. All Rights Reserved</center><script xmlns="http://www.w3.org/TR/xhtml1/transitional" type="text/javascript">
	var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
	document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
	</script><script xmlns="http://www.w3.org/TR/xhtml1/transitional" type="text/javascript">
	var pageTracker = _gat._getTracker("UA-1261295-1");
	pageTracker._trackPageview();
	</script></body></html>