<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;11.&nbsp;Configuration</title><link rel="stylesheet" href="../shared/css/html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.65.1"><link rel="home" href="index.html" title="Esper - Event Stream and Complex Event Processing for Java"><link rel="up" href="index.html" title="Esper - Event Stream and Complex Event Processing for Java"><link rel="previous" href="api.html" title="Chapter&nbsp;10.&nbsp;API Reference"><link rel="next" href="extension.html" title="Chapter&nbsp;12.&nbsp;Extension and Plug-in"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter&nbsp;11.&nbsp;Configuration</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="api.html">Prev</a>&nbsp;</td><th width="60%" align="center">&nbsp;</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="extension.html">Next</a></td></tr></table><hr></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="configuration"></a>Chapter&nbsp;11.&nbsp;Configuration</h2></div></div><div></div></div><a class="indexterm" name="d0e19117"></a><a class="indexterm" name="d0e19122"></a><p>
        Esper engine configuration is entirely optional. Esper has a very small number of configuration parameters that can be used to simplify event 
        pattern and EPL statements, and to tune the engine behavior to specific requirements. The Esper engine works out-of-the-box without configuration.
    </p><p>
        An application can supply configuration at the time of engine allocation using the <tt class="literal">Configuration</tt> class, and can also use XML files to hold configuration. Configuration can be changed at runtime
        via the <tt class="literal">ConfigurationOperations</tt> interface available from <tt class="literal">EPAdministrator</tt> via the <tt class="literal">getConfiguration</tt> method.
    </p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-programmatic"></a>11.1.&nbsp;Programmatic Configuration</h2></div></div><div></div></div><a class="indexterm" name="d0e19144"></a><p>
            An instance of <tt class="literal">com.espertech.esper.client.Configuration</tt> represents all configuration parameters. The <tt class="literal">Configuration</tt> is used to build an <tt class="literal">EPServiceProvider</tt>, which provides the administrative and runtime interfaces for an Esper engine instance.
        </p><p>
            You may obtain a <tt class="literal">Configuration</tt> instance by instantiating it directly and adding or setting values on it. The <tt class="literal">Configuration</tt> instance is then passed to <tt class="literal">EPServiceProviderManager</tt> to obtain a configured Esper engine.
        </p><pre class="programlisting">Configuration configuration = new Configuration();
configuration.addEventType("PriceLimit", PriceLimit.class.getName());
configuration.addEventType("StockTick", StockTick.class.getName());
configuration.addImport("org.mycompany.mypackage.MyUtility");
configuration.addImport("org.mycompany.util.*");

EPServiceProvider epService = EPServiceProviderManager.getProvider("sample", configuration);
</pre><p>
			Note that <tt class="literal">Configuration</tt> is meant only as an initialization-time object. The Esper engine represented by an <tt class="literal">EPServiceProvider</tt> does not retain any association back to the <tt class="literal">Configuration</tt>.
        </p><p>
			The <tt class="literal">ConfigurationOperations</tt> interface provides runtime configuration options. Through this interface applications can, for example, add new event types at runtime and then create new statements
			that rely on the additional configuration. The <tt class="literal">getConfiguration</tt> method on <tt class="literal">EPAdministrator</tt> allows access to <tt class="literal">ConfigurationOperations</tt>.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-via-xml"></a>11.2.&nbsp;Configuration via XML File</h2></div></div><div></div></div><a class="indexterm" name="d0e19201"></a><p>
			An alternative approach to configuration is to specify a configuration in a XML file. 
        </p><p>
			The default name for the XML configuration file is <tt class="literal">esper.cfg.xml</tt>. Esper reads this file from the root of the <tt class="literal">CLASSPATH</tt> as an application resource via the <tt class="literal">configure</tt> method.
        </p><pre class="programlisting">Configuration configuration = new Configuration();		
configuration.configure();
</pre><p>
			The <tt class="literal">Configuration</tt> class can read the XML configuration file from other sources as well. The <tt class="literal">configure</tt> method accepts <tt class="literal">URL, File and String</tt> filename parameters.
        </p><pre class="programlisting">Configuration configuration = new Configuration();		
configuration.configure("myengine.esper.cfg.xml");
</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-xml"></a>11.3.&nbsp;XML Configuration File</h2></div></div><div></div></div><p>
			Here is an example configuration file.
            The schema for the configuration file can be found in the <tt class="literal">etc</tt> folder and is named <tt class="literal">esper-configuration-3-0.xsd</tt>.
            It is also available online at <tt class="literal">http://www.espertech.com/schema/esper/esper-configuration-2.0.xsd</tt> so that IDE can fetch it automatically.
            The namespace used is <tt class="literal">http://www.espertech.com/schema/esper</tt>.
        </p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;esper-configuration xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns="http://www.espertech.com/schema/esper"
    xsi:schemaLocation="
http://www.espertech.com/schema/esper
http://www.espertech.com/schema/esper/esper-configuration-2.0.xsd"&gt;
  &lt;event-type name="StockTick" class="com.espertech.esper.example.stockticker.event.StockTick"/&gt;
  &lt;event-type name="PriceLimit" class="com.espertech.esper.example.stockticker.event.PriceLimit"/&gt;
  &lt;auto-import import-name="org.mycompany.mypackage.MyUtility"/&gt;
  &lt;auto-import import-name="org.mycompany.util.*"/&gt;
&lt;/esper-configuration&gt;		
</pre><p>
			The example above is only a subset of the configuration items available. The next chapters outline the available configuration in greater detail.
		</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-items"></a>11.4.&nbsp;Configuration Items</h2></div></div><div></div></div><a class="indexterm" name="d0e19258"></a><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="config-java"></a>11.4.1.&nbsp;Events represented by Java Classes</h3></div></div><div></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="config-java-package-alias"></a>11.4.1.1.&nbsp;Package of Java Event Classes</h4></div></div><div></div></div><p>
					Via this configuration an application can make the Java package or packages that contain an application's Java event classes known to an engine. 
					Thereby an application can simply refer to event types in statements by using the simple class name of
					each Java class representing an event type.
				</p><p>
					For example, consider an order-taking application that places all event classes in package <tt class="literal">com.mycompany.order.event</tt>. One Java class representing an event is the class <tt class="literal">OrderEvent</tt>. 
					The application can simply issue a statement as follows to select <tt class="literal">OrderEvent</tt> events:
				</p><pre class="programlisting">select * from OrderEvent</pre><p>
					The XML configuration for defining the Java packages that contain Java event classes is:
				</p><pre class="programlisting">&lt;event-type-auto-name package-name="com.mycompany.order.event"/&gt;</pre><p>
					The same configuration but using the <tt class="literal">Configuration</tt> class:
				</p><pre class="programlisting">Configuration config = new Configuration();
config.addEventTypeAutoName("com.mycompany.order.event");
// ... or ...
config.addEventTypeAutoName(MyEvent.getPackage().getName());</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="config-java-event-name"></a>11.4.1.2.&nbsp;Event type name to Java class mapping</h4></div></div><div></div></div><p>
					This configuration item can be used to allow event pattern statements and EPL statements to use an event type name rather then the fully qualified Java class name. Note that Java Interface classes and abstract classes are also supported as event types via the fully qualified Java class name, and an event type name can also be defined for such classes.
				</p><p>
					The example pattern statement below first shows a pattern that uses the name <tt class="literal">StockTick</tt>. The second pattern statement is equivalent but specifies the fully-qualified Java class name.
				</p><pre class="programlisting">every StockTick(symbol='IBM')"</pre><pre class="programlisting">every com.espertech.esper.example.stockticker.event.StockTick(symbol='IBM')</pre><p>
					The event type name can be listed in the XML configuration file as shown below. The <tt class="literal">Configuration</tt> API can also be used to programatically specify an event type name, as shown in an earlier code snippet.
				</p><pre class="programlisting">&lt;event-type name="StockTick" class="com.espertech.esper.example.stockticker.event.StockTick"/&gt;</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="config-java-legacy"></a>11.4.1.3.&nbsp;Non-JavaBean and Legacy Java Event Classes</h4></div></div><div></div></div><p>
					Esper can process Java classes that provide event properties through other means then through JavaBean-style getter methods. It is not necessary that the method and member variable names in your Java class adhere to the JavaBean convention - any public methods and public member variables can be exposed as event properties via the below configuration.
				</p><p>
					A Java class can optionally be configured with an accessor style attribute. This attribute instructs the engine how it should expose methods and fields for use as event properties in statements.
				</p><div class="table"><a name="d0e19323"></a><p class="title"><b>Table&nbsp;11.1.&nbsp;Accessor Styles</b></p><table summary="Accessor Styles" border="1"><colgroup><col><col></colgroup><thead><tr><th>Style Name</th><th>Description</th></tr></thead><tbody><tr><td><tt class="literal">javabean</tt></td><td>As the default setting, the engine exposes an event property for each public method following the JavaBean getter-method conventions</td></tr><tr><td><tt class="literal">public</tt></td><td>The engine exposes an event property for each public method and public member variable of the given class</td></tr><tr><td><tt class="literal">explicit</tt></td><td>The engine exposes an event property only for the explicitly configured public methods and public member variables</td></tr></tbody></table></div><p>
					Using the <tt class="literal">public</tt> setting for the <tt class="literal">accessor-style</tt> attribute instructs the engine to expose an event property for each public method and public member variable of a Java class. The engine assigns event property names of the same name as the name of the method or member variable in the Java class.
				</p><p>					
					For example, assuming the class <tt class="literal">MyLegacyEvent</tt> exposes a method named <tt class="literal">readValue</tt> and a member variable named <tt class="literal">myField</tt>, we can then use properties as shown. 
				</p><pre class="programlisting">select readValue, myField from MyLegacyEvent</pre><p>
					Using the <tt class="literal">explicit</tt> setting for the <tt class="literal">accessor-style</tt> attribute requires that event properties are declared via configuration. This is outlined in the next chapter.
				</p><p>
					When configuring an engine instance from a XML configuration file, the XML snippet below demonstrates the use of the <tt class="literal">legacy-type</tt> element and the <tt class="literal">accessor-style</tt> attribute.
				</p><pre class="programlisting">&lt;event-type name="MyLegacyEvent" class="com.mycompany.mypackage.MyLegacyEventClass"&gt;
  &lt;legacy-type accessor-style="public"/&gt;
&lt;/event-type&gt;</pre><p>
					When configuring an engine instance via Configuration API, the sample code below shows how to set the accessor style.
				</p><pre class="programlisting">Configuration configuration = new Configuration();
ConfigurationEventTypeLegacy legacyDef = new ConfigurationEventTypeLegacy();
legacyDef.setAccessorStyle(ConfigurationEventTypeLegacy.AccessorStyle.PUBLIC);
config.addEventType("MyLegacyEvent", MyLegacyEventClass.class.getName(), legacyDef);

EPServiceProvider epService = EPServiceProviderManager.getProvider("sample", configuration);
</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="config-java-spec-properties"></a>11.4.1.4.&nbsp;Specifying Event Properties for Java Classes</h4></div></div><div></div></div><p>
					Sometimes it may be convenient to use event property names in pattern and EPL statements that are backed up by a given public method or member variable (field) in a Java class. And it can be useful to declare multiple event properties that each map to the same method or member variable.
				</p><p>
					We can configure properties of events via <tt class="literal">method-property</tt> and <tt class="literal">field-property</tt> elements, as the next example shows.
				</p><pre class="programlisting">&lt;event-type name="StockTick" class="com.espertech.esper.example.stockticker.event.StockTickEvent"&gt;
	&lt;legacy-type accessor-style="javabean" code-generation="enabled"&gt;
		&lt;method-property name="price" accessor-method="getCurrentPrice" /&gt;
		&lt;field-property name="volume" accessor-field="volumeField" /&gt;
	&lt;/legacy-type&gt;
&lt;/event-type&gt;</pre><p>
					The XML configuration snippet above declared an event property named <tt class="literal">price</tt> backed by a getter-method named <tt class="literal">getCurrentPrice</tt>, and a second event property named <tt class="literal">volume</tt> that is backed by a public member variable named <tt class="literal">volumeField</tt>. Thus the price and volume properties can be used in a statement:
				</p><pre class="programlisting">select avg(price * volume) from StockTick</pre><p>
					As with all configuration options, the API can also be used:
				</p><pre class="programlisting">Configuration configuration = new Configuration();
ConfigurationEventTypeLegacy legacyDef = new ConfigurationEventTypeLegacy();
legacyDef.addMethodProperty("price", "getCurrentPrice");
legacyDef.addFieldProperty("volume", "volumeField");
config.addEventType("StockTick", StockTickEvent.class.getName(), legacyDef);</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="config-java-codegen"></a>11.4.1.5.&nbsp;Turning off Code Generation</h4></div></div><div></div></div><p>
					Esper employes the <tt class="literal">CGLIB</tt> library for very fast read access to event property values. For certain legacy Java classes it may be desirable to disable the use of this library and instead use Java reflection to obtain event property values from event objects.
				</p><p>
					In the XML configuration, the optional <tt class="literal">code-generation</tt> attribute in the <tt class="literal">legacy-type</tt> section can be set to <tt class="literal">disabled</tt> as shown next.
				</p><pre class="programlisting">&lt;event-type name="MyLegacyEvent" class="com.mycompany.package.MyLegacyEventClass"&gt;
	&lt;legacy-type accessor-style="javabean" code-generation="disabled" /&gt;
&lt;/event-type&gt;
</pre><p>
					The sample below shows how to configure this option via the API.
				</p><pre class="programlisting">Configuration configuration = new Configuration();
ConfigurationEventTypeLegacy legacyDef = new ConfigurationEventTypeLegacy();
legacyDef.setCodeGeneration(ConfigurationEventTypeLegacy.CodeGeneration.DISABLED);
config.addEventType("MyLegacyEvent", MyLegacyEventClass.class.getName(), legacyDef);</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="config-java-property-case-sensitivity"></a>11.4.1.6.&nbsp;Case Sensitivity and Property Names</h4></div></div><div></div></div><p>
					By default the engine resolves Java event properties case sensitive. That is, property names in statements must match JavaBean-convention property names in name and case. This option controls case sensitivity per Java class.
				</p><p>
					In the configuration XML, the optional <tt class="literal">property-resolution-style</tt> attribute in the <tt class="literal">legacy-type</tt> element can be set to any of these values:
				</p><div class="table"><a name="d0e19470"></a><p class="title"><b>Table&nbsp;11.2.&nbsp;Property Resolution Case Sensitivity Styles</b></p><table summary="Property Resolution Case Sensitivity Styles" border="1"><colgroup><col><col></colgroup><thead><tr><th>Style Name</th><th>Description</th></tr></thead><tbody><tr><td><tt class="literal">case_sensitive (default)</tt></td><td>As the default setting, the engine matches property names for the exact name and case only.</td></tr><tr><td><tt class="literal">case_insensitive</tt></td><td>Properties are matched if the names are identical.  A case insensitive search is used and will choose the first property that matches the name exactly 
											or the first property that matches case insensitively should no match be found.
								</td></tr><tr><td><tt class="literal">distinct_case_insensitive</tt></td><td>Properties are matched if the names are identical.  A case insensitive search is used and will choose the first property that matches the name exactly case insensitively.  If more than one 'name' can be mapped to the property an exception is thrown.</td></tr></tbody></table></div><p>
					The sample below shows this option in XML configuration, however the setting can also be changed via API:
				</p><pre class="programlisting">&lt;event-type name="MyLegacyEvent" class="com.mycompany.package.MyLegacyEventClass"&gt;
  &lt;legacy-type property-resolution-style="case_insensitive"/&gt;
&lt;/event-type&gt;</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="config-java-factory-copy-method"></a>11.4.1.7.&nbsp;Factory and Copy Method</h4></div></div><div></div></div><p>
					The <tt class="literal">insert into</tt> clause and directly instantiate and populate your event object. By default the engine invokes the default constructor to instantiate an event object. To change this behavior, you may configure
					a factory method. The factory method is a method name or a class name plus a method name (in the format class.method) that returns an instance of the class.
				</p><p>
					The <tt class="literal">update</tt> clause can change event properties on an event object. For the purpose of maintaining consistency, the engine may have to copy your event object via serialization (implement the <tt class="literal">java.io.Serializable</tt> interface). If instead you do not want any copy operations to occur, or your application needs to control the copy operation, you may configure a copy method. The copy method is the name of a method on the event object that copies the event object.
				</p><p>
					The sample below shows this option in XML configuration, however the setting can also be changed via API:
				</p><pre class="programlisting">&lt;event-type name="MyLegacyEvent" class="com.mycompany.package.MyLegacyEventClass"
  factory-method="com.mycompany.myapp.MySampleEventFactory.createMyLegacyTypeEvent" copy-method="myCopyMethod"&gt; 
&lt;/event-type&gt;</pre></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="config-java-util-map"></a>11.4.2.&nbsp;Events represented by <tt class="literal">java.util.Map</tt></h3></div></div><div></div></div><p>
				The engine can process <tt class="literal">java.util.Map</tt> events via the <tt class="literal">sendEvent(Map map, String eventTypeName)</tt> method on the <tt class="literal">EPRuntime</tt> interface. Entries in the Map represent event properties. Keys must be of type <tt class="literal">java.util.String</tt> for the engine to be able to look up event property names in pattern or EPL statements. Values can be of any type. JavaBean-style objects as values in a <tt class="literal">Map</tt> can be processed by the engine, and strongly-typed nested maps are also supported. Please see the <a href="event_representation.html" title="Chapter&nbsp;2.&nbsp;Event Representations">Chapter&nbsp;2, <i>Event Representations</i></a> section for details on how to use <tt class="literal">Map</tt> events with the engine.
			</p><p>
				Via configuration we provide an event type name for <tt class="literal">Map</tt> events for use in statements, and the event property names and types enabling the engine to validate properties in statements.
			</p><p>
				The below snippet of XML configuration configures an event named <tt class="literal">MyMapEvent</tt>.
			</p><pre class="programlisting">&lt;event-type name="MyMapEvent"&gt;
  &lt;java-util-map&gt;
    &lt;map-property name="carId" class="int"/&gt;
    &lt;map-property name="carType" class="string"/&gt;
    &lt;map-property name="assembly" class="com.mycompany.Assembly"/&gt;    
  &lt;/java-util-map&gt;
&lt;/event-type&gt;</pre><p>
				This configuration defines the <tt class="literal">carId</tt> property of <tt class="literal">MyMapEvent</tt> events to be of type <tt class="literal">int</tt>, and the <tt class="literal">carType</tt> property to be of type <tt class="literal">java.util.String</tt>. The <tt class="literal">assembly</tt> property of the Map event will contain instances of <tt class="literal">com.mycompany.Assembly</tt> for the engine to query.
			</p><p>
				The valid types for the <tt class="literal">class</tt> attribute are listed in <a href="configuration.html#configuration-type-names" title="11.5.&nbsp;Type Names">Section&nbsp;11.5, &#8220;Type Names&#8221;</a>. In addition, any fully-qualified Java class name that can be resolved via <tt class="literal">Class.forName</tt> is allowed.
			</p><p>
				 You can also use the configuration API to configure <tt class="literal">Map</tt> event types, as the short code snippet below demonstrates:
			</p><pre class="programlisting">Map&lt;String, Object&gt; properties = new Map&lt;String, Object&gt;();
properties.put("carId", "int");
properties.put("carType", "string");
properties.put("assembly", Assembly.class.getName());

Configuration configuration = new Configuration();
configuration.addEventType("MyMapEvent", properties);</pre><p>
				 For strongly-typed nested maps (maps-within-maps), the configuration API method <tt class="literal">addEventType</tt> can also used to define the nested types. The XML configuration does not provide the capability to configure nested maps.
			</p><p>
				Finally, here is a sample EPL statement that uses the configured <tt class="literal">MyMapEvent</tt> map event. This statement uses the <tt class="literal">chassisTag</tt> and <tt class="literal">numParts</tt> properties of <tt class="literal">Assembly</tt> objects in each map.
			</p><pre class="programlisting">select carType, assembly.chassisTag, count(assembly.numParts) from MyMapEvent.win:time(60 sec)</pre><p>
				A Map event type may also become a subtype of one or more supertypes that must also be Map event types. The <tt class="literal">java-util-map</tt> element provides an optional attribute <tt class="literal">supertype-names</tt> that accepts a comma-separated list of names of Map event types that are supertypes to the type:
			</p><pre class="programlisting">&lt;event-type name="AccountUpdate"&gt;
&lt;java-util-map supertype-names="BaseUpdate, AccountEvent"&gt;
...</pre><p>
				For initialization time configuration, the <tt class="literal">addMapSuperType</tt> method can be used to add Map hierarchy information. For runtime configuration, pass the supertype names to the <tt class="literal">addEventType</tt> method in <tt class="literal">ConfigurationOperations</tt>.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="config-xml-dom"></a>11.4.3.&nbsp;Events represented by <tt class="literal">org.w3c.dom.Node</tt></h3></div></div><div></div></div><p>
				Via this configuration item the Esper engine can natively process <tt class="literal">org.w3c.dom.Node</tt> instances, i.e. XML document object model (DOM) nodes.
				Please see the <a href="event_representation.html" title="Chapter&nbsp;2.&nbsp;Event Representations">Chapter&nbsp;2, <i>Event Representations</i></a> section for details on how to use <tt class="literal">Node</tt> events with the engine.
			</p><p>
				Esper allows configuring XPath expressions as event properties. You can specify arbitrary XPath functions or expressions and provide a property name by which their result values will be available for use in expressions. 
			</p><p>
				For XML documents that follow a XML schema, Esper can load and interrogate your schema and validate event property names and types against the schema information. 
			</p><p>
				Nested, mapped and indexed event properties are also supported in expressions against <tt class="literal">org.w3c.dom.Node</tt> events. Thus XML trees can conveniently be
				interrogated using the existing event property syntax for querying JavaBean objects, JavaBean object graphs or <tt class="literal">java.util.Map</tt> events.
			</p><p>
				In the simplest form, the Esper engine only requires a configuration entry containing the root element name and the event type name in order to process <tt class="literal">org.w3c.dom.Node</tt> events:
			</p><pre class="programlisting">&lt;event-type name="MyXMLNodeEvent"&gt;
  &lt;xml-dom root-element-name="myevent" /&gt;
&lt;/event-type&gt;</pre><p>
				 You can also use the configuration API to configure XML event types, as the short example below demonstrates. 
				 In fact, all configuration options available through XML configuration can 
				 also be provided via setter methods on the <tt class="literal">ConfigurationEventTypeXMLDOM</tt> class.
			</p><pre class="programlisting">Configuration configuration = new Configuration();
ConfigurationEventTypeXMLDOM desc = new ConfigurationEventTypeXMLDOM();
desc.setRootElementName("myevent");
desc.addXPathProperty("name1", "/element/@attribute", XPathConstants.STRING);
desc.addXPathProperty("name2", "/element/subelement", XPathConstants.NUMBER);
configuration.addEventType("MyXMLNodeEvent", desc);</pre><p>
				 The next example presents configuration options in a sample configuration entry.
			</p><pre class="programlisting">&lt;event-type name="AutoIdRFIDEvent"&gt;
  &lt;xml-dom root-element-name="Sensor" schema-resource="data/AutoIdPmlCore.xsd" 
       default-namespace="urn:autoid:specification:interchange:PMLCore:xml:schema:1"&gt;
    &lt;namespace-prefix prefix="pmlcore" 
       namespace="urn:autoid:specification:interchange:PMLCore:xml:schema:1"/&gt;
    &lt;xpath-property property-name="countTags" 
       xpath="count(/pmlcore:Sensor/pmlcore:Observation/pmlcore:Tag)" type="number"/&gt;
  &lt;/xml-dom&gt;
&lt;/event-type&gt;</pre><p>
				 This example configures an event property named <tt class="literal">countTags</tt> whose value is computed by an XPath expression. The namespace prefixes
				 and default namespace are for use with XPath expressions and must also be made known to the engine in order for the engine to compile XPath expressions. 
				 Via the <tt class="literal">schema-resource</tt> attribute we instruct the engine to load a schema file.
			</p><p>
				 Here is an example EPL statement using the configured event type named <tt class="literal">AutoIdRFIDEvent</tt>.
			</p><pre class="programlisting">select ID, countTags from AutoIdRFIDEvent.win:time(30 sec)</pre><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="config-xml-dom-schema"></a>11.4.3.1.&nbsp;Schema Resource</h4></div></div><div></div></div><p>
					 The <tt class="literal">schema-resource</tt> attribute takes a schema resource URL or classpath-relative filename. 
					 The engine attempts to resolve the schema resource as an URL. If the schema resource name is not a valid URL, the engine attempts to resolve the resource from classpath via the <tt class="literal">ClassLoader.getResource</tt> method using the thread context class loader. If the name could not be resolved, the engine uses the Configuration class classloader.
				</p><p>
					 By configuring a schema file for the engine to load, the engine performs these additional services:
				</p><div class="itemizedlist"><ul type="disc" compact><li><p>
							Validates the event properties in a statement, ensuring the event property name matches an attribute or element in the XML
						</p></li><li><p>
							Determines the type of the event property allowing event properties to be used in type-sensitive expressions such as expressions involving arithmetic (Note: XPath properties are also typed)
						</p></li><li><p>
							Matches event property names to either element names or attributes
						</p></li></ul></div><p>
					 If no schema resource is specified, none of the event properties specified in statements are validated at statement creation time and their type defaults to <tt class="literal">java.lang.String</tt>. Also, attributes are not supported
					 if no schema resource is specified and must thus be declared via XPath expression.
				</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="config-xml-dom-xpathprop"></a>11.4.3.2.&nbsp;Explicit XPath Property</h4></div></div><div></div></div><p>
					 The <tt class="literal">xpath-property</tt> element adds explicitly-names event properties to the event type that are computed via an XPath expression.
					 In order for the XPath expression to compile, be sure to specify the <tt class="literal">default-namespace</tt> attribute and use the 
					 <tt class="literal">namespace-prefix</tt> to declare namespace prefixes.
				</p><p>
					 XPath expression properties are strongly typed. The <tt class="literal">type</tt> attribute allows the following values. These values correspond to those declared by 
					 <tt class="literal">javax.xml.xpath.XPathConstants</tt>.
				</p><div class="itemizedlist"><ul type="disc" compact><li><p>
							number (Note: resolves to a <tt class="literal">double</tt>)
						</p></li><li><p>
							string
						</p></li><li><p>
							boolean
						</p></li><li><p>
							node
						</p></li><li><p>
							nodeset
						</p></li></ul></div><p>
					 In case you need your XPath expression to return a type other then the types listed above, an optional cast-to type can be specified. If specified, the operation firsts obtains the result of the XPath expression as the defined type (number, string, boolean) and then casts or parses the returned type to the specified cast-to-type. At runtime, a warning message is logged if the XPath expression returns a result object that cannot be casted or parsed.
				</p><p>
					 The next line shows how to return a long-type property for an XPath expression that returns a string:
				</p><pre class="programlisting">desc.addXPathProperty("name", "/element/sub", XPathConstants.STRING, "long");</pre><p>
					 The equivalent configuration XML is:
				</p><pre class="programlisting">&lt;xpath-property property-name="name"  xpath="/element/sub" type="string" cast="long"/&gt;</pre><p>
				  See <a href="configuration.html#configuration-type-names" title="11.5.&nbsp;Type Names">Section&nbsp;11.5, &#8220;Type Names&#8221;</a> for a list of cast-to type names.
				</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="config-xml-dom-absolute"></a>11.4.3.3.&nbsp;Absolute or Deep Property Resolution</h4></div></div><div></div></div><p>
					This setting indicates that when properties are compiled to XPath expressions that the compilation should generate an absolute XPath expression or a deep (find element) XPath expression. 					
				</p><p>
					For example, consider the following statement against an event type that is represented by a XML DOM document, assuming the event type GetQuote has been configured with the engine as a XML DOM event type:
				</p><pre class="programlisting">select request, request.symbol from GetQuote</pre><p>
					By default, the engine compiles the "request" property name to an XPath expression "/GetQuote/request". It compiles the nested property named "request.symbol" to an XPath expression "/GetQuote/request/symbol", wherein the root element node is "GetQuote".
				</p><p>
					By setting absolute property resolution to false, the engine compiles the "request" property name to an XPath expression "//request". It compiles the nested property named "request.symbol" to an XPath expression "//request/symbol".
					This enables these elements to be located anywhere in the XML document.
				</p><p>
					The setting is available in XML via the attribute <tt class="literal">resolve-properties-absolute</tt>.
				</p><p>
					The configuration API provides the above settings as shown here in a sample code:
				</p><pre class="programlisting">ConfigurationEventTypeXMLDOM desc = new ConfigurationEventTypeXMLDOM();
desc.setRootElementName("GetQuote");
desc.setDefaultNamespace("http://services.samples/xsd");
desc.setRootElementNamespace("http://services.samples/xsd");
desc.addNamespacePrefix("m0", "http://services.samples/xsd");
desc.setResolvePropertiesAbsolute(false);
configuration.addEventType("GetQuote", desc);</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="config-xml-dom-xpathresolver"></a>11.4.3.4.&nbsp;XPath Variable and Function Resolver</h4></div></div><div></div></div><p>
					If your XPath expressions require variables or functions, your application may provide the class name of an <tt class="literal">XPathVariableResolver</tt> and <tt class="literal">XPathFunctionResolver</tt>. At type initialization time 
					the engine instantiates the resolver instances and provides these to the XPathFactory.
				</p><p>
					This example shows the API to set this configuration.
				</p><pre class="programlisting">ConfigurationEventTypeXMLDOM desc = new ConfigurationEventTypeXMLDOM();
desc.setXPathFunctionResolver(MyXPathFunctionResolver.class.getName());
desc.setXPathVariableResolver(MyXPathVariableResolver.class.getName());</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="config-xml-dom-autofragment"></a>11.4.3.5.&nbsp;Auto Fragment</h4></div></div><div></div></div><p>
					This option is for use when a XSD schema is provided and determines whether the engine automatically creates an event type when a property expression transposes a property that is a complex type according to the schema.
				</p><p>
					An example:
				</p><pre class="programlisting">ConfigurationEventTypeXMLDOM desc = new ConfigurationEventTypeXMLDOM();
desc.setAutoFragment(false);</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="config-xml-dom-xpathpropertyexpr"></a>11.4.3.6.&nbsp;XPath Property Expression</h4></div></div><div></div></div><p>
					By default Esper employs the built-in DOM walker implementation to evaluate XPath expressions, which is not namespace-aware.
				</p><p>
					This configuration setting, when set to true, instructs the engine to rewrite property expressions into XPath.
				</p><p>
					An example:
				</p><pre class="programlisting">ConfigurationEventTypeXMLDOM desc = new ConfigurationEventTypeXMLDOM();
desc.setXPathPropertyExpr(true);</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="config-xml-dom-eventsendervalidatesroot"></a>11.4.3.7.&nbsp;Event Sender Setting</h4></div></div><div></div></div><p>
					By default an <tt class="literal">EventSender</tt> for a given XML event type validates the root element name for which the type has been declared against the one provided by the <tt class="literal">org.w3c.Node</tt> sent into the engine.
				</p><p>
					This configuration setting, when set to false, instructs an <tt class="literal">EventSender</tt> to not validate.
				</p><p>
					An example:
				</p><pre class="programlisting">ConfigurationEventTypeXMLDOM desc = new ConfigurationEventTypeXMLDOM();
desc.setEventSenderValidatesRoot(false);</pre></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="config-plugineventrep"></a>11.4.4.&nbsp;Events represented by Plug-in Event Representations</h3></div></div><div></div></div><p>
				As part of the extension API plug-in event representations allows an application to create new event types and event instances based on information available elsewhere. Please see <a href="extension.html#custom-event-representation" title="12.5.&nbsp;Custom Event Representation">Section&nbsp;12.5, &#8220;Custom Event Representation&#8221;</a> for details.
			</p><p>
				The configuration examples shown next use the configuration API to select settings. All options are also configurable via XML, please refer to the sample configuration XML in file <tt class="literal">esper.sample.cfg.xml</tt>.
			</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="config-plugineventrep-enable"></a>11.4.4.1.&nbsp;Enabling an Custom Event Representation</h4></div></div><div></div></div><p>
					Use the method <tt class="literal">addPlugInEventRepresentation</tt> to enable a custom event representation, like this:
				</p><pre class="programlisting">URI rootURI = new URI("type://mycompany/myproject/myname");
config.addPlugInEventRepresentation(rootURI, 
    MyEventRepresentation.class.getName(), null);</pre><p>
					The <tt class="literal">type://</tt> part of the URI is an optional convention for the scheme part of an URI. 
				</p><p>
					If your event representation takes initialization parameters, these are passed in as the last parameter. Initialization parameters can also be stored in the configuration XML, in which case
					they are passed as an XML string to the plug-in class.
				</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="config-plugineventrep-types"></a>11.4.4.2.&nbsp;Adding Plug-in Event Types</h4></div></div><div></div></div><p>
					To register event types that your plug-in event representation creates in advance of creating an EPL statement (either at runtime or at configuration time), use the method <tt class="literal">addPlugInEventType</tt>:
				</p><pre class="programlisting">URI childURI = new URI("type://mycompany/myproject/myname/MyEvent");
configuration.addPlugInEventType("MyEvent", new URI[] {childURI}, null);</pre><p>
					Your plug-in event type may take initialization parameters, these are passed in as the last parameter. Initialization parameters can also be stored in the configuration XML.
				</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="config-plugineventrep-resolution"></a>11.4.4.3.&nbsp;Setting Resolution URIs</h4></div></div><div></div></div><p>
					The engine can invoke your plug-in event representation when an EPL statement is created with an event type name that the engine has not seen before. Plug-in event representations can resolve such names to an actual event type. In order to do this, you need to supply a list of resolution URIs. Use the method <tt class="literal">setPlugInEventTypeNameResolutionURIs</tt>, at runtime or at configuration time:
				</p><pre class="programlisting">URI childURI = new URI("type://mycompany/myproject/myname");
configuration.setPlugInEventTypeNameResolutionURIs(new URI[] {childURI});</pre></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="config-class--package-imports"></a>11.4.5.&nbsp;Class and package imports</h3></div></div><div></div></div><p>
				Esper allows invocations of static Java library functions in expressions, as outlined in <a href="functionreference.html#epl-single-row-function-ref" title="8.1.&nbsp;Single-row Function Reference">Section&nbsp;8.1, &#8220;Single-row Function Reference&#8221;</a>. This configuration 
				item can be set to allow a partial rather than a fully qualified class name in such invocations. The imports work in the same way as in Java files, so both packages and classes can be imported.
			</p><pre class="programlisting">select Math.max(priceOne, PriceTwo)
// via configuration equivalent to
select java.lang.Math.max(priceOne, priceTwo)</pre><p>
				Esper auto-imports the following Java library packages if no other configuration is supplied.
				This list is replaced with any configuration specified in a configuration file or through the API.
			</p><div class="itemizedlist"><ul type="disc" compact><li><p>
						java.lang.*
					</p></li><li><p>
						java.math.*
					</p></li><li><p>
						java.text.*
					</p></li><li><p>
						java.util.*
					</p></li></ul></div><p>
				In a XML configuration file the auto-import configuration may look as below:
			</p><pre class="programlisting">&lt;auto-import import-name="com.mycompany.mypackage.*"/&gt;
&lt;auto-import import-name="com.mycompany.myapp.MyUtilityClass"/&gt;</pre><p>
				Here is an example of providing imports via the API:
			</p><pre class="programlisting">Configuration config = new Configuration();
config.addImport("com.mycompany.mypackage.*");	// package import
config.addImport("com.mycompany.mypackage.MyLib");   // class import</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="config-method-invocations"></a>11.4.6.&nbsp;Cache Settings for From-Clause Method Invocations</h3></div></div><div></div></div><p>
				Method invocations are allowed in the <tt class="literal">from</tt> clause in EPL, such that your application may join event streams to the data returned by a web service, or to data read from a distributed cache or object-oriented database, or obtain data by other means. A local cache may be placed in front of such method invocations through the configuration settings described herein.
			</p><p>
				The LRU cache is described in detail in <a href="configuration.html#config-database-cache-lru" title="11.4.8.6.1.&nbsp;LRU Cache">Section&nbsp;11.4.8.6.1, &#8220;LRU Cache&#8221;</a>. The expiry-time cache documentation can be found in <a href="configuration.html#config-database-cache-expiry" title="11.4.8.6.2.&nbsp;Expiry-time Cache">Section&nbsp;11.4.8.6.2, &#8220;Expiry-time Cache&#8221;</a>
			</p><p>
				The next XML snippet is a sample cache configuration that applies to methods provided by the classes 'MyFromClauseLookupLib'  and 'MyFromClauseWebServiceLib'. The XML and API configuration understand both the fully-qualified Java class name, as well as the simple class name:
			</p><pre class="programlisting">&lt;method-reference class-name="com.mycompany.MyFromClauseLookupLib"&gt;
  &lt;expiry-time-cache max-age-seconds="10" purge-interval-seconds="10" ref-type="weak"/&gt;
&lt;/method-reference&gt; 	
&lt;method-reference class-name="MyFromClauseWebServiceLib"&gt;
  &lt;lru-cache size="1000"/&gt;
&lt;/method-reference&gt; </pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="config-variables"></a>11.4.7.&nbsp;Variables</h3></div></div><div></div></div><p>
				Variables can be created dynamically in EPL via the <tt class="literal">create variable</tt> syntax but can also be configured at runtime and at configuration time.
			</p><p>
				A variable is declared by specifying a variable name, the variable type and an optional initialization value. The initialization value can be of the same or compatible type as the variable type, or can also be a String value that, when parsed, is compatible to the type declared for the variable.
			</p><p>
				In a XML configuration file the variable configuration may look as below. The <tt class="literal">Configuration</tt> API can also be used to configure variables.
			</p><pre class="programlisting">&lt;variable name="var_threshold" type="long" initialization-value="100"/&gt;
&lt;variable name="var_key" type="string"/&gt;</pre><p>
				Please find the list of valid values for the <tt class="literal">type</tt> attribute in <a href="configuration.html#configuration-type-names" title="11.5.&nbsp;Type Names">Section&nbsp;11.5, &#8220;Type Names&#8221;</a>.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="config-database-ref"></a>11.4.8.&nbsp;Relational Database Access</h3></div></div><div></div></div><p>
				Esper has the capability to join event streams against historical data sources, such as a relational database. This section describes the configuration entries that the engine requires to access data stored in your database. Please see <a href="epl_clauses.html#histdata_overview" title="4.15.&nbsp;Accessing Relational Data via SQL">Section&nbsp;4.15, &#8220;Accessing Relational Data via SQL&#8221;</a> for information on the use of EPL queries that include historical data sources.
			</p><p>
					EPL queries that poll data from a relational database specify the name of the database as part of the EPL statement. The engine uses the configuration information described here to resolve the database name in the statement to database settings. The required and optional database settings are summarized below. 
			</p><div class="itemizedlist"><ul type="disc" compact><li><p>
						Database connections can be obtained via JDBC <tt class="literal">javax.xml.DataSource</tt>, via <tt class="literal">java.sql.DriverManager</tt> and via data source factory. Either one of these methods to obtain database connections is a required configuration.
					</p></li><li><p>
						Optionally, JDBC connection-level settings such as auto-commit, transaction isolation level, read-only and the catalog name can be defined.
					</p></li><li><p>
						Optionally, a connection lifecycle can be set to indicate to the engine whether the engine must retain connections or must obtain a new connection for each lookup and close the connection when the lookup is done (pooled).
					</p></li><li><p>
						Optionally, define a cache policy to allow the engine to retrieve data from a query cache, reducing the number of query executions.
					</p></li></ul></div><p>
				Some of the settings can have important performance implications that need to be carefully considered in relationship to your database software, JDBC driver and runtime environment. This section attempts to outline such implications where appropriate.
			</p><p>
				The sample XML configuration file in the "etc" folder can be used as a template for configuring database settings. All settings are also available by means of the configuration API through the classes <tt class="literal">Configuration</tt> and <tt class="literal">ConfigurationDBRef</tt>.
			</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="config-database-datasource"></a>11.4.8.1.&nbsp;Connections obtained via DataSource</h4></div></div><div></div></div><p>
					This configuration causes Esper to obtain a database connection from a <tt class="literal">javax.sql.DataSource</tt> available from your JNDI provider.
				</p><p>
					The setting is most useful when running within an application server or when a JNDI directory is otherwise present in your Java VM. If your application environment does not provide an available <tt class="literal">DataSource</tt>, the next section outlines how to use Apache DBCP as a <tt class="literal">DataSource</tt> implementation with connection pooling options and outlines how to use a custom factory for <tt class="literal">DataSource</tt> implementations.
				</p><p>
					If your <tt class="literal">DataSource</tt> provides connections out of a connection pool, your configuration should set the collection lifecycle setting to <tt class="literal">pooled</tt>.
				</p><p>
				The snippet of XML below configures a database named <tt class="literal">mydb1</tt> to obtain connections via a <tt class="literal">javax.sql.DataSource</tt>. The <tt class="literal">datasource-connection</tt> element instructs the engine to obtain new connections to the database <tt class="literal">mydb1</tt> by performing a lookup via <tt class="literal">javax.naming.InitialContext</tt> for the given object lookup name. Optional environment properties for the <tt class="literal">InitialContext</tt> are also shown in the example.
				</p><pre class="programlisting">&lt;database-reference name="mydb1"&gt;
  &lt;datasource-connection context-lookup-name="java:comp/env/jdbc/mydb"&gt;
    &lt;env-property name="java.naming.factory.initial" value ="com.myclass.CtxFactory"/&gt;
    &lt;env-property name="java.naming.provider.url" value ="iiop://localhost:1050"/&gt;
  &lt;/datasource-connection&gt;
&lt;/database-reference&gt;</pre><p>
					To help you better understand how the engine uses this information to obtain connections, we have included the logic below.
				</p><pre class="programlisting">if (envProperties.size() &gt; 0) {
  initialContext = new InitialContext(envProperties);
}
else {
  initialContext = new InitialContext();
}
DataSource dataSource = (DataSource) initialContext.lookup(lookupName);
Connection connection = dataSource.getConnection();</pre><p>
					In order to plug-in your own implementation of the <tt class="literal">DataSource</tt> interface, your application may use an existing JNDI provider as provided by an application server if running in a J2EE environment.
				</p><p>
					In case your application does not have an existing JNDI implementation to register a <tt class="literal">DataSource</tt> to provide connections, you may set the <tt class="literal">java.naming.factory.initial</tt> property in the configuration to point to your application's own implementation of the <tt class="literal">javax.naming.spi.InitialContextFactory</tt> interface that can return your application <tt class="literal">DataSource</tt> though the <tt class="literal">javax.naming.Context</tt> provided by the factory implementation. Please see Java Naming and Directory Interface (JNDI) API documentation for further information.
				</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="config-database-datasourcefactory"></a>11.4.8.2.&nbsp;Connections obtained via DataSource Factory</h4></div></div><div></div></div><p>
					This section describes how to use <a href="http://commons.apache.org/dbcp" target="_top"><i class="citetitle">Apache Commons Database Connection Pooling (Apache DBCP)</i></a> with Esper. We also explain how to provide a custom application-specific <tt class="literal">DataSource</tt> factory if not using Apache DBCP.
				</p><p>
					If your <tt class="literal">DataSource</tt> provides connections out of a connection pool, your configuration should set the collection lifecycle setting to <tt class="literal">pooled</tt>.
				</p><p>
					Apache DBCP provides comprehensive means to test for dead connections or grow and shrik a connection pool. Configuration properties for Apache DBCP can be found at <a href="http://commons.apache.org/dbcp/configuration.html" target="_top"><i class="citetitle">Apache DBCP configuration</i></a>. The listed properties are passed to Apache DBCP via the properties list provided as part of the Esper configuration.
				</p><p>
				   The snippet of XML below is an example that configures a database named <tt class="literal">mydb3</tt> to obtain connections via the pooling <tt class="literal">DataSource</tt> provided by Apache DBCP <tt class="literal">BasicDataSourceFactory</tt>.
				</p><p>
				   The listed properties are passed to DBCP to instruct DBCP how to manage the connection pool. The settings below initialize the connection pool to 2 connections and provide the validation query <tt class="literal">select 1 from dual</tt> for DBCP to validate a connection before providing a connection from the pool to Esper:
				</p><pre class="programlisting">&lt;database-reference name="mydb3"&gt;
  &lt;!-- For a complete list of properties see Apache DBCP. --&gt;
  &lt;datasourcefactory-connection class-name="org.apache.commons.dbcp.BasicDataSourceFactory"&gt;	
    &lt;env-property name="username" value ="myusername"/&gt;
    &lt;env-property name="password" value ="mypassword"/&gt;
    &lt;env-property name="driverClassName" value ="com.mysql.jdbc.Driver"/&gt;
    &lt;env-property name="url" value ="jdbc:mysql://localhost/test"/&gt;
    &lt;env-property name="initialSize" value ="2"/&gt;
    &lt;env-property name="validationQuery" value ="select 1 from dual"/&gt;
  &lt;/datasourcefactory-connection&gt;
  &lt;connection-lifecycle value="pooled"/&gt;
&lt;/database-reference&gt;</pre><p>
					The same configuration options provided through the API:
				</p><pre class="programlisting">Properties props = new Properties();
props.put("username", "myusername");
props.put("password", "mypassword");
props.put("driverClassName", "com.mysql.jdbc.Driver");
props.put("url", "jdbc:mysql://localhost/test");
props.put("initialSize", 2);
props.put("validationQuery", "select 1 from dual");

ConfigurationDBRef configDB = new ConfigurationDBRef();
// BasicDataSourceFactory is an Apache DBCP import
configDB.setDataSourceFactory(props, BasicDataSourceFactory.class.getName());
configDB.setConnectionLifecycleEnum(ConfigurationDBRef.ConnectionLifecycleEnum.POOLED);

Configuration configuration = new Configuration();;
configuration.addDatabaseReference("mydb3", configDB);</pre><p>
					Apache Commons DBCP is a separate download and not provided as part of the Esper distribution. The Apache Commons DBCP jar file requires the Apache Commons Pool jar file.
				</p><p>
					Your application can provide its own factory implementation for <tt class="literal">DataSource</tt> instances: Set the class name to the name of the application class that provides a public static method named <tt class="literal">createDataSource</tt> which takes a single <tt class="literal">Properties</tt> object as parameter and returns a  <tt class="literal">DataSource</tt> implementation. For example:
				</p><pre class="programlisting">configDB.setDataSourceFactory(props, MyOwnDataSourceFactory.class.getName());
...
class MyOwnDataSourceFactory {
  public static DataSource createDataSource(Properties properties) {
    return new MyDataSourceImpl(properties);
  }
}</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="config-database-drivermanager"></a>11.4.8.3.&nbsp;Connections obtained via DriverManager</h4></div></div><div></div></div><p>
				The next snippet of XML configures a database named <tt class="literal">mydb2</tt> to obtain connections via <tt class="literal">java.sql.DriverManager</tt>. The <tt class="literal">drivermanager-connection</tt> element instructs the engine to obtain new connections to the database <tt class="literal">mydb2</tt> by means of <tt class="literal">Class.forName</tt> and <tt class="literal">DriverManager.getConnection</tt> using the class name, URL and optional username, password and connection arguments.
				</p><pre class="programlisting">&lt;database-reference name="mydb2"&gt;
  &lt;drivermanager-connection class-name="my.sql.Driver" 
        url="jdbc:mysql://localhost/test?user=root&amp;amp;password=mypassword" 
        user="myuser" password="mypassword"&gt;
    &lt;connection-arg name="user" value ="myuser"/&gt;
    &lt;connection-arg name="password" value ="mypassword"/&gt;
    &lt;connection-arg name="somearg" value ="someargvalue"/&gt;
  &lt;/drivermanager-connection&gt;
&lt;/database-reference&gt;</pre><p>
					The username and password are shown in multiple places in the XML only as an example. Please check with your database software on the required information in
					URL and connection arguments.
				</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="config-database-connections"></a>11.4.8.4.&nbsp;Connections-level settings</h4></div></div><div></div></div><p>
					Additional connection-level settings can optionally be provided to the engine which the engine will apply to new connections. When the engine obtains a new connection, it applies only those settings to the connection that are explicitly configured. The engine leaves all other connection settings at default values.
				</p><p>
					The below XML is a sample of all available configuration settings. Please refer to the Java API JavaDocs for <tt class="literal">java.sql.Connection</tt> for more information to each option or check the documentation of your JDBC driver and database software.
				</p><pre class="programlisting">&lt;database-reference name="mydb2"&gt;
... configure data source or driver manager settings...
  &lt;connection-settings auto-commit="true" catalog="mycatalog" 
      read-only="true" transaction-isolation="1" /&gt;
&lt;/database-reference&gt;</pre><p>
					The <tt class="literal">read-only</tt> setting can be used to indicate to your database engine that SQL statements are read-only. The <tt class="literal">transaction-isolation</tt> and <tt class="literal">auto-commit</tt> help you database software perform the right level of locking and lock release. Consider setting these values to reduce transactional overhead in your database queries.
				</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="config-database-connections-lifecycle"></a>11.4.8.5.&nbsp;Connections lifecycle settings</h4></div></div><div></div></div><p>
					By default the engine retains a separate database connection for each started EPL statement. However, it is possible to override this behavior and require the engine to obtain a new database connection for each lookup, and to close that database connection after the lookup is completed. This often makes sense when you have a large number of EPL statements and require pooling of connections via a connection pool.
				</p><p>
					In the <tt class="literal">pooled</tt> setting, the engine obtains a database connection from the data source or driver manager for every query, and closes the connection when done, returning the database connection to the pool if using a pooling data source.
				</p><p>
					In the <tt class="literal">retain</tt> setting, the engine retains a separate dedicated database connection for each statement and does not close the connection between uses.
				</p><p>
					The XML for this option is below. The connection lifecycle allows the following values: <tt class="literal">pooled</tt> and <tt class="literal">retain</tt>.
				</p><pre class="programlisting">&lt;database-reference name="mydb2"&gt;
... configure data source or driver manager settings...
    &lt;connection-lifecycle value="pooled"/&gt;
&lt;/database-reference&gt;</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="config-database-cache"></a>11.4.8.6.&nbsp;Cache settings</h4></div></div><div></div></div><p>
					Cache settings can dramatically reduce the number of database queries that the engine executes for EPL statements. If no cache setting is specified, the engine does not cache query results and executes a separate database query for every event.
				</p><p>
					Caches store the results of database queries and make these results available to subsequent queries using the exact same query parameters as the query for which
					the result was stored. If your query returns one or more rows, the cache keep the result rows of the query keyed to the parameters of the query. If your query returns no rows, the cache also keeps the empty result. Query results are held by a cache until the cache entry is evicted. The strategies available for evicting cached 
					query results are listed next.
				</p><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="config-database-cache-lru"></a>11.4.8.6.1.&nbsp;LRU Cache</h5></div></div><div></div></div><p>
						The least-recently-used (LRU) cache is configured by a maximum size. The cache discards the least recently used query results first once the cache reaches the maximum size.
					</p><p>
						The XML configuration entry for a LRU cache is as below. This entry configures an LRU cache holding up to 1000 query results.
					</p><pre class="programlisting">&lt;database-reference name="mydb"&gt;
... configure data source or driver manager settings...
    &lt;lru-cache size="1000"/&gt;
&lt;/database-reference&gt;</pre></div><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="config-database-cache-expiry"></a>11.4.8.6.2.&nbsp;Expiry-time Cache</h5></div></div><div></div></div><p>
						The expiry time cache is configured by a maximum age in seconds, a purge interval and an optional reference type. The cache discards (on the get operation) any query results that are older then the maximum age so that stale data is not used. If the cache is not empty, then every purge interval number of seconds the engine purges any expired entries from the cache.
					</p><p>
						The XML configuration entry for an expiry-time cache is as follows. The example configures an expiry time cache in which prior query results are valid for 60 seconds and which the engine inspects every 2 minutes to remove query results older then 60 seconds.
					</p><pre class="programlisting">&lt;database-reference name="mydb"&gt;
... configure data source or driver manager settings...
    &lt;expiry-time-cache max-age-seconds="60" purge-interval-seconds="120" /&gt;
&lt;/database-reference&gt;</pre><p>
						By default, the expiry-time cache is backed by a <tt class="literal">java.util.WeakHashMap</tt> and thus relies on weak references. That means that cached SQL results can be freed during garbage collection. 
					</p><p>
						Via XML or using the configuration API the type of reference can be configured to not allow entries to be garbage collected, by setting the <tt class="literal">ref-type</tt> property to <tt class="literal">hard</tt>:
					</p><pre class="programlisting">&lt;database-reference name="mydb"&gt;
... configure data source or driver manager settings...
    &lt;expiry-time-cache max-age-seconds="60" purge-interval-seconds="120" ref-type="hard"/&gt;
&lt;/database-reference&gt;</pre></div><p>
						The last setting for the cache reference type is <tt class="literal">soft</tt>: This strategy allows the garbage collection of cache entries only when all other weak references have been collected.
					</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="config-database-columnchangecase"></a>11.4.8.7.&nbsp;Column Change Case</h4></div></div><div></div></div><p>
					This setting instructs the engine to convert to lower- or uppercase any output column names returned by your database system. When using Oracle relational database software, for example, column names
					can be changed to lowercase via this setting.
				</p><p>
					A sample XML configuration entry for this setting is:
				</p><pre class="programlisting">&lt;column-change-case value="lowercase"/&gt;</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="config-database-sqltypes"></a>11.4.8.8.&nbsp;SQL Types Mapping</h4></div></div><div></div></div><p>
					By providing a mapping of SQL types (<tt class="literal">java.sql.Types</tt>) to Java built-in types your code can avoid using sometimes awkward default database types and can easily change the way Esper
					returns Java types for columns returned by a SQL query.
				</p><p>
					The mapping maps a constant as defined by <tt class="literal">java.sql.Types</tt> to a Java built-in type of any of the following Java type names: <tt class="literal">String, BigDecimal, Boolean, Byte, Short, Int, Long, Float, Double, ByteArray, SqlDate, SqlTime, SqlTimestamp</tt>.  The Java type names are not case-sensitive.
				</p><p>
					A sample XML configuration entry for this setting is shown next. The sample maps <tt class="literal">Types.NUMERIC</tt> which is a constant value of <tt class="literal">2</tt> per JDBC API to the Java <tt class="literal">int</tt> type.
				</p><pre class="programlisting">&lt;sql-types-mapping sql-type="2" java-type="int" /&gt;</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="config-database-metadata"></a>11.4.8.9.&nbsp;Metadata Origin</h4></div></div><div></div></div><p>
					This setting controls how the engine retrieves SQL statement metadata from JDBC prepared statements.
				</p><div class="table"><a name="epl-grouping-aggregate-func"></a><p class="title"><b>Table&nbsp;11.3.&nbsp;Syntax and results of aggregate functions</b></p><table summary="Syntax and results of aggregate functions" border="1"><colgroup><col><col></colgroup><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody><tr><td>default</td><td><p>
										By default, the engine detects the driver name and queries prepared statement metadata if the driver is not an Oracle database driver. For Oracle drivers, the engine uses
										lexical analysis of the SQL statement to construct a sample SQL statement and then fires that statement to retrieve statement metadata.
									</p></td></tr><tr><td>metadata</td><td><p>
										The engine always queries prepared statement metadata regardless of the database driver used.
									</p></td></tr><tr><td>sample</td><td><p>
										The engine always uses lexical analysis of the SQL statement to construct a sample SQL statement, and then fires that statement to retrieve statement metadata.
									</p></td></tr></tbody></table></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="config-engine-threading"></a>11.4.9.&nbsp;Engine Settings related to Concurrency and Threading</h3></div></div><div></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="config-engine-threading-dispatch"></a>11.4.9.1.&nbsp;Preserving the order of events delivered to listeners</h4></div></div><div></div></div><p>
					In multithreaded environments, this setting controls whether dispatches of statement result events to listeners preserve the ordering in which a statement processes events. By default the engine guarantees that it delivers a statement's result events to statement listeners in the order in which the result is generated. This behavior can be turned off via configuration as below. 
				</p><p>
					The next code snippet shows how to control this feature:
				</p><pre class="programlisting">Configuration config = new Configuration();
config.getEngineDefaults().getThreading().setListenerDispatchPreserveOrder(false);
engine = EPServiceProviderManager.getDefaultProvider(config);</pre><p>
					And the XML configuration file can also control this feature by adding the following elements:
				</p><pre class="programlisting">&lt;engine-settings&gt;
  &lt;defaults&gt;
    &lt;threading&gt;
      &lt;listener-dispatch preserve-order="true" timeout-msec="1000" locking="spin"/&gt;
    &lt;/threading&gt;
  &lt;/defaults&gt;
&lt;/engine-settings&gt;</pre><p>
					As discussed, by default the engine can temporarily block another processing thread when delivering result events to listeners in order to preserve the order in which results are delivered to a given statement. The maximum time the engine blocks a thread can also be configured, and by default is set to 1 second.
				</p><p>
					As such delivery locks are typically held for a very short amount of time, the default blocking technique employs a spin lock (There are two techniques for implementing blocking; having the operating system suspend the thread until it is awakened later or using spin locks). While spin locks are CPU-intensive and appear inefficient, a spin lock can be more efficient than suspending the thread and subsequently waking it up, especially if the lock in question is held for a very short time. That is because there is significant overhead to suspending and rescheduling a thread.  
				</p><p>
					The locking technique can be changed to use a blocking strategy that suspends the thread, by means of setting the locking property to 'suspend'.
				</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="config-engine-threading-insert-into"></a>11.4.9.2.&nbsp;Preserving the order of events for insert-into streams</h4></div></div><div></div></div><p>
					In multithreaded environments, this setting controls whether statements producing events for other statements via insert-into preserve the order of delivery within the producing and consuming statements, allowing statements that consume other statement's events to behave deterministic in multithreaded applications, if the consuming statement requires such determinism. By default, the engine makes this guarantee (the setting is on).
				</p><p>
					Take, for example, an application where a single statement (S1) inserts events into a stream that another statement (S2) further evaluates. A multithreaded application may have multiple threads processing events into statement S1. As statement S1 produces events for consumption by statement S2, such results may need to be delivered in the exact order produced as the consuming statement may rely on the order received. For example, if the first statement counts the number of events, the second statement may employ a pattern that inspects counts and thus expect the counts posted by statement S1 to continuously increase by 1 even though multiple threads process events. 
				</p><p>
					The engine may need to block a thread such that order of delivery is maintained, and statements that require order (such as pattern detection, previous and prior functions) receive a deterministic order of events. The settings available control the blocking technique and parameters. As described in the section immediately prior, the default blocking technique employs spin locks per statement inserting events for consumption, as the locks in questions are typically held a very short time. The 'suspend' blocking technique can be configured and a timeout value can also defined.
				</p><p>
					The XML configuration file may change settings via the following elements:
				</p><pre class="programlisting">&lt;engine-settings&gt;
  &lt;defaults&gt;
    &lt;threading&gt;
      &lt;insert-into-dispatch preserve-order="true" timeout-msec="100" locking="spin"/&gt;
    &lt;/threading&gt;
  &lt;/defaults&gt;
&lt;/engine-settings&gt;</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="config-engine-threading-internal-timer"></a>11.4.9.3.&nbsp;Internal Timer Settings</h4></div></div><div></div></div><p>
					This option can be used to disable the internal timer thread and such have the application supply external time events, as well as to set a timer resolution.
				</p><p>
					The next code snippet shows how to disable the internal timer thread via the configuration API:
				</p><pre class="programlisting">Configuration config = new Configuration();
  config.getEngineDefaults().getThreading().setInternalTimerEnabled(false);</pre><p>
					This snippet of XML configuration leaves the internal timer enabled (the default) and sets a resolution of 200 milliseconds (the default is 100 milliseconds):
				</p><pre class="programlisting">&lt;engine-settings&gt;
  &lt;defaults&gt;
    &lt;threading&gt;
      &lt;internal-timer enabled="true" msec-resolution="200"/&gt;
    &lt;/threading&gt;
  &lt;/defaults&gt;
&lt;/engine-settings&gt;</pre><p>
					We recommend that when disabling the internal timer, applications send an external timer event setting the start time before creating statements,
					such that statement start time is well-defined.
				</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="config-engine-threading-advanced"></a>11.4.9.4.&nbsp;Advanced Threading Options</h4></div></div><div></div></div><p>
					The settings described herein are for enabling advanced threading options for inbound, outbound, timer and route executions.
				</p><p>
					Take the next snippet of XML configuration as an example. It configures all threading options to 2 threads, which may not be suitable to your application, however demonstrates the configuration:
				</p><pre class="programlisting">&lt;engine-settings&gt;
  &lt;defaults&gt;
    &lt;threading&gt;
      &lt;threadpool-inbound enabled="true" num-threads="2"/&gt;
      &lt;threadpool-outbound enabled="true" num-threads="2" capacity="1000"/&gt;
      &lt;threadpool-timerexec enabled="true" num-threads="2"/&gt;
      &lt;threadpool-routeexec enabled="true" num-threads="2"/&gt;
    &lt;/threading&gt;
  &lt;/defaults&gt;
&lt;/engine-settings&gt;</pre><p>
					By default, queues are unbound and backed by <tt class="literal">java.util.concurrent.LinkedBlockingQueue</tt>. 
					The optional <tt class="literal">capacity</tt> attribute can be set to instruct the threading option to configure a capacity-bound queue with a sender-wait (blocking put) policy, backed <tt class="literal">ArrayBlockingQueue</tt>.
				</p><p>
					This example uses the API for configuring inbound threading :
				</p><pre class="programlisting">Configuration config = new Configuration();
config.getEngineDefaults().getThreading().setThreadPoolInbound(true);
config.getEngineDefaults().getThreading().setThreadPoolInboundNumThreads(2);</pre><p>
					With a bounded work queue, the queue size and pool size should be tuned together. A large queue coupled with a small pool can help reduce memory usage, CPU usage, and context switching, at the cost of potentially constraining throughput.
				</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="config-engine-eventmeta"></a>11.4.10.&nbsp;Engine Settings related to Event Metadata</h3></div></div><div></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="config-engine-eventmeta-propertyreso"></a>11.4.10.1.&nbsp;Java Class Property Names and Case Sensitivity</h4></div></div><div></div></div><p>
				  As discussed in <a href="configuration.html#config-java-property-case-sensitivity" title="11.4.1.6.&nbsp;Case Sensitivity and Property Names">Section&nbsp;11.4.1.6, &#8220;Case Sensitivity and Property Names&#8221;</a> this setting controls case sensitivity for Java event class properties of all Java classes as a default, rather then at a class level.
				</p><p>
					The next code snippet shows how to control this feature via the API:
				</p><pre class="programlisting">Configuration config = new Configuration();
config.getEngineDefaults().getEventMeta().setClassPropertyResolutionStyle(
    Configuration.PropertyResolutionStyle.CASE_INSENSITIVE);</pre></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="config-engine-viewresources"></a>11.4.11.&nbsp;Engine Settings related to View Resources</h3></div></div><div></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="config-engine-viewresources-sharing"></a>11.4.11.1.&nbsp;Sharing View Resources between Statements</h4></div></div><div></div></div><p>
				   The engine by default attempts to optimize resource usage and thus re-uses or shares views between statements that declare same views. However, in multi-threaded environments, this can lead to reduced concurrency as 
				   locking for shared view resources must take place. Via this setting this behavior can be turned off for higher concurrency in multi-threaded processing.
				</p><p>
					The next code snippet outlines the API to turn off view resource sharing between statements:
				</p><pre class="programlisting">Configuration config = new Configuration();
config.getEngineDefaults().getViewResources().setShareViews(false);</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="config-engine-viewresources-multipolicy"></a>11.4.11.2.&nbsp;Configuring Multi-Expiry Policy Defaults</h4></div></div><div></div></div><p>
				   By default, when combining multiple data window views, Esper applies an intersection of the data windows unless the <tt class="literal">retain-union</tt> keyword is provided which instructs to apply an union. The setting described herein may be used primarily for backward compatibility to instruct that intersection should not be the default.
				</p><p>
				   Here is a sample statement that specifies multiple expiry policies:
				</p><pre class="programlisting">select * from MyEvent.std:unique(price).std:unique(quantity)</pre><p>
				   By default Esper applies intersection as described in <a href="epl_clauses.html#epl-from-clause-view-multidatawindow" title="4.4.4.&nbsp;Multiple Data Window Views">Section&nbsp;4.4.4, &#8220;Multiple Data Window Views&#8221;</a>. 
				</p><p>
				   Here is the setting to allow multiple data windows without the intersection default:
				</p><pre class="programlisting">Configuration config = new Configuration();
config.getEngineDefaults().getViewResources().setAllowMultipleExpiryPolicies(true);</pre><p>
				   When setting this option to true, and when using multiple data window views for a given stream, the behavior is as follows: The top-most data window receives an insert stream of events. It passes each insert stream event to each further data window view in the chain. Each data window view may remove events according to its expiry policy. Such remove stream events are only passed to data window views further in the chain, and are not made available to data window views earlier in the chain.
				</p><p>
				   It is recommended to leave the default setting at false.
				</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="config-engine-logging"></a>11.4.12.&nbsp;Engine Settings related to Logging</h3></div></div><div></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="config-engine-logging-execpath"></a>11.4.12.1.&nbsp;Execution Path Debug Logging</h4></div></div><div></div></div><p>
				   By default, the engine does not produce debug output for the event processing execution paths even when Log4j or Logger configurations have been set to output debug level logs.
				   To enable debug level logging, set this option in the configuration as well as in your Log4j configuration file.
				</p><p>
				   When debug-level logging is enabled by setting the flag as below and by setting DEBUG in the Log4j configuration file, then the timer processing may produce extensive debug output that
				   you may not want to have in the log file. The <tt class="literal">timer-debug</tt> setting in the XML or via API as below disables timer debug output which is enabled by default.
				</p><p>
					The API to use to enable debug logging and disable timer event output is shown here:
				</p><pre class="programlisting">Configuration config = new Configuration();
config.getEngineDefaults().getLogging().setEnableExecutionDebug(true);
config.getEngineDefaults().getLogging().setEnableTimerDebug(false);</pre><p>
					Note: this is a configuration option that applies to all engine instances of a given Java module or VM.
				</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="config-engine-variables"></a>11.4.13.&nbsp;Engine Settings related to Variables</h3></div></div><div></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="config-engine-variables-lifetimeold"></a>11.4.13.1.&nbsp;Variable Version Release Interval</h4></div></div><div></div></div><p>
				   This setting controls the length of time that the engine retains variable versions for use by statements that use variables and that execute, within the same statement for the same event, longer then the time interval.
				   By default, the engine retains 15 seconds of variable versions.
				</p><p>
				   For statements that use variables and that execute (in response to a single timer or other event) longer then the time period, the engine returns the current variable version at the time the statement executes, thereby softening the guarantee of consistency of variable values within the long-running statement. Please see <a href="epl_clauses.html#variable_using" title="4.19.3.&nbsp;Using Variables">Section&nbsp;4.19.3, &#8220;Using Variables&#8221;</a> for more information.
				</p><p>
					The XML configuration for this setting is shown below:
				</p><pre class="programlisting">&lt;engine-settings&gt;
  &lt;defaults&gt;
    &lt;variables&gt;
      &lt;msec-version-release value="15000"/&gt;
    &lt;/variables&gt;
  &lt;/defaults&gt;
&lt;/engine-settings&gt;</pre></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="config-engine-stream-selection"></a>11.4.14.&nbsp;Engine Settings related to Stream Selection</h3></div></div><div></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="config-engine-streamselect-choices"></a>11.4.14.1.&nbsp;Default Statement Stream Selection</h4></div></div><div></div></div><p>
				   Statements can produce both insert stream (new data) and remove stream (old data) results. Remember that insert stream refers to arriving events and new aggregation values, while remove stream refers to events leaving data windows and prior aggregation values. By default, the engine delivers only the insert stream to listeners and observers of a statement.
				</p><p>
				   There are keywords in the <tt class="literal">select</tt> clause that instruct the engine to not generate insert stream and/or remove stream results if your application does not need either one of the streams. These keywords are the <tt class="literal">istream</tt>, <tt class="literal">rstream</tt> and the <tt class="literal">irstream</tt> keywords. 
				</p><p>
				   By default, the engine only generates insert stream results equivalent to using the optional <tt class="literal">istream</tt> keyword in the <tt class="literal">select</tt> clause.
				   If you application requires insert and remove stream results for many statements, your application can add the <tt class="literal">irstream</tt> keyword to the <tt class="literal">select</tt> clause of each statement,
				   or you can set a new default stream selector via this setting.
				</p><p>
					The XML configuration for this setting is shown below:
				</p><pre class="programlisting">&lt;engine-settings&gt;
  &lt;defaults&gt;
    &lt;stream-selection&gt;
      &lt;stream-selector value="irstream" /&gt;
    &lt;/stream-selection&gt;
  &lt;/defaults&gt;
&lt;/engine-settings&gt;</pre><p>
					The equivalent code snippet using the configuration API is here:
				</p><pre class="programlisting">Configuration config = new Configuration();
config.getEngineDefaults().getStreamSelection()
    .setDefaultStreamSelector(StreamSelector.RSTREAM_ISTREAM_BOTH);</pre></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="config-engine-time-source"></a>11.4.15.&nbsp;Engine Settings related to Time Source</h3></div></div><div></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="config-engine-timesource-choices"></a>11.4.15.1.&nbsp;Default Time Source</h4></div></div><div></div></div><p>
				   This setting only applies if internal timer events control engine time (default). If external timer events provide engine clocking, the setting does not apply.
				</p><p>
				   By default, the internal timer uses the call <tt class="literal">System.currentTimeMillis()</tt> to determine engine time in milliseconds. Via this setting the internal timer can be instructed to use <tt class="literal">System.nanoTime()</tt> instead. Please see <a href="api.html#api-time-resolution" title="10.8.&nbsp;Time Resolution">Section&nbsp;10.8, &#8220;Time Resolution&#8221;</a> for more information. 
				</p><p>
					Note: This is a Java VM global setting. If running multiple engine instances in a Java VM, the timer setting is global and applies to all engine instances in the same Java VM, for performance reasons.
				</p><p>
					A sample XML configuration for this setting is shown below, whereas the sample setting sets the time source to the nanosecond time provider:
				</p><pre class="programlisting">&lt;engine-settings&gt;
  &lt;defaults&gt;
    &lt;time-source&gt;
      &lt;time-source-type value="nano" /&gt;
    &lt;/time-source&gt;
  &lt;/defaults&gt;
&lt;/engine-settings&gt;</pre><p>
					The equivalent code snippet using the configuration API is here:
				</p><pre class="programlisting">Configuration config = new Configuration();
config.getEngineDefaults().getTimeSource().
      setTimeSourceType(ConfigurationEngineDefaults.TimeSourceType.NANO);</pre></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="config-engine-instrumentation"></a>11.4.16.&nbsp;Engine Settings related to Metrics Reporting</h3></div></div><div></div></div><p>
				This section explains how to enable and configure metrics reporting, which is by default disabled. Please see <a href="api.html#api-instrumentation" title="10.12.&nbsp;Engine and Statement Metrics Reporting">Section&nbsp;10.12, &#8220;Engine and Statement Metrics Reporting&#8221;</a> for more information on the metrics data reported to your application.
			</p><p>
				The flag that enables metrics reporting is global to a Java virtual machine. If metrics reporting is enabled, the overhead incurred for reporting metrics is carried by all engine instances per Java VM.
			</p><p>
				Metrics reporting occurs by an engine-controlled separate daemon thread that each engine instance starts at engine initialization time, if metrics reporting and threading is enabled (threading enabled is the default).
			</p><p>
			    Engine and statement metric intervals are in milliseconds. A negative or zero millisecond interval value may be provided to disable reporting.
			</p><p>
			    To control statement metric reporting for individual statements or groups of statements, the engine provides a facility that groups statements by statement name. 
			    Each such statement group may have different reporting intervals configured, and intervals can be
			    changed at runtime through runtime configuration. A statement group is assigned a group name at configuration time to identify the group.
			</p><p>
			    Metrics reporting configuration is part of the engine default settings. All configuration options are also available via the <tt class="literal">Configuration</tt> API.
			</p><p>
			    A sample XML configuration is shown below:
			</p><pre class="programlisting">&lt;engine-settings&gt;
  &lt;defaults&gt;
    &lt;metrics-reporting enabled="true" engine-interval="1000" statement-interval="1000" 
        threading="true"/&gt;
  &lt;/defaults&gt;
&lt;/engine-settings&gt;</pre><p>
			    The <tt class="literal">engine-interval</tt> setting (defaults to 10 seconds) determines the frequency in milliseconds at which the engine reports engine metrics, in this example every 1 second. The <tt class="literal">statement-interval</tt> is for statement metrics. The <tt class="literal">threading</tt> flag is true by default since reporting takes place by a dedicated engine thread and can be set to false to use the external or internal timer thread instead.
			</p><p>
			    The next example XML declares a statement group: The statements that have statement names that fall within the group follow a different reporting frequency:
			</p><pre class="programlisting">&lt;metrics-reporting enabled="true" statement-interval="0"&gt;
  &lt;stmtgroup name="MyStmtGroup" interval="2000" default-include="true" num-stmts="100" 
        report-inactive="true"&gt;
    &lt;exclude-regex&gt;.*test.*&lt;/exclude-regex&gt;
  &lt;/stmtgroup&gt;
&lt;/metrics-reporting&gt;</pre><p>
			    The above example configuration sets the <tt class="literal">statement-interval</tt> to zero to disable reporting for all statements. It defines a statement group by name <tt class="literal">MyStmtGroup</tt> and specifies a 2-second interval. The example sets the <tt class="literal">default-include</tt> flag to true (by default false) to include all statements in the statement group. The example also sets <tt class="literal">report-inactive</tt> to true (by default false) to report inactive statements.
			</p><p>
			  The <tt class="literal">exclude-regex</tt> element may be used to specify a regular expression that serves to exclude statements from the group. Any statement whose statement name matches the exclude regular expression is not included in the group. In the above example, all statements with the characters 'test' inside their statement name are excluded from the group.
			</p><p>
			  Any statement not belonging to any of the statement groups follow the configured statement interval. 
			</p><p>
			 There are additional elements available to include and exclude statements: <tt class="literal">include-regex</tt>, <tt class="literal">include-like</tt> and <tt class="literal">exclude-like</tt>. The latter two apply SQL-like matching. All patterns are case-sensitive.
			</p><p>
			 Here is a further example of a possible statement group definition, which includes statements whose statement name have the characters <tt class="literal">@REPORT</tt> or <tt class="literal">@STREAM</tt>, and excludes statements whose statement name have the characters <tt class="literal">@IGNORE</tt> or <tt class="literal">@METRICS</tt> inside.
			</p><pre class="programlisting">&lt;metrics-reporting enabled="true"&gt;
  &lt;stmtgroup name="MyStmtGroup" interval="1000"&gt;
    &lt;include-like&gt;%@REPORT%&lt;/include-like&gt;
    &lt;include-regex&gt;.*@STREAM.*&lt;/include-like&gt;
    &lt;exclude-like&gt;%@IGNORE%&lt;/exclude-like&gt;
    &lt;exclude-regex&gt;.*@METRICS.*&lt;/exclude-regex&gt;
  &lt;/stmtgroup&gt;
&lt;/metrics-reporting&gt;</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="config-engine-language"></a>11.4.17.&nbsp;Engine Settings related to Language and Locale</h3></div></div><div></div></div><p>
				Locale-dependence in Esper can be present in the sort order of string values by the <tt class="literal">order by</tt> clause and by the sort view.
			</p><p>
				By default, Esper sorts string values using the <tt class="literal">compare</tt> method that is not locale dependent. To enable local dependent sorting you must set the configuration flag as described below.
			</p><p>
			 The XML configuration sets the locale dependent sorting as shown below:
			</p><pre class="programlisting">&lt;engine-settings&gt;
  &lt;defaults&gt;
    &lt;language sort-using-collator="true"/&gt;
  &lt;/defaults&gt;
&lt;/engine-settings&gt;</pre><p>
			 The API to change the setting:
			</p><pre class="programlisting">Configuration config = new Configuration();
config.getEngineDefaults().getLanguage().setSortUsingCollator(true);</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="config-engine-expression"></a>11.4.18.&nbsp;Engine Settings related to Expression Evaluation</h3></div></div><div></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="config-engine-expression-division"></a>11.4.18.1.&nbsp;Integer Division and Division by Zero</h4></div></div><div></div></div><p>
					By default Esper returns double-typed values for divisions regardless of operand types. Division by zero returns positive or negative double infinity.
				</p><p>
					To have Esper use Java-standard integer division instead, use this setting as described here. In Java integer division, when dividing integer types, the result is an integer type. This means that if you divide an integer unevenly by another integer, it returns the whole number part of the result, does not perform any rounding and the fraction part is dropped. If Java-standard integer division is enabled, when dividing an integer numerator by an integer denominator, the result is an integer number. Thus the expression <tt class="literal">1 / 4</tt> results in an integer zero. Your EPL must then convert at least one of the numbers to a double value before the division, for example by specifying <tt class="literal">1.0 / 4</tt> or by using <tt class="literal">cast(myint, double)</tt>.
				</p><p>
					When using Java integer division, division by zero for integer-typed operands always returns null. However division by zero for double-type operands still returns positive or negative double infinity. To also return null upon division by zero for double-type operands, set the flag to true as below (default is false).
				</p><p>
				 The XML configuration is as follows:
				</p><pre class="programlisting">&lt;engine-settings&gt;
  &lt;defaults&gt;
    &lt;expression integer-division="false" division-by-zero-is-null="false"/&gt;
  &lt;/defaults&gt;
&lt;/engine-settings&gt;</pre><p>
				 The API to change the setting:
				</p><pre class="programlisting">Configuration config = new Configuration();
config.getEngineDefaults().getExpression().setIntegerDivision(true);
config.getEngineDefaults().getExpression().setDivisionByZeroReturnsNull(true);</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="config-engine-expression-subselecteval"></a>11.4.18.2.&nbsp;Subselect Evaluation Order</h4></div></div><div></div></div><p>
					By default Esper updates sub-selects with new events before evaluating the enclosing statement. This is relevant for statements that look for the same event in both the <tt class="literal">from</tt> clause and subselects.
				</p><p>
					To have Esper evaluate the enclosing clauses before updating the subselect in a subselect expression, set the flag as indicated herein.
				</p><p>
					 The XML configuration as below sets the same as the default value:
				</p><pre class="programlisting">&lt;engine-settings&gt;
  &lt;defaults&gt;
    &lt;expression self-subselect-preeval="true"/&gt;
  &lt;/defaults&gt;
&lt;/engine-settings&gt;</pre><p>
					 Here is a sample statement that utilitzes a sub-select against the same-events:
				</p><pre class="programlisting">select * from MyEvent where prop not in (select prop from MyEvent.std:unique(otherProp))</pre><p>
					 By default the subselect data window updates first before the <tt class="literal">where</tt> clause is evaluated, thereby above statement never returns results.
				</p><p>
					 Changing the setting described here causes the <tt class="literal">where</tt> clause to evaluate before the subselect data window updates, thereby the statement does post results.
				</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="config-engine-expression-udfcache"></a>11.4.18.3.&nbsp;User-Defined Function or Static Method Cache</h4></div></div><div></div></div><p>
					By default Esper caches the result of an user-defined function if the parameter set to that function is empty or all parameters are constant values.
				</p><p>
					To have Esper evaluate the user-defined function regardless of constant parameters, set the flag as indicated herein.
				</p><p>
					 The XML configuration as below sets the same as the default value:
				</p><pre class="programlisting">&lt;engine-settings&gt;
  &lt;defaults&gt;
    &lt;expression udf-cache="true"/&gt;
  &lt;/defaults&gt;
&lt;/engine-settings&gt;</pre></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="config-engine-execution"></a>11.4.19.&nbsp;Engine Settings related to Execution of Statements</h3></div></div><div></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="config-engine-execution-prioritized"></a>11.4.19.1.&nbsp;Prioritized Execution</h4></div></div><div></div></div><p>
					By default Esper ignores @Priority and @Drop annotations and executes unprioritized, that is the engine does not attempt to interpret assigned priorities and reorder executions based on priority. Use this setting if your application requires prioritized execution.
				</p><p>
					By setting this configuration, the engine executes statements, when an event or schedule matches multiple statements, according to the assigned priority, starting from the highest priority value. See built-in EPL annotations in <a href="epl_clauses.html#epl-syntax-annotation-priority" title="4.2.5.6.&nbsp;@Priority">Section&nbsp;4.2.5.6, &#8220;@Priority&#8221;</a>.
				</p><p>
					By enabling this setting view sharing between statements as described in <a href="configuration.html#config-engine-viewresources-sharing" title="11.4.11.1.&nbsp;Sharing View Resources between Statements">Section&nbsp;11.4.11.1, &#8220;Sharing View Resources between Statements&#8221;</a> is disabled.
				</p><p>
					 The XML configuration is as follows:
				</p><pre class="programlisting">&lt;engine-settings&gt;
  &lt;defaults&gt;
    &lt;execution prioritized="true"/&gt;
  &lt;/defaults&gt;
&lt;/engine-settings&gt;</pre><p>
				 The API to change the setting:
				</p><pre class="programlisting">Configuration config = new Configuration();
config.getEngineDefaults().getExecution().setPrioritized(true);</pre></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="config-revisionevent"></a>11.4.20.&nbsp;Revision Event Type</h3></div></div><div></div></div><p>
			   Revision event types reflect an update or versioning relationship between events of same or different event types. Please refer to <a href="event_representation.html#eventrep-update" title="2.9.&nbsp;Updating and Versioning Events">Section&nbsp;2.9, &#8220;Updating and Versioning Events&#8221;</a> and <a href="epl_clauses.html#named_update" title="4.17.8.&nbsp;Updating and Versioning Events in Named Windows">Section&nbsp;4.17.8, &#8220;Updating and Versioning Events in Named Windows&#8221;</a>.
			</p><p>
				The configuration consists of the following:
			</p><div class="itemizedlist"><ul type="disc" compact><li><p>
						An name of an event type whose events are <span class="emphasis"><em>base</em></span> events.
					</p></li><li><p>
						Zero, one or more names of event types whose events are <span class="emphasis"><em>delta</em></span> events.
					</p></li><li><p>
						One or more property names that supply the key values that tie base and delta events to existing revision events. Properties must exist on the event type as simple properties. Nested, indexed or mapped properties are not allowed.
					</p></li><li><p>
						Optionally, a strategy for overlaying or merging properties. The default strategy is <span class="emphasis"><em>Overlay Declared</em></span> as described below.
					</p></li></ul></div><p>
				The XML configuration for this setting is shown below:
			</p><pre class="programlisting">&lt;revision-event-type name="UserProfileRevisions"&gt;
  &lt;base-event-type name="ProfileCreation"/&gt;
  &lt;delta-event-type name="ProfileUpdate"/&gt;
  &lt;key-property name="userid"/&gt;
&lt;/revision-event-type&gt;</pre><p>
				If configuring via runtime or initialization-time API, this code snippet explains how:
			</p><pre class="programlisting">Configuration config = new Configuration();
ConfigurationRevisionEventType configRev = new ConfigurationRevisionEventType();
configRev.setNameBaseEventType("ProfileCreation");
configRev.addNameDeltaEventType("ProfileUpdate");
configRev.setKeyPropertyNames(new String[] {"userid"});
config.addRevisionEventType("UserProfileRevisions", configRev);</pre><p>
				As the configuration provides names of base and delta event types, such names must be configured for JavaBean, Map or XML events as the previous sections outline.
			</p><p>
				The next table outlines the available strategies:
			</p><div class="table"><a name="d0e20842"></a><p class="title"><b>Table&nbsp;11.4.&nbsp;Property Revision Strategies</b></p><table summary="Property Revision Strategies" border="1"><colgroup><col><col></colgroup><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td>Overlay Declared (default)</td><td><p>A fast strategy for revising events that groups properties provided by base and delta events and overlays contributed properties to compute a revision.</p><p>For use when there is a limited number of combinations of properties that change on an event, and such combinations are known in advance.</p><p>The properties available on the output revision events are all properties of the base event type. Delta event types do not add any additional properties that are not present on the base event type.</p><p>Any null values or non-existing property on a delta (or base) event results in a null values for the same property on the output revision event.</p></td></tr><tr><td>Merge Declared</td><td><p>A strategy for revising events by merging properties provided by base and delta events, considering null values and non-existing (dynamic) properties as well.</p><p>For use when there is a limited number of combinations of properties that change on an event, and such combinations are known in advance.</p><p>The properties available on the output revision events are all properties of the base event type plus all additional properties that any of the delta event types provide.</p><p>Any null values or non-existing property on a delta (or base) event results in a null values for the same property on the output revision event.</p></td></tr><tr><td>Merge Non-null</td><td><p>A strategy for revising events by merging properties provided by base and delta events, considering only non-null values.</p><p>For use when there is an unlimited number of combinations of properties that change on an event, or combinations are not known in advance.</p><p>The properties available on the output revision events are all properties of the base event type plus all additional properties that any of the delta event types provide.</p><p>Null values returned by delta (or base) event properties provide no value to output revision events, i.e. null values are not merged.</p></td></tr><tr><td>Merge Exists</td><td><p>A strategy for revising events by merging properties provided by base and delta events, considering only values supplied by event properties that exist.</p><p>For use when there is an unlimited number of combinations of properties that change on an event, or combinations are not known in advance.</p><p>The properties available on the output revision events are all properties of the base event type plus all additional properties that any of the delta event types provide.</p><p>All properties are treated as dynamic properties: If an event property does not exist on a delta event (or base) event the property provides no value to output revision events, i.e. non-existing property values are not merged.</p></td></tr></tbody></table></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="config-variantstream"></a>11.4.21.&nbsp;Variant Stream</h3></div></div><div></div></div><p>
			   A <span class="emphasis"><em>variant stream</em></span> is a predefined stream into which events of multiple disparate event types can be inserted, and which can be selected from in patterns and the <tt class="literal">from</tt> clause.
			</p><p>
				The name of the variant stream and, optionally, the type of events that the stream may accept, are part of the stream definition. By default, the variant stream accepts only the predefined event types. The engine validates your <tt class="literal">insert into</tt> clause which inserts into the variant stream against the predefined types.
			</p><p>
				A variant stream can be set to accept any type of event, in which case all properties of the variant stream are effectively dynamic properties. Set the <tt class="literal">type variance</tt> flag to <tt class="literal">ANY</tt> to indicate the variant stream accepts any type  of event.
			</p><p>
				The following XML configuration defines a variant stream by name <tt class="literal">OrderStream</tt> that carries only <tt class="literal">PartsOrder</tt> and <tt class="literal">ServiceOrder</tt> events:
			</p><pre class="programlisting">&lt;variant-stream name="OrderStream"&gt;
  &lt;variant-event-type name="PartsOrder"/&gt;
  &lt;variant-event-type name="ServiceOrder"/&gt;
&lt;/variant-stream&gt;</pre><p>
				This code snippet sets up a variant stream by name <tt class="literal">OutgoingEvent</tt>:
			</p><pre class="programlisting">Configuration config = new Configuration();
ConfigurationVariantStream variant = new ConfigurationVariantStream();
variant.setTypeVariance(ConfigurationVariantStream.TypeVariance.ANY);
config.addVariantStream("OutgoingEvent", variant);</pre><p>
				If specifying variant event type names, make sure such names have been configured for JavaBean, Map or XML events.
			</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-type-names"></a>11.5.&nbsp;Type Names</h2></div></div><div></div></div><p>
			Certain configuration values accept type names. Type names can occur in the configuration of variable types, Map-event property types as well as XPath cast types, for example. Types names are not case-sensitive.
		</p><p>
			The table below outlines all possible type names:
		</p><div class="table"><a name="d0e20956"></a><p class="title"><b>Table&nbsp;11.5.&nbsp;Variable Type Names</b></p><table summary="Variable Type Names" border="1"><colgroup><col><col></colgroup><thead><tr><th>Type Name</th><th>Type</th></tr></thead><tbody><tr><td><tt class="literal">string</tt>, <tt class="literal">varchar</tt>, <tt class="literal">varchar2</tt> or <tt class="literal">java.lang.String</tt></td><td>A string value</td></tr><tr><td><tt class="literal">int</tt>, <tt class="literal">integer</tt> or <tt class="literal">java.lang.Integer</tt></td><td>An integer value</td></tr><tr><td><tt class="literal">long</tt> or <tt class="literal">java.lang.Long</tt></td><td>A long value</td></tr><tr><td><tt class="literal">bool</tt>, <tt class="literal">boolean</tt> or <tt class="literal">java.lang.Boolean</tt></td><td>A boolean value</td></tr><tr><td><tt class="literal">double</tt> or <tt class="literal">java.lang.Double</tt></td><td>A double value</td></tr><tr><td><tt class="literal">float</tt> or <tt class="literal">java.lang.Float</tt></td><td>A float value</td></tr><tr><td><tt class="literal">short</tt> or <tt class="literal">java.lang.Short</tt></td><td>A short value</td></tr><tr><td><tt class="literal">char</tt>, <tt class="literal">character</tt> or <tt class="literal">java.lang.Character</tt></td><td>A character value</td></tr><tr><td><tt class="literal">byte</tt> or <tt class="literal">java.lang.Byte</tt></td><td>A byte value</td></tr></tbody></table></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="configuration-runtime"></a>11.6.&nbsp;Runtime Configuration</h2></div></div><div></div></div><a class="indexterm" name="d0e21068"></a><p>
			Certain configuration changes are available to perform on an engine instance while in operation. Such configuration operations are available via the <tt class="literal">getConfiguration</tt> method on <tt class="literal">EPAdministrator</tt>,
			which returns an <tt class="literal">ConfigurationOperations</tt> object. Please consult the JavaDoc documentation for more detail.
		</p></div></div><hr xmlns="http://www.w3.org/TR/xhtml1/transitional"><center xmlns="http://www.w3.org/TR/xhtml1/transitional">&copy; 2009 EsperTech Inc. All Rights Reserved</center><script xmlns="http://www.w3.org/TR/xhtml1/transitional" type="text/javascript">
	var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
	document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
	</script><script xmlns="http://www.w3.org/TR/xhtml1/transitional" type="text/javascript">
	var pageTracker = _gat._getTracker("UA-1261295-1");
	pageTracker._trackPageview();
	</script><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="api.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="index.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="extension.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter&nbsp;10.&nbsp;API Reference&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;12.&nbsp;Extension and Plug-in</td></tr></table></div></body></html>