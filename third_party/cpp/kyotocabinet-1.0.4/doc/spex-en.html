<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>
<meta http-equiv="Content-Language" content="en" />
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta http-equiv="Content-Style-Type" content="text/css" />
<meta name="author" content="Mikio Hirabayashi" />
<meta name="keywords" content="Kyoto Cabinet, kyotocabinet, database, DBM" />
<meta name="description" content="Specifications of Kyoto Cabinet" />
<link rel="contents" href="./" />
<link rel="stylesheet" href="common.css" />
<link rel="icon" href="icon16.png" />
<link rev="made" href="mailto:hirarin@gmail.com" />
<title>Fundamental Specifications of Kyoto Cabinet Version 1</title>
</head>

<body>

<h1 id="headline">Fundamental Specifications of Kyoto Cabinet Version 1</h1>

<div class="note">Copyright (C) 2009-2010 Mikio Hirabayashi</div>
<div class="note">Last Update: Sat, 17 Apr 2010 01:28:52 +0900</div>

<hr />

<h2 id="contents">Table of Contents</h2>

<ol>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#features">Features</a></li>
<li><a href="#installation">Installation</a></li>
<li><a href="#tutorial">Tutorial</a></li>
<li><a href="#command">Command Line Utilities</a></li>
<li><a href="#tips">Tips and Hacks</a></li>
<li><a href="#license">License</a></li>
</ol>

<hr />

<h2 id="introduction">Introduction</h2>

<p>Kyoto Cabinet is a library of routines for managing a database.  The database is a simple data file containing records, each is a pair of a key and a value.  Every key and value is serial bytes with variable length.  Both binary data and character string can be used as a key and a value.  Each key must be unique within a database.  There is neither concept of data tables nor data types.  Records are organized in hash table or B+ tree.</p>

<p>The following access methods are provided to the database: storing a record with a key and a value, deleting a record by a key, retrieving a record by a key.  Moreover, traversal access to every key are provided.  These access methods are similar to ones of the original DBM (and its followers: NDBM and GDBM) library defined in the UNIX standard.  Kyoto Cabinet is an alternative for the DBM because of its higher performance.</p>

<p>Each operation of the hash database has the time complexity of "O(1)".  Therefore, in theory, the performance is constant regardless of the scale of the database.  In practice, the performance is determined by the speed of the main memory or the storage device.  If the size of the database is less than the capacity of the main memory, the performance will seem on-memory speed, which is faster than std::map of STL.  Of course, the database size can be greater than the capacity of the main memory and the upper limit is 8 exabytes.  Even in that case, each operation needs only one or two seeking of the storage device.</p>

<p>Each operation of the B+ tree database has the time complexity of "O(log N)".  Therefore, in theory, the performance is logarithmic to the scale of the database.  Although the performance of random access of the B+ tree database is slower than that of the hash database, the B+ tree database supports sequential access in order of the keys, which realizes forward matching search for strings and range search for integers.  The performance of sequential access is much faster than that of random access.</p>

<p>As the API is based on object-oriented design, the hash database and the the B+ tree database have same methods which inherited from the upper abstract class.  Beside them, two kinds of databases are provided under the same base class.  The prototype database is powered by the standard containers of STL.  The cache database is powered by the original implementation of double-linked hash map with LRU deletion algorithm.  All databases have practical utility methods related to transaction and cursor.  Programs for command line interface are also included in the package.</p>

<p>Kyoto Cabinet runs very fast.  For example, elapsed time to store one million records is 0.9 seconds for the hash database, and 1.1 seconds for the B+ tree database.  Moreover, the size of database is very small.  For example, overhead for a record is 16 bytes for the hash database, and 4 bytes for the B+ tree database.  Furthermore, scalability of Kyoto Cabinet is great.  The database size can be up to 8EB (9.22e18 bytes).</p>

<p>Kyoto Cabinet is written in the C++ language, and provided as API of C++, C, Java, Python, Ruby, Perl, and Lua.  Kyoto Cabinet is available on platforms which have API conforming to C++03 with the TR1 library extensions.  Kyoto Cabinet is a free software licensed under the GNU General Public License.</p>

<hr />

<h2 id="features">Features</h2>

<p>This section describes the features of Kyoto Cabinet.</p>

<h3 id="features_genealogy">Genealogy</h3>

<p>The original DBM was developed by Kenneth Thompson as a part of the original AT&amp;T UNIX.  After that, a lot of followers developed such DBM-like products as NDBM, SDBM, GDBM, TDB, and BerkeleyDB.  In 2003, I developed QDBM to replace GDBM for performance reason.</p>

<p>In 2007, Tokyo Cabinet was developed as the successor to QDBM on the following purposes.  They were achieved and Tokyo Cabinet could replace conventional DBM products.</p>

<ul>
<li>improves <strong>space efficiency</strong> : smaller size of database file.</li>
<li>improves <strong>time efficiency</strong> : faster processing speed.</li>
<li>improves <strong>parallelism</strong> : higher performance in multi-thread environment.</li>
<li>improves <strong>usability</strong> : simplified API.</li>
<li>improves <strong>robustness</strong> : database file is not corrupted even under catastrophic situation.</li>
<li>supports <strong>64-bit architecture</strong> : enormous memory space and database file are available.</li>
</ul>

<p>In 2009, Kyoto Cabinet was developed as another successor to QDBM.  Compared with the sibling product (Tokyo Cabinet), the following advantages were pursued.  However, the performance of Tokyo Cabinet is higher than Kyoto Cabinet, at least in single thread operations.</p>

<ul>
<li>improves <strong>space efficiency</strong> : smaller size of database file.</li>
<li>improves <strong>parallelism</strong> : higher performance in multi-thread environment.</li>
<li>improves <strong>portability</strong> : abstraction of the lower layer to support non-POSIX systems.</li>
<li>improves <strong>usability</strong> : simplified API, object-oriented design.</li>
<li>improves <strong>robustness</strong> : database file is not corrupted even under catastrophic situation.</li>
</ul>

<p>I'll maintain the both of Tokyo Cabinet and Kyoto Cabinet because their values are different.</p>

<h3 id="features_hash">Effective Implementation of Hash Database</h3>

<p>Kyoto Cabinet uses hash algorithm to retrieve records.  If a bucket array has sufficient number of elements, the time complexity of retrieval is "O(1)".  That is, the time required for retrieving a record is constant, regardless of the scale of a database.  It is also the same about storing and deleting.  Collision of hash values is managed by separate chaining.  Data structure of the chains is binary search tree.  Even if a bucket array has unusually scarce elements, the time complexity of retrieval is "O(log n)".</p>

<p>Kyoto Cabinet attains performance improvement in retrieval by loading the whole of the bucket array onto the RAM.  If the bucket array is on RAM, it is possible to access a region of a target record by about one set of file operations such as `lseek', `read', and `write'.  The bucket array saved in a file is not read into RAM with the `read' call but directly mapped to RAM with the `mmap' call.  Therefore, preparation time on connecting to a database is very short, and two or more processes can share the same memory map.</p>

<p>The hash function used for hash table is MurMurHash 2.0.  If the number of elements of the bucket array is about a half of records stored within a database, although it depends on characteristic of the input, the probability of collision of hash values is about 55.3% (35.5% if the same, 20.4% if twice, 11.0% if four times, 5.7% if eight times).  In that case, it is possible to retrieve a record by two or less sets of file operations.  If it is made into a performance index, in order to handle a database containing one million of records, a bucket array with half a million of elements is required.  The size of each element is 6 bytes.  That is, if 3M bytes of RAM is available, a database containing one million records can be handled.</p>

<p>When overwriting a record with a value whose size is greater than the existing one, it is necessary to move the region to another position of the file.  Because the time complexity of the operation depends on the size of the region of a record, extending values successively is inefficient.  However, Kyoto Cabinet deals with this problem by alignment.  If the incremental data can be placed in the padding region trailing the records, it is not necessary to move the region of the record.</p>

<p>Generally speaking, while succession of updating, fragmentation of available regions occurs, and the size of a database grows rapidly.  Kyoto Cabinet deals with this problem by the free block pool and the auto defragmentation mechanism.  If a record is removed or shifted to another position, the region will be treated as a free block.  The free block pool manages free blocks and reuses the best fit region for a new record.  The auto defragmentation is to shift records and free blocks separately.  Successive free blocks coalesce into one.</p>

<h3 id="features_tree">Useful Implementation of B+ Tree Database</h3>

<p>Although the B+ tree database is slower than the hash database, it features ordering access to each record.  The order can be assigned by users.  Records in the B+ tree database are sorted and arranged in logical pages.  Sparse index organized in B tree that is multiway balanced tree are maintained for each page.  Thus, the time complexity of retrieval and so on is "O(log n)".  Cursor is provided to access each record in order.  The cursor can jump to a position specified by a key and can step forward or backward from the current position.  Because each page is arranged as double linked list, the time complexity of stepping cursor is "O(1)".</p>

<p>The B+ tree database is implemented based on the above the hash database.  Because each page of the B+ tree database is stored as each record in the hash database, the B+ tree database inherits efficiency of storage management of the hash database.  Because the header of each record is smaller and alignment of each page is adjusted according to the page size, in most cases, the size of database file is cut by half compared to one of the hash database.</p>

<p>Although operations of many pages are required to update the B+ tree database, Kyoto Cabinet expedites the process by the page cache and reducing file operations.  The page cache is implemented with double layered LRU list, which realizes that frequently accessed pages are cached in the "hot" list and recently accessed pages are cached in the "warm" LRU list.  If the page cache works efficiently and the whole of the sparse index is cached on memory, it is possible to retrieve a record by one or less set of file operations.</p>

<p>Each page of the B+ tree database can be stored with compressed.  The default compression method is "Deflate" by ZLIB.  Because records in a page has similar patterns, high efficiency of compression is expected due to the Lempel-Ziv algorithm.  In case of handling text data, the size of a database is reduced to about 50% or less.  If the scale of a database is large and disk I/O is the bottleneck, featuring compression makes the processing speed improved to a large extent.  Moreover, you can specify such external compression algorithms as LZO and LZMA.</p>

<h3 id="features_practical">Practical Functionality</h3>

<p>Kyoto Cabinet features transaction mechanisms.  It is possible to commit a series of operations between the beginning and the end of the transaction in a lump, or to abort the transaction and perform rollback to the state before the transaction.  Two isolation levels are supported: "serializable" and "read uncommitted".  Durability is secured by write ahead logging and shadow paging.</p>

<p>Auto transaction and auto recovery mechanisms are also supported.  If the auto transaction option is specified when opening the database, every updating operation is guarded by transaction which is committed implicitly.  Therefore, durability can be assured without explicit transaction operations.  The auto recovery mechanism works after the database is crashed outside transaction.  If inconsistency of the database is detected when opening the database, all regions are scanned as with "fsck" and the database is reconstructed with surviving records implicitly.</p>

<p>Kyoto Cabinet provides two modes to connect to a database: "reader" and "writer".  A reader can perform retrieving but neither storing nor deleting.  A writer can perform all access methods.  Exclusion control between processes is performed when connecting to a database by file locking.  While a writer is connected to a database, neither readers nor writers can be connected.  While a reader is connected to a database, other readers can be connect, but writers can not.  According to this mechanism, data consistency is guaranteed with simultaneous connections in multitasking environment.</p>

<p>Functions of API are reentrant and available in multi-thread environment.  Different database objects can be operated in parallel entirely.  For simultaneous operations against the same database object, rwlock (reader-writer lock) is used for exclusion control.  That is, while a writing thread is operating an object, other reading threads and writing threads are blocked.  However, while a reading thread is operating an object, reading threads are not blocked.  Locking granularity depends on data structures.  The hash database uses record locking.  The B+ tree database uses page locking.</p>

<p>In order to improve performance and concurrency, Kyoto Cabinet uses such atomic operations built in popular CPUs as atomic-increment and CAS (compare-and-swap).  Lock primitives provided by the native environment such as the POSIX thread package are alternated by own primitives using CAS.</p>

<h3 id="features_simple">Simple but Flexible Interfaces</h3>

<p>Kyoto Cabinet provides simple APIs based on object-oriented design.  Every operation for database is encapsulated and published as lucid methods as `open', `close', `set', `remove', `get', and so on.  The classes of the hash database and the B+ tree database are derived class of the common abstract class which defines the interface.  Porting an application from one database to another is easy.  Moreover, the polymorphic database API is provided to assign a database in run-time.</p>

<p>Kyoto Cabinet supports the "visitor" pattern.  You can define arbitrary database operations with call back functions.  The visitor class encapsulates that call back functions and their state data.  The database class has the "accept" method, which accepts an instance of the visitor class and calls its functions with a record data.  The return value of the call back function is reflected as the new state of the record.</p>

<p>While the core API is provided for C++, bindings for other languages such as C, Java, Python, Ruby, Perl, and Lua are also provided.  Command line interfaces are also provided corresponding to each API.  They are useful for prototyping, test, and debugging.</p>

<hr />

<h2 id="installation">Installation</h2>

<p>This section describes how to install Kyoto Cabinet with the source package.  As for a binary package, see its installation manual.</p>

<h3 id="installation_preparation">Preparation</h3>

<p>Kyoto Cabinet is available on UNIX-like systems.  At least, the following environments are supported.</p>

<ul>
<li>Linux 2.6 and later (i386/x86-64/PowerPC/Alpha/SPARC)</li>
<li>FreeBSD 7.1 and later (i386/x86-64)</li>
<li>Solaris 10 and later (i386/x86-64/SPARC)</li>
<li>Mac OS X 10.5 and later (x86-64)</li>
<li>Windows XP and later (i386/x86-64)</li>
</ul>

<p><code>gcc</code> (GNU Compiler Collection) 4.2 or later and <code>make</code> (GNU Make) are required to install Kyoto Cabinet with the source package.  They are installed by default on Linux, FreeBSD and so on.</p>

<p>As Kyoto Cabinet depends on the following libraries, install them beforehand.</p>

<ul>
<li><a href="http://www.zlib.net/">ZLIB</a> : for loss-less data compression.  1.2.3 or later is required.</li>
</ul>

<h3 id="installation_installation">Installation</h3>

<p>When an archive file of Kyoto Cabinet is extracted, change the current working directory to the generated directory and perform installation.</p>

<p>Run the configuration script.</p>

<pre>$ ./configure
</pre>

<p>Build programs.</p>

<pre>$ make
</pre>

<p>Perform self-diagnostic test.</p>

<pre>$ make check
</pre>

<p>Install programs.  This operation must be carried out by the <code>root</code> user.</p>

<pre># make install
</pre>

<h3 id="installation_result">Result</h3>

<p>When a series of work finishes, the following files will be installed.</p>

<pre>/usr/local/include/kccommon.h
/usr/local/include/kcutil.h
/usr/local/include/kcdb.h
/usr/local/include/kcthread.h
/usr/local/include/kcfile.h
/usr/local/include/kccompress.h
/usr/local/include/kccompare.h
/usr/local/include/kcmap.h
/usr/local/include/kcprotodb.h
/usr/local/include/kccachedb.h
/usr/local/include/kchashdb.h
/usr/local/include/kctreedb.h
/usr/local/include/kcpolydb.h
/usr/local/include/kclangc.h
/usr/local/lib/libkyotocabinet.a
/usr/local/lib/libkyotocabinet.so.x.y.z
/usr/local/lib/libkyotocabinet.so.x
/usr/local/lib/libkyotocabinet.so
/usr/local/lib/pkgconfig/kyotocabinet.pc
/usr/local/bin/kcutiltest
/usr/local/bin/kcutilcodec
/usr/local/bin/kcprototest
/usr/local/bin/kccachetest
/usr/local/bin/kchashtest
/usr/local/bin/kchashmgr
/usr/local/bin/kctreetest
/usr/local/bin/kctreemgr
/usr/local/bin/kcpolytest
/usr/local/bin/kcpolymgr
/usr/local/bin/kclanctest
/usr/local/share/kyotocabinet/...
/usr/local/man/man1/...
</pre>

<h3 id="installation_option">Options of Configure</h3>

<p>The following options can be specified with `<code>./configure</code>'.</p>

<ul class="options">
<li><code>--enable-debug</code> : build for debugging.  Enable debugging symbols, do not perform optimization, and perform static linking.</li>
<li><code>--enable-devel</code> : build for development.  Enable debugging symbols, perform optimization, and perform dynamic linking.</li>
<li><code>--enable-profile</code> : build for profiling.  Enable profiling symbols, perform optimization, and perform dynamic linking.</li>
<li><code>--enable-static</code> : build by static linking.</li>
<li><code>--disable-shared</code> :  avoid to build shared libraries.</li>
<li><code>--disable-zlib</code> : build without ZLIB compression.</li>
<li><code>--disable-atomic</code> : build without atomic operations.</li>
</ul>

<p>`<code>--prefix</code>' and other options are also available as with usual UNIX software packages.  If you want to install Kyoto Cabinet under `<code>/usr</code>' not `<code>/usr/local</code>', specify `<code>--prefix=/usr</code>'.  As well, the library search path does not include `<code>/usr/local/lib</code>', it is necessary to set the environment variable `<code>LD_LIBRARY_PATH</code>' to include `<code>/usr/local/lib</code>' before running applications of Kyoto Cabinet.</p>

<h3 id="installation_library">How to Use the Library</h3>

<p>Kyoto Cabinet provides API of the C++ language and it is available by programs conforming to the C++03 standard.  As the header files of Kyoto Cabinet are provided as `<code>kcutil.h</code>', `<code>kchashdb.h</code>', and so on, applications should include one or more of them accordingly to use the API.  As the library is provided as `<code>libkyotocabinet.a</code>' and `<code>libkyotocabinet.so</code>' and they depends `<code>libz.so</code>', `<code>libstdc++.so</code>', `<code>librt.so</code>', `<code>libpthread.so</code>', `<code>libm.so</code>', and `<code>libc.so</code>', linker options corresponding to them are required by the build command.  The typical build command is the following.</p>

<pre>$ g++ -I/usr/local/include example.cc -o example \
  -L/usr/local/lib -lkyotocabinet -lz -lstdc++ -lrt -lpthread -lm -lc
</pre>

<h3 id="installation_windows">For Windows</h3>

<p>Microsoft Visual Studio (Visual C++) is required to build Kyoto Cabinet on Windows.  The building configuration is described in the file `<code>VCmakefile</code>', which should be edited according to your environment.  Then, perform the following command in a command prompt window.</p>

<pre>&gt; nmake -f VCmakefile
</pre>

<p>If you want, perform self-diagnostic test.</p>

<pre>&gt; nmake -f VCmakefile check
</pre>

<p>If all building processes finish successfully, the static library `<code>kyotocabinet.lib</code>' and some executable files are generated.  As for now, neither DLL nor installation tool is provided.  Please, install the header files, the library file, and the executable files by yourself.</p>

<p>If the header files and the library file are in the current directory, you can build an application program by the following command.</p>

<pre>&gt; cl /I. example.cc kyotocabinet.lib
</pre>

<p>By default, the library is built with linking to `<code>LIBCMT.LIB</code>' by the `<code>/MT</code>' option.  If you want to use `<code>MSVCRT.LIB</code>', which is required by the MFC, rebuild the library with the `<code>/MD</code>' option and set the same option when building applications.  If your environment is 64-bit version, add the `<code>/D_SYS_WIN64_</code>' option to compiler options to improve performance.</p>

<hr />

<h2 id="tutorial">Tutorial</h2>

<p>This section describes how to use Kyoto Cabinet with the command line utilities and some sample application programs.</p>

<h3 id="tutorial_kchashmgr">Command Line Utility for the File Hash Database</h3>

<p>To begin with, let's build a file hash database with the command line utility `<code>kchashmgr</code>'.  The database stores a list of staffs of a company.  Each record is composed of the key and the value.  The key is the staff ID and the value is person's name.</p>

<p>The database must be created just one time before any database operation.  Let's create a database file "casket.kch" with the default configuration.</p>

<pre>$ kchashmgr create staffs.kch
</pre>

<p>Register some staffs into the database.</p>

<pre>$ kchashmgr set staffs.kch 1001 "George Washington"
$ kchashmgr set staffs.kch 1002 "John Adams"
$ kchashmgr set staffs.kch 1003 "Thomas Jefferson"
$ kchashmgr set staffs.kch 1004 "James Madison"
</pre>

<p>Check the current contents.</p>

<pre>$ kchashmgr list -pv staffs.kch
1001    George Washington
1002    John Adams
1003    Thomas Jefferson
1004    James Madison
</pre>

<p>To retrieve the value of a record, search the database with the key.</p>

<pre>$ kchashmgr get staffs.kch 1003
Thomas Jefferson
</pre>

<p>Of course, you can remove a record with the key.</p>

<pre>$ kchashmgr remove staffs.kch 1003
</pre>

<p>That's all for the fundamental operations.  The DBM family have been improving performance thanks to discarding the functionality.</p>

<h3 id="tutorial_kchashex">Sample Application of the File Hash Database</h3>

<p>Next, let's write a sample application program handling a file hash database.  See the following source code.</p>

<pre>#include &lt;kchashdb.h&gt;

using namespace std;
using namespace kyotocabinet;

// main routine
int main(int argc, char** argv) {

  // create the database object
  HashDB db;

  // open the database
  if (!db.open("casket.kch", HashDB::OWRITER | HashDB::OCREATE)) {
    cerr &lt;&lt; "open error: " &lt;&lt; db.error().name() &lt;&lt; endl;
  }

  // store records
  if (!db.set("foo", "hop") ||
      !db.set("bar", "step") ||
      !db.set("baz", "jump")) {
    cerr &lt;&lt; "set error: " &lt;&lt; db.error().name() &lt;&lt; endl;
  }

  // retrieve a record
  string* value = db.get("foo");
  if (value) {
    cout &lt;&lt; *value &lt;&lt; endl;
    delete value;
  } else {
    cerr &lt;&lt; "get error: " &lt;&lt; db.error().name() &lt;&lt; endl;
  }

  // traverse records
  DB::Cursor* cur = db.cursor();
  cur-&gt;jump();
  pair&lt;string, string&gt;* rec;
  while ((rec = cur-&gt;get_pair(true)) != NULL) {
    cout &lt;&lt; rec-&gt;first &lt;&lt; ":" &lt;&lt; rec-&gt;second &lt;&lt; endl;
    delete rec;
  }
  delete cur;

  // close the database
  if (!db.close()) {
    cerr &lt;&lt; "close error: " &lt;&lt; db.error().name() &lt;&lt; endl;
  }

  return 0;
}
</pre>

<p>Save the above code as a file "example.cc".  Then, perform the following command line.  The command `<code>kcutilcodec conf</code>' prints the building configuration.</p>

<pre>$ g++ `kcutilcodec conf -i` -o example example.cc `kcutilcodec conf -l`
</pre>

<p>Execute the application program built by the above.</p>

<pre>$ ./example
hop
foo:hop
bar:step
baz:jump
</pre>

<p>The API of the file hash database is defined in the header `<code>kchash.h</code>'.  So, include the header near the front of a source file.  All symbols of Kyoto Cabinet are packaged in the name space `<code>kyotocabinet</code>'.  You can use them without any prefix by importing the name space.</p>

<pre>#include &lt;kchashdb.h&gt;
using namespace kyotocabinet;
</pre>

<p>The class `<code>HashDB</code>' contains all functionality of the file hash database and each instance expresses a file hash database file.</p>

<pre>HashDB db;
</pre>

<p>Each database file must be opened by the `<code>open</code>' method before any database operation.  The flag `<code>HashDB::OWRITER</code>' means the process will update the database.  The flag `<code>HashDB::OCREATE</code>' means a database file will be created if it does not exist yet.</p>

<pre>db.open("casket.kch", HashDB::OWRITER | HashDB::OCREATE);
</pre>

<p>Every opened database must be closed by the `<code>close</code>' method when it is no longer in use.  Closing the database is very important to avoid data corruption and memory leak.</p>

<pre>db.close();
</pre>

<p>To store a record, use the `<code>set</code>' method with the key and the value.</p>

<pre>db.put("foo", "hop");
</pre>

<p>To retrieve the value of a record, use the `<code>get</code>' method with the key.  The return value is NULL if no record corresponds to the key.  On success, the return value is the pointer to a dynamic object and it should be deleted explicitly after the use.</p>

<pre>string* value = db.get("foo", "hop");
if (value) {
  cout &lt;&lt; *value &lt;&lt; endl;
  delete value;
}
</pre>

<p>Except for `<code>set</code>' and `<code>get</code>', there are other methods; `<code>add</code>', `<code>append</code>', `<code>remove</code>', `<code>increment</code>', and `<code>cas</code>'.  Each method has two versions; for `<code>std::string</code>' parameters and for `<code>char*</code>' and `<code>size_t</code>' parameters.</p>

<p>Traversing records is a bit complicated task.  It needs a cursor object, which expresses the current position in the sequence of all records in the database.  Each cursor is created by the `<code>cursor</code>' method of the database object.  Each cursor should be initialized by `<code>jump</code>' method before actual record operations.</p>

<pre>DB::Cursor* cur = db.cursor();
cur-&gt;jump();
</pre>

<p>The cursor class has such methods against the record at the current position as `<code>set_value</code>', `<code>remove</code>', `<code>get_key</code>', `<code>get_value</code>', and `<code>get_pair</code>'.  Most methods have an optional stepping parameter to shift the current position to the next record atomically.  Therefore, iterating such methods with the stepping parameter results in that all records are visited.</p>

<pre>pair&lt;string, string&gt;* rec;
while ((rec = cur.get_pair(true)) != NULL) {
  cout &lt;&lt; rec-&gt;first &lt;&lt; ":" &lt;&lt; rec-&gt;second &lt;&lt; endl;
  delete rec;
}
</pre>

<h3 id="tutorial_kcvisex">More Complex Example Using the Visitor Pattern</h3>

<p>Every operation against a record can be abstracted by the "visitor" pattern.  A visitor object specifies call back methods which receives the state of a record and returns the new state.  Let's see the next sample using the visitor pattern.</p>

<pre>#include &lt;kchashdb.h&gt;

using namespace std;
using namespace kyotocabinet;

// main routine
int main(int argc, char** argv) {

  // create the database object
  HashDB db;

  // open the database
  if (!db.open("casket.kch", HashDB::OREADER)) {
    cerr &lt;&lt; "open error: " &lt;&lt; db.error().name() &lt;&lt; endl;
  }

  // define the visitor
  class VisitorImpl : public DB::Visitor {
    // call back function for an existing record
    const char* visit_full(const char* kbuf, size_t ksiz,
                           const char* vbuf, size_t vsiz, size_t *sp) {
      cout &lt;&lt; string(kbuf, ksiz) &lt;&lt; ":" &lt;&lt; string(vbuf, vsiz) &lt;&lt; endl;
      return NOP;
    }
    // call back function for an empty record space
    const char* visit_empty(const char* kbuf, size_t ksiz, size_t *sp) {
      cerr &lt;&lt; string(kbuf, ksiz) &lt;&lt; " is missing" &lt;&lt; endl;
      return NOP;
    }
  } visitor;

  // retrieve a record with visitor
  if (!db.accept("foo", 3, &amp;visitor, false) ||
      !db.accept("dummy", 5, &amp;visitor, false)) {
    cerr &lt;&lt; "accept error: " &lt;&lt; db.error().name() &lt;&lt; endl;
  }

  // traverse records with visitor
  if (!db.iterate(&amp;visitor, false)) {
    cerr &lt;&lt; "iterate error: " &lt;&lt; db.error().name() &lt;&lt; endl;
  }

  // close the database
  if (!db.close()) {
    cerr &lt;&lt; "close error: " &lt;&lt; db.error().name() &lt;&lt; endl;
  }

  return 0;
}
</pre>

<p>The methods `<code>accept</code>' and `<code>iterate</code>' receive visitor objects.  Each visitor object must be implement the interface `<code>DB::Visitor</code>'.  The method `<code>visit_full</code>' is called for an existing record.  The parameters specify the pointer to key buffer, the length of the key buffer, the pointer to the value buffer, the length of the value buffer, and the pointer to the variable to notice the length of the return value.  The return value is `<code>NOP</code>' for no update, `<code>REMOVE</code>' to remove the record, or otherwise the pointer to the buffer contains arbitrary byte pattern to update the value.  The method `<code>visit_empty</code>' is called for an empty record space.  The specification is the same to `<code>visit_full</code>' except that it does not receive the record value.</p>

<p>As it is, almost all built-in operations like `<code>set</code>', `<code>remove</code>', and `<code>get</code>' are implemented with the `<code>accept</code>' method.  The following code is to store a record.</p>

<pre>class Setter : public DB::Visitor {
public:
  Setter(const char* vbuf, size_t vsiz) : vbuf_(vbuf), vsiz_(vsiz) {}
private:
  const char* visit_full(const char* kbuf, size_t ksiz,
                         const char* vbuf, size_t vsiz, size_t* sp) {
    *sp = vsiz_;
    return vbuf_;
  }
  const char* visit_empty(const char* kbuf, size_t ksiz, size_t* sp) {
    *sp = vsiz_;
    return vbuf_;
  }
  const char* vbuf_;
  size_t vsiz_;
};
Setter setter("foo", 3);
accept(kbuf, ksiz, &amp;setter, true);
</pre>

<h3 id="tutorial_dbchart">Features of Various Database Classes</h3>

<p>As Kyoto Cabinet provides various database classes, they have the common base class, which defines the common interface of all database classes.  That is, you can use the following classes in the same way.</p>

<table summary="database types">
<tr>
<th abbr="class">class</th>
<th abbr="file">file</th>
<th abbr="description">description</th>
</tr>
<tr>
<td><code>ProtoHashDB</code></td>
<td>kcprotodb.h</td>
<td>
<div>prototype hash database.</div>
<div>on-memory database implemented with std::unorderd_map of STL.</div>
</td>
</tr>
<tr>
<td><code>ProtoTreeDB</code></td>
<td>kcprotodb.h</td>
<td>
<div>prototype tree database.</div>
<div>on-memory database implemented with std::map of STL.</div>
</td>
</tr>
<tr>
<td><code>CacheDB</code></td>
<td>kccachedb.h</td>
<td>
<div>cache database.</div>
<div>on-memory database featuring LRU deletion.</div>
</td>
</tr>
<tr>
<td><code>HashDB</code></td>
<td>kchashdb.h</td>
<td>
<div>file hash database.</div>
<div>file database of hash table: typical DBM.</div>
</td>
</tr>
<tr>
<td><code>TreeDB</code></td>
<td>kctreedb.h</td>
<td>
<div>file tree database.</div>
<div>file database of B+ tree: DBM with order.</div>
</td>
</tr>
<tr>
<td><code>PolyDB</code></td>
<td>kcpolydb.h</td>
<td>
<div>polymorphic database.</div>
<div>dynamic binding of the above databases.</div>
</td>
</tr>
</table>

<p>Each database has different features in persistence, algorithm, time complexity, record sequence, and lock model for concurrency.</p>

<table summary="database features">
<tr>
<th abbr="class"></th>
<td><code>ProtoHashDB</code></td>
<td><code>ProtoTreeDB</code></td>
<td><code>CacheDB</code></td>
<td><code>HashDB</code></td>
<td><code>TreeDB</code></td>
</tr>
<tr>
<th abbr="persistence">persistence</th>
<td>volatile</td>
<td>volatile</td>
<td>volatile</td>
<td>persistent</td>
<td>persistent</td>
</tr>
<tr>
<th abbr="algorithm">algorithm</th>
<td>hash table</td>
<td>red black tree</td>
<td>hash table</td>
<td>hash table</td>
<td>B+ tree</td>
</tr>
<tr>
<th abbr="complexity">complexity</th>
<td>O(1)</td>
<td>O(log N)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(log N)</td>
</tr>
<tr>
<th abbr="sequence">sequence</th>
<td>undefined</td>
<td>lexical order</td>
<td>undefined</td>
<td>undefined</td>
<td>custom order</td>
</tr>
<tr>
<th abbr="lock">lock unit</th>
<td>whole (rwlock)</td>
<td>whole (rwlock)</td>
<td>record (mutex)</td>
<td>record (rwlock)</td>
<td>page (rwlock)</td>
</tr>
</table>

<p>The C language binding is also provided as a wrapper of the polymorphic database API.  Include the header file `<code>kclangc.h</code>' and use the pointer to `<code>KCDB</code>' as a database object.</p>

<p>Please see the <a href="api/">the API documents</a> for detail.  Writing your own sample application is the best way to learn this library.</p>

<hr />

<h2 id="command">Command Line Utilities</h2>

<p>This section describes how to use command line utilities.  They are useful to manage database contents and to test the library and its applications.</p>

<h3 id="kcutiltest">kcutiltest</h3>

<p>The command `<code>kcutiltest</code>' is a utility for facility test and performance test of the utility functions.  This command is used in the following format.  `<var>rnum</var>' specifies the number of iterations.  `<var>path</var>' specifies the path of a file.</p>

<dl class="api">
<dt><code>kcutiltest mutex [-th <var>num</var>] [-iv <var>num</var>] <var>rnum</var></code></dt>
<dd>Performs test of lock primitives.</dd>
<dt><code>kcutiltest file [-th <var>num</var>] [-rnd] [-msiz <var>num</var>] <var>path</var> <var>rnum</var></code></dt>
<dd>Performs test of the filesystem abstraction.</dd>
<dt><code>kcutiltest map [-rnd] [-bnum <var>num</var>] <var>rnum</var></code></dt>
<dd>Performs test of data mapping structures.</dd>
<dt><code>kcutiltest misc <var>rnum</var></code></dt>
<dd>Performs test of miscellaneous mechanisms.</dd>
</dl>

<p>Options feature the following.</p>

<ul class="options">
<li><code>-th <var>num</var></code> : specifies the number of worker threads.</li>
<li><code>-iv <var>num</var></code> : specifies the interval between iterations.</li>
<li><code>-rnd</code> : performs random test.</li>
<li><code>-msiz <var>num</var></code> : specifies the size of the memory-mapped region.</li>
<li><code>-bnum <var>num</var></code> : specifies the number of buckets of the hash table.</li>
</ul>

<p>This command returns 0 on success, another on failure.</p>

<h3 id="kcutilcodec">kcutilcodec</h3>

<p>The command `<code>kcutilcodec</code>' is a tool to use encoding and decoding features, or to show the configuration.  This command is used in the following format.</p>

<dl class="api">
<dt><code>kcutilcodec conf [-v|-i|-l|-p]</code></dt>
<dd>Shows the configuration of Kyoto Cabinet.</dd>
</dl>

<p>Options feature the following.</p>

<ul class="options">
<li><code>-v</code> : show the version number of Kyoto Cabinet.</li>
<li><code>-i</code> : show options to include the headers of Tokyo Cabinet.</li>
<li><code>-l</code> : show options to link the library of Tokyo Cabinet.</li>
<li><code>-p</code> : show the directory path of the commands.</li>
</ul>

<p>This command returns 0 on success, another on failure.</p>

<h3 id="kcprototest">kcprototest</h3>

<p>The command `<code>kcprototest</code>' is a utility for facility test and performance test of the prototype database.  This command is used in the following format.  `<var>rnum</var>' specifies the number of iterations.</p>

<dl class="api">
<dt><code>kcprototest order [-tree] [-th <var>num</var>] [-rnd] [-etc] [-tran] <var>rnum</var></code></dt>
<dd>Performs in-order tests.</dd>
<dt><code>kcprototest queue [-tree] [-th <var>num</var>] [-it <var>num</var>] [-rnd] <var>rnum</var></code></dt>
<dd>Performs queuing operations.</dd>
<dt><code>kcprototest wicked [-tree] [-th <var>num</var>] [-it <var>num</var>] <var>rnum</var></code></dt>
<dd>Performs mixed operations selected at random.</dd>
<dt><code>kcprototest tran [-tree] [-th <var>num</var>] [-it <var>num</var>] <var>rnum</var></code></dt>
<dd>Performs test of transaction.</dd>
</dl>

<p>Options feature the following.</p>

<ul class="options">
<li><code>-tree</code> : test the prototype tree database instead of the prototype hash database.</li>
<li><code>-th <var>num</var></code> : specifies the number of worker threads.</li>
<li><code>-rnd</code> : performs random test.</li>
<li><code>-etc</code> : performs miscellaneous operations.</li>
<li><code>-tran</code> : performs transaction.</li>
<li><code>-it <var>num</var></code> : specifies the number of repetition.</li>
</ul>

<p>This command returns 0 on success, another on failure.</p>

<h3 id="kccachetest">kccachetest</h3>

<p>The command `<code>kccachetest</code>' is a utility for facility test and performance test of the cache database.  This command is used in the following format.  `<var>rnum</var>' specifies the number of iterations.</p>

<dl class="api">
<dt><code>kccachetest order [-th <var>num</var>] [-rnd] [-etc] [-tran] [-bnum <var>num</var>] [-capcnt <var>num</var>] [-capsiz <var>num</var>] <var>rnum</var></code></dt>
<dd>Performs in-order tests.</dd>
<dt><code>kccachetest queue [-th <var>num</var>] [-it <var>num</var>] [-rnd] [-bnum <var>num</var>] [-capcnt <var>num</var>] [-capsiz <var>num</var>] <var>rnum</var></code></dt>
<dd>Performs queuing operations.</dd>
<dt><code>kccachetest wicked [-th <var>num</var>] [-it <var>num</var>] [-bnum <var>num</var>] [-capcnt <var>num</var>] [-capsiz <var>num</var>] <var>rnum</var></code></dt>
<dd>Performs mixed operations selected at random.</dd>
<dt><code>kccachetest tran [-th <var>num</var>] [-it <var>num</var>] [-bnum <var>num</var>] [-capcnt <var>num</var>] [-capsiz <var>num</var>] <var>rnum</var></code></dt>
<dd>Performs test of transaction.</dd>
</dl>

<p>Options feature the following.</p>

<ul class="options">
<li><code>-th <var>num</var></code> : specifies the number of worker threads.</li>
<li><code>-rnd</code> : performs random test.</li>
<li><code>-etc</code> : performs miscellaneous operations.</li>
<li><code>-tran</code> : performs transaction.</li>
<li><code>-bnum <var>num</var></code> : specifies the number of buckets of the hash table.</li>
<li><code>-capcnt <var>num</var></code> : specifies the maximum number of records.</li>
<li><code>-capsiz <var>num</var></code> : specifies the maximum size of memory usage.</li>
<li><code>-it <var>num</var></code> : specifies the number of repetition.</li>
</ul>

<p>This command returns 0 on success, another on failure.</p>

<h3 id="kchashtest">kchashtest</h3>

<p>The command `<code>kchashtest</code>' is a utility for facility test and performance test of the file hash database.  This command is used in the following format.  `<var>path</var>' specifies the path of a database file.  `<var>rnum</var>' specifies the number of iterations.</p>

<dl class="api">
<dt><code>kchashtest order [-th <var>num</var>] [-rnd] [-set|-get|-getw|-rem|-etc] [-tran] [-oat|-onl|-onl|-otl|-onr] [-apow <var>num</var>] [-fpow <var>num</var>] [-ts] [-tl] [-tc] [-bnum <var>num</var>] [-msiz <var>num</var>] [-dfunit <var>num</var>] [-erv] <var>path</var> <var>rnum</var></code></dt>
<dd>Performs in-order tests.</dd>
<dt><code>kchashtest queue [-th <var>num</var>] [-it <var>num</var>] [-rnd] [-oat|-onl|-onl|-otl|-onr] [-apow <var>num</var>] [-fpow <var>num</var>] [-ts] [-tl] [-tc] [-bnum <var>num</var>] [-msiz <var>num</var>] [-dfunit <var>num</var>] [-erv] <var>path</var> <var>rnum</var></code></dt>
<dd>Performs queuing operations.</dd>
<dt><code>kchashtest wicked [-th <var>num</var>] [-it <var>num</var>] [-oat|-onl|-onl|-otl|-onr] [-apow <var>num</var>] [-fpow <var>num</var>] [-ts] [-tl] [-tc] [-bnum <var>num</var>] [-msiz <var>num</var>] [-dfunit <var>num</var>] [-erv] <var>path</var> <var>rnum</var></code></dt>
<dd>Performs mixed operations selected at random.</dd>
<dt><code>kchashtest tran [-th <var>num</var>] [-it <var>num</var>] [-hard] [-oat|-onl|-onl|-otl|-onr] [-apow <var>num</var>] [-fpow <var>num</var>] [-ts] [-tl] [-tc] [-bnum <var>num</var>] [-msiz <var>num</var>] [-dfunit <var>num</var>] [-erv] <var>path</var> <var>rnum</var></code></dt>
<dd>Performs test of transaction.</dd>
</dl>

<p>Options feature the following.</p>

<ul class="options">
<li><code>-th <var>num</var></code> : specifies the number of worker threads.</li>
<li><code>-rnd</code> : performs random test.</li>
<li><code>-set</code> : performs setting operation only.</li>
<li><code>-get</code> : performs getting operation only.</li>
<li><code>-getw</code> : performs getting with a buffer operation only.</li>
<li><code>-rem</code> : performs removing operation only.</li>
<li><code>-etc</code> : performs miscellaneous operations.</li>
<li><code>-tran</code> : performs transaction.</li>
<li><code>-oat</code> : opens the database with the auto transaction option.</li>
<li><code>-oas</code> : opens the database with the auto synchronization option.</li>
<li><code>-onl</code> : opens the database with the no locking option.</li>
<li><code>-otl</code> : opens the database with the try locking option.</li>
<li><code>-onr</code> : opens the database with the no auto repair option.</li>
<li><code>-apow <var>num</var></code> : specifies the power of the alignment of record size.</li>
<li><code>-fpow <var>num</var></code> : specifies the power of the capacity of the free block pool.</li>
<li><code>-ts</code> : tunes the database with the small option.</li>
<li><code>-tl</code> : tunes the database with the linear option.</li>
<li><code>-tc</code> : tunes the database with the compression option.</li>
<li><code>-bnum <var>num</var></code> : specifies the number of buckets of the hash table.</li>
<li><code>-msiz <var>num</var></code> : specifies the size of the memory-mapped region.</li>
<li><code>-dfunit <var>num</var></code> : specifies the unit step number of auto defragmentation.</li>
<li><code>-erv</code> : reports all errors.</li>
<li><code>-it <var>num</var></code> : specifies the number of repetition.</li>
<li><code>-hard</code> : performs physical synchronization.</li>
</ul>

<p>This command returns 0 on success, another on failure.</p>

<h3 id="kchashmgr">kchashmgr</h3>

<p>The command `<code>kchashmgr</code>' is a utility for test and debugging of the file hash database and its applications.  `<var>path</var>' specifies the path of a database file.  `<var>key</var>' specifies the key of a record.  `<var>value</var>' specifies the value of a record.  `<var>file</var>' specifies the input file.</p>

<dl class="api">
<dt><code>kchashmgr create [-otr] [-onl|-otl|-onr] [-apow <var>num</var>] [-fpow <var>num</var>] [-ts] [-tl] [-tc] [-bnum <var>num</var>] <var>path</var></code></dt>
<dd>Creates a database file.</dd>
<dt><code>kchashmgr inform [-onl|-otl|-onr] [-st] <var>path</var></code></dt>
<dd>Prints status information.</dd>
<dt><code>kchashmgr set [-onl|-otl|-onr] [-add|-app|-inci|-incd] [-sx] <var>path</var> <var>key</var> <var>value</var></code></dt>
<dd>Stores a record.</dd>
<dt><code>kchashmgr remove [-onl|-otl|-onr] [-sx] <var>path</var> <var>key</var></code></dt>
<dd>Removes a record.</dd>
<dt><code>kchashmgr get [-onl|-otl|-onr] [-sx] [-px] [-pz] <var>path</var> <var>key</var></code></dt>
<dd>Prints the value of a record.</dd>
<dt><code>kchashmgr list [-onl|-otl|-onr] [-max <var>num</var>] [-sx] [-pv] [-px] <var>path</var> [<var>key</var>]</code></dt>
<dd>Prints keys of all records, separated by line feeds.</dd>
<dt><code>kchashmgr import [-onl|-otl|-onr] [-sx] <var>path</var> [<var>file</var>]</code></dt>
<dd>Imports records from a TSV file.</dd>
<dt><code>kchashmgr dump [-onl|-otl|-onr] <var>path</var> [<var>file</var>]</code></dt>
<dd>Dump records into a snapshot file.</dd>
<dt><code>kchashmgr load [-otr] [-onl|-otl|-onr] <var>path</var> [<var>file</var>]</code></dt>
<dd>Load records from a snapshot file.</dd>
<dt><code>kchashmgr defrag [-onl|-otl|-onr] <var>path</var></code></dt>
<dd>Performs defragmentation.</dd>
<dt><code>kchashmgr check [-onl|-otl|-onr] <var>path</var></code></dt>
<dd>Checks consistency.</dd>
</dl>

<p>Options feature the following.</p>

<ul class="options">
<li><code>-otr</code> : opens the database with the truncation option.</li>
<li><code>-onl</code> : opens the database with the no locking option.</li>
<li><code>-otl</code> : opens the database with the try locking option.</li>
<li><code>-onr</code> : opens the database with the no auto repair option.</li>
<li><code>-apow <var>num</var></code> : specifies the power of the alignment of record size.</li>
<li><code>-fpow <var>num</var></code> : specifies the power of the capacity of the free block pool.</li>
<li><code>-ts</code> : tunes the database with the small option.</li>
<li><code>-tl</code> : tunes the database with the linear option.</li>
<li><code>-tc</code> : tunes the database with the compression option.</li>
<li><code>-bnum <var>num</var></code> : specifies the number of buckets of the hash table.</li>
<li><code>-st</code> : prints miscellaneous information.</li>
<li><code>-add</code> : performs adding operation.</li>
<li><code>-app</code> : performs appending operation.</li>
<li><code>-inci</code> : performs integer increment operation.</li>
<li><code>-incd</code> : performs real number increment operation.</li>
<li><code>-sx</code> : the input data is evaluated as a hexadecimal data string.</li>
<li><code>-px</code> : the output data is converted into a hexadecimal data string.</li>
<li><code>-pz</code> : does not append line feed at the end of the output.</li>
<li><code>-max</code> : specifies the maximum number of shown records.</li>
<li><code>-pv</code> : prints values of records also.</li>
</ul>

<p>This command returns 0 on success, another on failure.</p>

<h3 id="kctreetest">kctreetest</h3>

<p>The command `<code>kctreetest</code>' is a utility for facility test and performance test of the file tree database.  This command is used in the following format.  `<var>path</var>' specifies the path of a database file.  `<var>rnum</var>' specifies the number of iterations.</p>

<dl class="api">
<dt><code>kctreetest order [-th <var>num</var>] [-rnd] [-set|-get|-getw|-rem|-etc] [-tran] [-oat|-onl|-onl|-otl|-onr] [-apow <var>num</var>] [-fpow <var>num</var>] [-ts] [-tl] [-tc] [-bnum <var>num</var>] [-psiz <var>num</var>] [-msiz <var>num</var>] [-dfunit <var>num</var>] [-pccap <var>num</var>] [-rcd] [-erv] <var>path</var> <var>rnum</var></code></dt>
<dd>Performs in-order tests.</dd>
<dt><code>kctreetest queue [-th <var>num</var>] [-it <var>num</var>] [-rnd] [-oat|-onl|-onl|-otl|-onr] [-apow <var>num</var>] [-fpow <var>num</var>] [-ts] [-tl] [-tc] [-bnum <var>num</var>] [-psiz <var>num</var>] [-msiz <var>num</var>] [-dfunit <var>num</var>] [-pccap <var>num</var>] [-rcd] [-erv] <var>path</var> <var>rnum</var></code></dt>
<dd>Performs queuing operations.</dd>
<dt><code>kctreetest wicked [-th <var>num</var>] [-it <var>num</var>] [-oat|-onl|-onl|-otl|-onr] [-apow <var>num</var>] [-fpow <var>num</var>] [-ts] [-tl] [-tc] [-bnum <var>num</var>] [-psiz <var>num</var>] [-msiz <var>num</var>] [-dfunit <var>num</var>] [-pccap <var>num</var>] [-rcd] [-erv] <var>path</var> <var>rnum</var></code></dt>
<dd>Performs mixed operations selected at random.</dd>
<dt><code>kctreetest tran [-th <var>num</var>] [-it <var>num</var>] [-hard] [-oat|-onl|-onl|-otl|-onr] [-apow <var>num</var>] [-fpow <var>num</var>] [-ts] [-tl] [-tc] [-bnum <var>num</var>] [-psiz <var>num</var>] [-msiz <var>num</var>] [-dfunit <var>num</var>] [-pccap <var>num</var>] [-rcd] [-erv] <var>path</var> <var>rnum</var></code></dt>
<dd>Performs test of transaction.</dd>
</dl>

<p>Options feature the following.</p>

<ul class="options">
<li><code>-th <var>num</var></code> : specifies the number of worker threads.</li>
<li><code>-rnd</code> : performs random test.</li>
<li><code>-set</code> : performs setting operation only.</li>
<li><code>-get</code> : performs getting operation only.</li>
<li><code>-getw</code> : performs getting with a buffer operation only.</li>
<li><code>-rem</code> : performs removing operation only.</li>
<li><code>-etc</code> : performs miscellaneous operations.</li>
<li><code>-tran</code> : performs transaction.</li>
<li><code>-oat</code> : opens the database with the auto transaction option.</li>
<li><code>-oas</code> : opens the database with the auto synchronization option.</li>
<li><code>-onl</code> : opens the database with the no locking option.</li>
<li><code>-otl</code> : opens the database with the try locking option.</li>
<li><code>-onr</code> : opens the database with the no auto repair option.</li>
<li><code>-apow <var>num</var></code> : specifies the power of the alignment of record size.</li>
<li><code>-fpow <var>num</var></code> : specifies the power of the capacity of the free block pool.</li>
<li><code>-ts</code> : tunes the database with the small option.</li>
<li><code>-tl</code> : tunes the database with the linear option.</li>
<li><code>-tc</code> : tunes the database with the compression option.</li>
<li><code>-bnum <var>num</var></code> : specifies the number of buckets of the hash table.</li>
<li><code>-psiz <var>num</var></code> : specifies the size of each page.</li>
<li><code>-msiz <var>num</var></code> : specifies the size of the memory-mapped region.</li>
<li><code>-dfunit <var>num</var></code> : specifies the unit step number of auto defragmentation.</li>
<li><code>-pccap <var>num</var></code> : specifies the capacity size of the page cache.</li>
<li><code>-rcd</code> : use the decimal comparator instead of the lexical one.</li>
<li><code>-erv</code> : reports all errors.</li>
<li><code>-it <var>num</var></code> : specifies the number of repetition.</li>
<li><code>-hard</code> : performs physical synchronization.</li>
</ul>

<p>This command returns 0 on success, another on failure.</p>

<h3 id="kctreemgr">kctreemgr</h3>

<p>The command `<code>kctreemgr</code>' is a utility for test and debugging of the file tree database and its applications.  `<var>path</var>' specifies the path of a database file.  `<var>key</var>' specifies the key of a record.  `<var>value</var>' specifies the value of a record.  `<var>file</var>' specifies the input file.</p>

<dl class="api">
<dt><code>kctreemgr create [-otr] [-onl|-otl|-onr] [-apow <var>num</var>] [-fpow <var>num</var>] [-ts] [-tl] [-tc] [-bnum <var>num</var>] [-psiz <var>num</var>] [-rcd] <var>path</var></code></dt>
<dd>Creates a database file.</dd>
<dt><code>kctreemgr inform [-onl|-otl|-onr] [-st] <var>path</var></code></dt>
<dd>Prints status information.</dd>
<dt><code>kctreemgr set [-onl|-otl|-onr] [-add|-app|-inci|-incd] [-sx] <var>path</var> <var>key</var> <var>value</var></code></dt>
<dd>Stores a record.</dd>
<dt><code>kctreemgr remove [-onl|-otl|-onr] [-sx] <var>path</var> <var>key</var></code></dt>
<dd>Removes a record.</dd>
<dt><code>kctreemgr get [-onl|-otl|-onr] [-sx] [-px] [-pz] <var>path</var> <var>key</var></code></dt>
<dd>Prints the value of a record.</dd>
<dt><code>kctreemgr list [-onl|-otl|-onr] [-max <var>num</var>] [-sx] [-pv] [-px] <var>path</var> [<var>key</var>]</code></dt>
<dd>Prints keys of all records, separated by line feeds.</dd>
<dt><code>kctreemgr import [-onl|-otl|-onr] [-sx] <var>path</var> [<var>file</var>]</code></dt>
<dd>Imports records from a TSV file.</dd>
<dt><code>kctreemgr dump [-onl|-otl|-onr] <var>path</var> [<var>file</var>]</code></dt>
<dd>Dump records into a snapshot file.</dd>
<dt><code>kctreemgr load [-otr] [-onl|-otl|-onr] <var>path</var> [<var>file</var>]</code></dt>
<dd>Load records from a snapshot file.</dd>
<dt><code>kctreemgr defrag [-onl|-otl|-onr] <var>path</var></code></dt>
<dd>Performs defragmentation.</dd>
<dt><code>kctreemgr check [-onl|-otl|-onr] <var>path</var></code></dt>
<dd>Checks consistency.</dd>
</dl>

<p>Options feature the following.</p>

<ul class="options">
<li><code>-otr</code> : opens the database with the truncation option.</li>
<li><code>-onl</code> : opens the database with the no locking option.</li>
<li><code>-otl</code> : opens the database with the try locking option.</li>
<li><code>-onr</code> : opens the database with the no auto repair option.</li>
<li><code>-apow <var>num</var></code> : specifies the power of the alignment of record size.</li>
<li><code>-fpow <var>num</var></code> : specifies the power of the capacity of the free block pool.</li>
<li><code>-ts</code> : tunes the database with the small option.</li>
<li><code>-tl</code> : tunes the database with the linear option.</li>
<li><code>-tc</code> : tunes the database with the compression option.</li>
<li><code>-bnum <var>num</var></code> : specifies the number of buckets of the hash table.</li>
<li><code>-psiz <var>num</var></code> : specifies the size of each page.</li>
<li><code>-rcd</code> : use the decimal comparator instead of the lexical one.</li>
<li><code>-st</code> : prints miscellaneous information.</li>
<li><code>-add</code> : performs adding operation.</li>
<li><code>-app</code> : performs appending operation.</li>
<li><code>-inci</code> : performs integer increment operation.</li>
<li><code>-incd</code> : performs real number increment operation.</li>
<li><code>-sx</code> : the input data is evaluated as a hexadecimal data string.</li>
<li><code>-px</code> : the output data is converted into a hexadecimal data string.</li>
<li><code>-pz</code> : does not append line feed at the end of the output.</li>
<li><code>-max</code> : specifies the maximum number of shown records.</li>
<li><code>-pv</code> : prints values of records also.</li>
</ul>

<p>This command returns 0 on success, another on failure.</p>

<h3 id="kcpolytest">kcpolytest</h3>

<p>The command `<code>kcpolytest</code>' is a utility for facility test and performance test of the polymorphic database.  This command is used in the following format.  `<var>path</var>' specifies the path of a database file.  `<var>rnum</var>' specifies the number of iterations.</p>

<dl class="api">
<dt><code>kcpolytest order [-th <var>num</var>] [-rnd] [-set|-get|-getw|-rem|-etc] [-tran] [-oat|-onl|-onl|-otl|-onr] <var>path</var> <var>rnum</var></code></dt>
<dd>Performs in-order tests.</dd>
<dt><code>kcpolytest queue [-th <var>num</var>] [-it <var>num</var>] [-rnd] [-oat|-onl|-onl|-otl|-onr] <var>path</var> <var>rnum</var></code></dt>
<dd>Performs queuing operations.</dd>
<dt><code>kcpolytest wicked [-th <var>num</var>] [-it <var>num</var>] [-oat|-onl|-onl|-otl|-onr] <var>path</var> <var>rnum</var></code></dt>
<dd>Performs mixed operations selected at random.</dd>
<dt><code>kcpolytest tran [-th <var>num</var>] [-it <var>num</var>] [-hard] [-oat|-onl|-onl|-otl|-onr] <var>path</var> <var>rnum</var></code></dt>
<dd>Performs test of transaction.</dd>
<dt><code>kcpolytest misc <var>path</var></code></dt>
<dd>Performs miscellaneous tests.</dd>
</dl>

<p>Options feature the following.</p>

<ul class="options">
<li><code>-th <var>num</var></code> : specifies the number of worker threads.</li>
<li><code>-rnd</code> : performs random test.</li>
<li><code>-set</code> : performs setting operation only.</li>
<li><code>-get</code> : performs getting operation only.</li>
<li><code>-getw</code> : performs getting with a buffer operation only.</li>
<li><code>-rem</code> : performs removing operation only.</li>
<li><code>-etc</code> : performs miscellaneous operations.</li>
<li><code>-tran</code> : performs transaction.</li>
<li><code>-oat</code> : opens the database with the auto transaction option.</li>
<li><code>-oas</code> : opens the database with the auto synchronization option.</li>
<li><code>-onl</code> : opens the database with the no locking option.</li>
<li><code>-otl</code> : opens the database with the try locking option.</li>
<li><code>-onr</code> : opens the database with the no auto repair option.</li>
<li><code>-it <var>num</var></code> : specifies the number of repetition.</li>
<li><code>-hard</code> : performs physical synchronization.</li>
</ul>

<p>This command returns 0 on success, another on failure.</p>

<h3 id="kcpolymgr">kcpolymgr</h3>

<p>The command `<code>kcpolymgr</code>' is a utility for test and debugging of the file hash database and its applications.  `<var>path</var>' specifies the path of a database file.  `<var>key</var>' specifies the key of a record.  `<var>value</var>' specifies the value of a record.  `<var>file</var>' specifies the input file.</p>

<dl class="api">
<dt><code>kcpolymgr create [-otr] [-onl|-otl|-onr] <var>path</var></code></dt>
<dd>Creates a database file.</dd>
<dt><code>kcpolymgr inform [-onl|-otl|-onr] [-st] <var>path</var></code></dt>
<dd>Prints status information.</dd>
<dt><code>kcpolymgr set [-onl|-otl|-onr] [-add|-app|-inci|-incd] [-sx] <var>path</var> <var>key</var> <var>value</var></code></dt>
<dd>Stores a record.</dd>
<dt><code>kcpolymgr remove [-onl|-otl|-onr] [-sx] <var>path</var> <var>key</var></code></dt>
<dd>Removes a record.</dd>
<dt><code>kcpolymgr get [-onl|-otl|-onr] [-sx] [-px] [-pz] <var>path</var> <var>key</var></code></dt>
<dd>Prints the value of a record.</dd>
<dt><code>kcpolymgr list [-onl|-otl|-onr] [-max <var>num</var>] [-sx] [-pv] [-px] <var>path</var> [<var>key</var>]</code></dt>
<dd>Prints keys of all records, separated by line feeds.</dd>
<dt><code>kcpolymgr import [-onl|-otl|-onr] [-sx] <var>path</var> [<var>file</var>]</code></dt>
<dd>Imports records from a TSV file.</dd>
<dt><code>kcpolymgr dump [-onl|-otl|-onr] <var>path</var> [<var>file</var>]</code></dt>
<dd>Dump records into a snapshot file.</dd>
<dt><code>kcpolymgr load [-otr] [-onl|-otl|-onr] <var>path</var> [<var>file</var>]</code></dt>
<dd>Load records from a snapshot file.</dd>
<dt><code>kcpolymgr defrag [-onl|-otl|-onr] <var>path</var></code></dt>
<dd>Performs defragmentation.</dd>
<dt><code>kcpolymgr check [-onl|-otl|-onr] <var>path</var></code></dt>
<dd>Checks consistency.</dd>
</dl>

<p>Options feature the following.</p>

<ul class="options">
<li><code>-otr</code> : opens the database with the truncation option.</li>
<li><code>-onl</code> : opens the database with the no locking option.</li>
<li><code>-otl</code> : opens the database with the try locking option.</li>
<li><code>-onr</code> : opens the database with the no auto repair option.</li>
<li><code>-st</code> : prints miscellaneous information.</li>
<li><code>-add</code> : performs adding operation.</li>
<li><code>-app</code> : performs appending operation.</li>
<li><code>-inci</code> : performs integer increment operation.</li>
<li><code>-incd</code> : performs real number increment operation.</li>
<li><code>-sx</code> : the input data is evaluated as a hexadecimal data string.</li>
<li><code>-px</code> : the output data is converted into a hexadecimal data string.</li>
<li><code>-pz</code> : does not append line feed at the end of the output.</li>
<li><code>-max</code> : specifies the maximum number of shown records.</li>
<li><code>-pv</code> : prints values of records also.</li>
</ul>

<h3 id="kclangctest">kclangctest</h3>

<p>The command `<code>kclangctest</code>' is a utility for facility test and performance test of the C language binding.  This command is used in the following format.  `<var>path</var>' specifies the path of a database file.  `<var>rnum</var>' specifies the number of iterations.</p>

<dl class="api">
<dt><code>kcpolytest order [-rnd] [-etc] [-tran] [-oat|-onl|-onl|-otl|-onr] <var>path</var> <var>rnum</var></code></dt>
<dd>Performs in-order tests.</dd>
</dl>

<p>Options feature the following.</p>

<ul class="options">
<li><code>-rnd</code> : performs random test.</li>
<li><code>-etc</code> : performs miscellaneous operations.</li>
<li><code>-tran</code> : performs transaction.</li>
<li><code>-oat</code> : opens the database with the auto transaction option.</li>
<li><code>-oas</code> : opens the database with the auto synchronization option.</li>
<li><code>-onl</code> : opens the database with the no locking option.</li>
<li><code>-otl</code> : opens the database with the try locking option.</li>
<li><code>-onr</code> : opens the database with the no auto repair option.</li>
</ul>

<p>This command returns 0 on success, another on failure.</p>

<hr />

<h2 id="tips">Tips and Hacks</h2>

<p>This section describes tips and hacks to use Kyoto Cabinet.</p>

<h3 id="tips_tuningcache">Tuning the Cache Database</h3>

<p>The cache database is on-memory database featuring LRU deletion.  The following tuning methods are provided.</p>

<ul>
<li><code>tune_buckets</code> : sets the number of buckets of the hash table.</li>
<li><code>cap_count</code> : sets the capacity by record number.</li>
<li><code>cap_size</code> : sets the capacity by memory usage.</li>
</ul>

<p>By default, the cache database maintains all records on memory and no record is expired.  If you want to expire old records to keep the memory usage constant, call `<code>cap_count</code>' and/or `<code>cap_size</code>' to limit the capacity.</p>

<p>The default tuning of the bucket number is about one million.  If you intend to store more records, call `<code>tune_buckets</code>' to set the bucket number.  The suggested ratio of the bucket number is the same to the total number of records and it is okay from 50% to 400%.  If the ratio decreases smaller than 50%, the time efficiency will decrease gradually.</p>

<p>If you want to cache ten millions of records and keep the memory usage less than 8GB, the following tuning is suggested for example.</p>

<pre>db.tune_buckets(10LL * 1000 * 1000);
db.cap_count(10LL * 1000 * 1000);
db.cap_size(8LL &lt;&lt; 30);
db.open(...);
</pre>

<p>All tuning methods must be called before the database is opened.</p>

<h3 id="tips_tuninghash">Tuning the File Hash Database</h3>

<p>The file hash database is file database of hash table.  The following tuning methods are provided.</p>

<ul>
<li><code>tune_alignment</code> : sets the power of the alignment of record size.</li>
<li><code>tune_fbp</code> : sets the power of the capacity of the free block pool.</li>
<li><code>tune_options</code> : sets the optional features.</li>
<li><code>tune_buckets</code> : sets the number of buckets of the hash table.</li>
<li><code>tune_map</code> : sets the size of the internal memory-mapped region.</li>
<li><code>tune_defrag</code> : sets the unit step number of auto defragmentation.</li>
<li><code>tune_compressor</code> : set the data compressor.</li>
</ul>

<p>The default alignment power is 3, which means the address of each record is aligned to a multiple of 8 (1&lt;&lt;3) bytes.  If you trust that the database is constructed at a time and not updated often, call `<code>tune_alignment</code>' to set the alignment power 0, which means 1 (1&lt;&lt;0) byte.  If the typical size of each record is expected to be larger than 1KB, tune the alignment 8 or more.</p>

<p>The tuning of the free block pool by `<code>tune_fbp</code>' does not have to be modified in most cases.  The default is 10, which means the capacity of the free block pool is 1024 (1&lt;&lt;10).</p>

<p>The optional features by `<code>tune_options</code>' is useful to reduce the size of the database fine at the expense of scalability or time efficiency.  If `<code>HashDB::TSMALL</code>' is specified, the width of record addressing is reduced from 6 bytes to 4 bytes.  As the result, the footprint for each record is reduced from 16 bytes to 12 bytes.  However, it limits the maximum size of the database file up to 16GB (2GB multiplied by the alignment).  If `<code>HashDB::TLINEAR</code>' is specified, the data structure of the collision chain of hash table is changed from binary tree to linear linked list.  In that case, the footprint of each record is reduced from 16 bytes to 10 bytes although the time efficiency becomes sensitive to the number of the hash buckets.  If `<code>HashDB::TCOMPRESS</code>' is specified, the value of each record is compressed implicitly when stored in the file.  If the value is bigger than 1KB or more, compression is effective.</p>

<p>The default tuning of the bucket number is about one million.  If you intend to store more records, call `<code>tune_buckets</code>' to set the bucket number.  The suggested ratio of the bucket number is the twice of the total number of records and it is okay from 100% to 400%.  If the ratio decreases smaller than 100%, the time efficiency will decrease gradually.</p>

<p>The default tuning of the size of the internal memory-mapped region is 64MB.  If the database size is expected to be larger than 64MB, call `<code>tune_map</code> to set the map size larger than the expected size of the database.  Although the capacity of the RAM on the machine limits the map size, increasing the map size is effective to improve performance.</p>

<p>By default, auto defragmentation is disabled.  If the existing records in the database are modified (removed or modified with varying the size), fragmentation of available regions proceeds gradually.  In that case, call `<code>tune_defrag</code>' to enable auto defragmentation and set the unit step number.  The suggested unit step number is 8, which means that a set of defragmentation operations is performed each 8 updating operations.  The more the unit is, space efficiency becomes higher but time efficiency becomes lower.</p>

<p>The default compression algorithm of the `<code>HashDB::TLINEAR</code>' option is "Deflate" by ZLIB.  If you want to use another algorithm, call `<code>tune_compressor</code>' to set a functor which implements compression and decompression functions.</p>

<p>If you intend to store ten thousands of records and reduce the database size as possible, the following tuning is suggested for example.</p>

<pre>db.tune_alignment(0);
db.tune_buckets(10LL * 1000);
db.tune_options(HashDB::TSMALL | HashDB::TLINEAR);
db.tune_defrag(8);
db.open(...);
</pre>

<p>If you have a monster machine and intend to store ten billion records and improve time efficiency as possible, the following tuning is suggested for example.</p>

<pre>db.tune_buckets(20LL * 1000 * 1000 * 1000);
db.tune_map(300LL &lt;&lt; 30);
db.open(...);
</pre>

<p>All tuning methods must be called before the database is opened.  Because the settings of `<code>tune_alignment</code>', `<code>tune_fbp</code>', `<code>tune_options</code>', and `<code>tune_buckets</code>' are recorded as the meta data of the database, the methods are called before the database is created and they can not be modified afterward.  Because other tuning parameters are not recorded in the database, they should be specified before every time opening the database.</p>

<h3 id="tips_tuningtree">Tuning the File Tree Database</h3>

<p>The file tree database is file database of B+ tree.  Because each node of B+ tree is serialized as a page buffer and stored as a record in the file hash database, all tuning parameters of the file hash database is inherited to the file tree database.  Moreover, the following tuning methods are added.</p>

<ul>
<li><code>tune_page</code> : sets the size of each page.</li>
<li><code>tune_page_cache</code> : sets the capacity size of the page cache.</li>
<li><code>tune_comparator</code> : sets the record comparator.</li>
</ul>

<p>The tuning of the page size by `<code>tune_page</code>' does not have to be modified in most cases.  The default is 8192, which is the twice of the typical page size of popular environments.  If the size of each node exceeds the parameter, the node is divided into two.</p>

<p>The default tuning of the capacity size of the page cache is 64MB.  If your machine has abundant RAM, call `<code>tune_page</code>' to load all nodes on the page cache.  If the RAM is not abundant, it is better to keep the default page cache size and assign the RAM for the internal memory-mapped region by `<code>tune_map</code>'.</p>

<p>The default record comparator is the lexical ordering function.  That is, records in the B+ tree database are placed in the lexical order of each key.  If you want to use another ordering, call `<code>tune_comparator</code>' to set a functor which implements the ordering function.</p>

<p>The default alignment of the file tree database is 256 (1&lt;&lt;8).  The default bucket number of the file tree database is about 65536.  Other default tuning parameters are the same to the file hash database.  Note that the bucket number should be calculated by the number of pages.  The suggested ratio of the bucket number is about 10% of the number of records.  If the compression option is specified, all records in each page are compressed at once.  Therefore, compression is more effective for the file tree database rather than for the file hash database.</p>

<p>If you intend to store ten thousands of records and reduce the database size as possible, the following tuning is suggested for example.</p>

<pre>db.tune_buckets(1LL * 1000);
db.tune_options(TreeDB::TCCOMPESS);
db.tune_defrag(8);
db.tune_page(32768);
db.open(...);
</pre>

<p>If you have a monster machine and intend to store ten billion records and improve time efficiency as possible, the following tuning is suggested for example.</p>

<pre>db.tune_buckets(1LL * 1000 * 1000 * 1000);
db.tune_map(300LL &lt;&lt; 30);
db.tune_page_cache(2LL &lt;&lt; 30);
db.open(...);
</pre>

<p>All tuning methods must be called before the database is opened.  Because the setting of `<code>tune_page</code>' is recorded as the meta data of the database, the methods are called before the database is created and it can not be modified afterward.  Because other tuning parameters are not recorded in the database, they should be specified before every time opening the database.</p>

<h3 id="tips_transaction">Transaction</h3>

<p>If an application process which opened a database terminated without closing the database, it involves risks that some records may be missing and the database may be broken.  By default, durability is settled when the database is closed properly and it is not settled for each updating operation.  Kyoto Cabinet deal with the problem by transaction mechanism based on WAL (write ahead logging).  Transaction is begun and committed by application explicitly.  Durability during transaction is settled for each updating operation.  Transaction can be aborted by application.  In that case, all update operations during transaction are voided and the content of the database is rollbacked.  Although transaction is very useful like this, throughput of updating operation decreases to about 50% of the default manner due to overhead of writing WAL.</p>

<pre>db.begin_transaction();
db.set("japan", "tokyo");
db.set("korea", "seoul");
db.end_transaction();
</pre>

<p>If you can't be bothered to begin and commit transaction explicitly, use auto transaction mechanism by specifying the `<code>FileDB::AUTOTRAN</code>' option when opening the database.  Auto transaction is begun and committed implicitly for each operation.  Overhead of auto transaction is lighter than explicit transaction.</p>

<pre>db.open("casket.kch", HashDB::OWRITER | HashDB::OCREATE | HashDB::OAUTOTRAN);
db.set("japan", "tokyo");
db.set("china", "beijing");
</pre>

<p>After all, it is important to choose the usage according to the requirements of your application.</p>

<dl>
<dt><strong>default</strong></dt>
<dd>risk on process crash: Some records may be missing.</dd>
<dd>risk on system crash: Some records may be missing.</dd>
<dd>performance penalty: none</dd>
<dd>remark: Auto recovery after crash will take time in proportion of the database size.</dd>
</dl>

<dl>
<dt><strong>transaction</strong></dt>
<dd>implicit usage: open(..., FileDB::OAUTOTRAN);</dd>
<dd>explicit usage: begin_transaction(false); ...; end_transaction(true);</dd>
<dd>risk on process crash: none</dd>
<dd>risk on system crash: Some records may be missing.</dd>
<dd>performance penalty: Throughput will be down to about 50% or less.</dd>
</dl>

<dl>
<dt><strong>transaction + synchronize</strong></dt>
<dd>implicit usage: open(..., FileDB::OAUTOTRAN | FileDB::OAUTOSYNC);</dd>
<dd>explicit usage: begin_transaction(true); ...; end_transaction(true);</dd>
<dd>risk on process crash: none</dd>
<dd>risk on system crash: none</dd>
<dd>performance penalty: Throughput will be down to about 1% or less.</dd>
</dl>

<h3 id="tips_backup">Backup</h3>

<p>Any hardware will break down suddenly.  Especially such storage devices as HDD and SSD are fragile.  Therefore, making backup files of your database file periodically is very important even if you use transaction.  You can copy a database file by such popular commands as `<code>cp</code>' and `<code>tar</code>' when the database is not being updated by another process.</p>

<p>If an application uses multi threads and you want to make a backup file of the database in safety, use the `<code>FileDB::copy</code>' method, which synchronizes the database status with the database file and makes a copy file.  During the copying operation, it is assured that the database file is not updated.</p>

<pre>db.copy("backup.kch");
</pre>

<p>You may want "hot backup", which means that other threads are not blocked while a thread is creating a backup file.  In that case, use the `<code>File::synchronize</code>' method which synchronizes the database file and calls a function defined arbitrary.  The call back function can execute a "snapshot" command provided by the operating system.</p>

<pre>class BackupImpl : public FileProcessor {
  bool process(const std::string&amp; path, int64_t size, int64_t count) {
    char cmd[1024];
    sprintf(cmd, "snapshot.sh %s", path.c_str());
    return system(cmd) == 0;
  }
} proc;
db.synchronize(&amp;proc);
</pre>

<h3 id="tips_snapshot">Pseudo-snapshot</h3>

<p>Chiefly for the cache database, the pseudo-snapshot mechanism is provided.  The `<code>FileDB::dump_snapshot</code>' dumps all records into a stream or a file.  The `<code>FileDB::load_snapshot</code>' method loads records from a stream or a file.  Although the operations are performed atomically, they don't finish momentarily but take time in proportion of the database size with blocking the other threads.  Because the format of pseudo-snapshot data is common among the all database classes, it is useful to migrate records for each other.</p>

<pre>db.dump_snapshot("backup.kcss");
db.load_snapshot("backup.kcss");
</pre>

<p>If you don't want to let the other threads be blocked.  Use the cursor mechanism and save/load records by yourself.</p>

<hr />

<h2 id="license">License</h2>

<p>Kyoto Cabinet is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or any later version.</p>

<p>Kyoto Cabinet is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.</p>

<p>You should have received a copy of the GNU General Public License along with this program.  If not, see `<code>http://www.gnu.org/licenses/</code>'.</p>

<p>Kyoto Cabinet was written by Mikio Hirabayashi.  You can contact the author by e-mail to `<code>hirarin@gmail.com</code>'.</p>

<hr />

</body>

</html>

<!-- END OF FILE -->
