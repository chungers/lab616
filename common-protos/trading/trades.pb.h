// Generated by the protocol buffer compiler.  DO NOT EDIT!

#ifndef PROTOBUF_trades_2eproto__INCLUDED
#define PROTOBUF_trades_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2002000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2002000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>

namespace trading {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_trades_2eproto();
void protobuf_AssignDesc_trades_2eproto();
void protobuf_ShutdownFile_trades_2eproto();

class Trade;
class GainLoss;

enum OrderType {
  BUY = 0,
  SELL = 1,
  BUY_OPEN = 2,
  SELL_CLOSE = 3,
  OPTION_EXPIRE = 4
};
bool OrderType_IsValid(int value);
const OrderType OrderType_MIN = BUY;
const OrderType OrderType_MAX = OPTION_EXPIRE;

// ===================================================================

class Trade : public ::google::protobuf::MessageLite {
 public:
  Trade();
  virtual ~Trade();
  
  Trade(const Trade& from);
  
  inline Trade& operator=(const Trade& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const Trade& default_instance();
  void Swap(Trade* other);
  
  // implements Message ----------------------------------------------
  
  Trade* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Trade& from);
  void MergeFrom(const Trade& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string date = 1;
  inline bool has_date() const;
  inline void clear_date();
  static const int kDateFieldNumber = 1;
  inline const ::std::string& date() const;
  inline void set_date(const ::std::string& value);
  inline void set_date(const char* value);
  inline void set_date(const char* value, size_t size);
  inline ::std::string* mutable_date();
  
  // required .trading.OrderType orderType = 2;
  inline bool has_ordertype() const;
  inline void clear_ordertype();
  static const int kOrderTypeFieldNumber = 2;
  inline trading::OrderType ordertype() const;
  inline void set_ordertype(trading::OrderType value);
  
  // optional string cusip = 3;
  inline bool has_cusip() const;
  inline void clear_cusip();
  static const int kCusipFieldNumber = 3;
  inline const ::std::string& cusip() const;
  inline void set_cusip(const ::std::string& value);
  inline void set_cusip(const char* value);
  inline void set_cusip(const char* value, size_t size);
  inline ::std::string* mutable_cusip();
  
  // required string security = 4;
  inline bool has_security() const;
  inline void clear_security();
  static const int kSecurityFieldNumber = 4;
  inline const ::std::string& security() const;
  inline void set_security(const ::std::string& value);
  inline void set_security(const char* value);
  inline void set_security(const char* value, size_t size);
  inline ::std::string* mutable_security();
  
  // required string description = 5;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 5;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  
  // required int32 quantity = 6;
  inline bool has_quantity() const;
  inline void clear_quantity();
  static const int kQuantityFieldNumber = 6;
  inline ::google::protobuf::int32 quantity() const;
  inline void set_quantity(::google::protobuf::int32 value);
  
  // required float price = 7;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 7;
  inline float price() const;
  inline void set_price(float value);
  
  // optional float commission = 8;
  inline bool has_commission() const;
  inline void clear_commission();
  static const int kCommissionFieldNumber = 8;
  inline float commission() const;
  inline void set_commission(float value);
  
  // required float net = 9;
  inline bool has_net() const;
  inline void clear_net();
  static const int kNetFieldNumber = 9;
  inline float net() const;
  inline void set_net(float value);
  
  // required fixed64 timestamp = 10;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 10;
  inline ::google::protobuf::uint64 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint64 value);
  
  // required fixed64 tradeId = 11;
  inline bool has_tradeid() const;
  inline void clear_tradeid();
  static const int kTradeIdFieldNumber = 11;
  inline ::google::protobuf::uint64 tradeid() const;
  inline void set_tradeid(::google::protobuf::uint64 value);
  
 private:
  mutable int _cached_size_;
  
  ::std::string* date_;
  static const ::std::string _default_date_;
  int ordertype_;
  ::std::string* cusip_;
  static const ::std::string _default_cusip_;
  ::std::string* security_;
  static const ::std::string _default_security_;
  ::std::string* description_;
  static const ::std::string _default_description_;
  ::google::protobuf::int32 quantity_;
  float price_;
  float commission_;
  float net_;
  ::google::protobuf::uint64 timestamp_;
  ::google::protobuf::uint64 tradeid_;
  friend void  protobuf_AddDesc_trades_2eproto();
  friend void protobuf_AssignDesc_trades_2eproto();
  friend void protobuf_ShutdownFile_trades_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Trade* default_instance_;
};
// -------------------------------------------------------------------

class GainLoss : public ::google::protobuf::MessageLite {
 public:
  GainLoss();
  virtual ~GainLoss();
  
  GainLoss(const GainLoss& from);
  
  inline GainLoss& operator=(const GainLoss& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const GainLoss& default_instance();
  void Swap(GainLoss* other);
  
  // implements Message ----------------------------------------------
  
  GainLoss* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GainLoss& from);
  void MergeFrom(const GainLoss& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string symbol = 1;
  inline bool has_symbol() const;
  inline void clear_symbol();
  static const int kSymbolFieldNumber = 1;
  inline const ::std::string& symbol() const;
  inline void set_symbol(const ::std::string& value);
  inline void set_symbol(const char* value);
  inline void set_symbol(const char* value, size_t size);
  inline ::std::string* mutable_symbol();
  
  // required int32 quantity = 2;
  inline bool has_quantity() const;
  inline void clear_quantity();
  static const int kQuantityFieldNumber = 2;
  inline ::google::protobuf::int32 quantity() const;
  inline void set_quantity(::google::protobuf::int32 value);
  
  // required string open_date = 3;
  inline bool has_open_date() const;
  inline void clear_open_date();
  static const int kOpenDateFieldNumber = 3;
  inline const ::std::string& open_date() const;
  inline void set_open_date(const ::std::string& value);
  inline void set_open_date(const char* value);
  inline void set_open_date(const char* value, size_t size);
  inline ::std::string* mutable_open_date();
  
  // required float open_price = 4;
  inline bool has_open_price() const;
  inline void clear_open_price();
  static const int kOpenPriceFieldNumber = 4;
  inline float open_price() const;
  inline void set_open_price(float value);
  
  // required float open_net = 5;
  inline bool has_open_net() const;
  inline void clear_open_net();
  static const int kOpenNetFieldNumber = 5;
  inline float open_net() const;
  inline void set_open_net(float value);
  
  // required .trading.OrderType order_type = 6;
  inline bool has_order_type() const;
  inline void clear_order_type();
  static const int kOrderTypeFieldNumber = 6;
  inline trading::OrderType order_type() const;
  inline void set_order_type(trading::OrderType value);
  
  // required string closing_date = 7;
  inline bool has_closing_date() const;
  inline void clear_closing_date();
  static const int kClosingDateFieldNumber = 7;
  inline const ::std::string& closing_date() const;
  inline void set_closing_date(const ::std::string& value);
  inline void set_closing_date(const char* value);
  inline void set_closing_date(const char* value, size_t size);
  inline ::std::string* mutable_closing_date();
  
  // required float closing_price = 8;
  inline bool has_closing_price() const;
  inline void clear_closing_price();
  static const int kClosingPriceFieldNumber = 8;
  inline float closing_price() const;
  inline void set_closing_price(float value);
  
  // required float closing_net = 9;
  inline bool has_closing_net() const;
  inline void clear_closing_net();
  static const int kClosingNetFieldNumber = 9;
  inline float closing_net() const;
  inline void set_closing_net(float value);
  
  // required float gain_loss = 10;
  inline bool has_gain_loss() const;
  inline void clear_gain_loss();
  static const int kGainLossFieldNumber = 10;
  inline float gain_loss() const;
  inline void set_gain_loss(float value);
  
  // required fixed64 id = 11;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 11;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);
  
 private:
  mutable int _cached_size_;
  
  ::std::string* symbol_;
  static const ::std::string _default_symbol_;
  ::google::protobuf::int32 quantity_;
  ::std::string* open_date_;
  static const ::std::string _default_open_date_;
  float open_price_;
  float open_net_;
  int order_type_;
  ::std::string* closing_date_;
  static const ::std::string _default_closing_date_;
  float closing_price_;
  float closing_net_;
  float gain_loss_;
  ::google::protobuf::uint64 id_;
  friend void  protobuf_AddDesc_trades_2eproto();
  friend void protobuf_AssignDesc_trades_2eproto();
  friend void protobuf_ShutdownFile_trades_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static GainLoss* default_instance_;
};
// ===================================================================


// ===================================================================

// Trade

// required string date = 1;
inline bool Trade::has_date() const {
  return _has_bit(0);
}
inline void Trade::clear_date() {
  if (date_ != &_default_date_) {
    date_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& Trade::date() const {
  return *date_;
}
inline void Trade::set_date(const ::std::string& value) {
  _set_bit(0);
  if (date_ == &_default_date_) {
    date_ = new ::std::string;
  }
  date_->assign(value);
}
inline void Trade::set_date(const char* value) {
  _set_bit(0);
  if (date_ == &_default_date_) {
    date_ = new ::std::string;
  }
  date_->assign(value);
}
inline void Trade::set_date(const char* value, size_t size) {
  _set_bit(0);
  if (date_ == &_default_date_) {
    date_ = new ::std::string;
  }
  date_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Trade::mutable_date() {
  _set_bit(0);
  if (date_ == &_default_date_) {
    date_ = new ::std::string;
  }
  return date_;
}

// required .trading.OrderType orderType = 2;
inline bool Trade::has_ordertype() const {
  return _has_bit(1);
}
inline void Trade::clear_ordertype() {
  ordertype_ = 0;
  _clear_bit(1);
}
inline trading::OrderType Trade::ordertype() const {
  return static_cast< trading::OrderType >(ordertype_);
}
inline void Trade::set_ordertype(trading::OrderType value) {
  GOOGLE_DCHECK(trading::OrderType_IsValid(value));
  _set_bit(1);
  ordertype_ = value;
}

// optional string cusip = 3;
inline bool Trade::has_cusip() const {
  return _has_bit(2);
}
inline void Trade::clear_cusip() {
  if (cusip_ != &_default_cusip_) {
    cusip_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& Trade::cusip() const {
  return *cusip_;
}
inline void Trade::set_cusip(const ::std::string& value) {
  _set_bit(2);
  if (cusip_ == &_default_cusip_) {
    cusip_ = new ::std::string;
  }
  cusip_->assign(value);
}
inline void Trade::set_cusip(const char* value) {
  _set_bit(2);
  if (cusip_ == &_default_cusip_) {
    cusip_ = new ::std::string;
  }
  cusip_->assign(value);
}
inline void Trade::set_cusip(const char* value, size_t size) {
  _set_bit(2);
  if (cusip_ == &_default_cusip_) {
    cusip_ = new ::std::string;
  }
  cusip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Trade::mutable_cusip() {
  _set_bit(2);
  if (cusip_ == &_default_cusip_) {
    cusip_ = new ::std::string;
  }
  return cusip_;
}

// required string security = 4;
inline bool Trade::has_security() const {
  return _has_bit(3);
}
inline void Trade::clear_security() {
  if (security_ != &_default_security_) {
    security_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& Trade::security() const {
  return *security_;
}
inline void Trade::set_security(const ::std::string& value) {
  _set_bit(3);
  if (security_ == &_default_security_) {
    security_ = new ::std::string;
  }
  security_->assign(value);
}
inline void Trade::set_security(const char* value) {
  _set_bit(3);
  if (security_ == &_default_security_) {
    security_ = new ::std::string;
  }
  security_->assign(value);
}
inline void Trade::set_security(const char* value, size_t size) {
  _set_bit(3);
  if (security_ == &_default_security_) {
    security_ = new ::std::string;
  }
  security_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Trade::mutable_security() {
  _set_bit(3);
  if (security_ == &_default_security_) {
    security_ = new ::std::string;
  }
  return security_;
}

// required string description = 5;
inline bool Trade::has_description() const {
  return _has_bit(4);
}
inline void Trade::clear_description() {
  if (description_ != &_default_description_) {
    description_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& Trade::description() const {
  return *description_;
}
inline void Trade::set_description(const ::std::string& value) {
  _set_bit(4);
  if (description_ == &_default_description_) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void Trade::set_description(const char* value) {
  _set_bit(4);
  if (description_ == &_default_description_) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void Trade::set_description(const char* value, size_t size) {
  _set_bit(4);
  if (description_ == &_default_description_) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Trade::mutable_description() {
  _set_bit(4);
  if (description_ == &_default_description_) {
    description_ = new ::std::string;
  }
  return description_;
}

// required int32 quantity = 6;
inline bool Trade::has_quantity() const {
  return _has_bit(5);
}
inline void Trade::clear_quantity() {
  quantity_ = 0;
  _clear_bit(5);
}
inline ::google::protobuf::int32 Trade::quantity() const {
  return quantity_;
}
inline void Trade::set_quantity(::google::protobuf::int32 value) {
  _set_bit(5);
  quantity_ = value;
}

// required float price = 7;
inline bool Trade::has_price() const {
  return _has_bit(6);
}
inline void Trade::clear_price() {
  price_ = 0;
  _clear_bit(6);
}
inline float Trade::price() const {
  return price_;
}
inline void Trade::set_price(float value) {
  _set_bit(6);
  price_ = value;
}

// optional float commission = 8;
inline bool Trade::has_commission() const {
  return _has_bit(7);
}
inline void Trade::clear_commission() {
  commission_ = 0;
  _clear_bit(7);
}
inline float Trade::commission() const {
  return commission_;
}
inline void Trade::set_commission(float value) {
  _set_bit(7);
  commission_ = value;
}

// required float net = 9;
inline bool Trade::has_net() const {
  return _has_bit(8);
}
inline void Trade::clear_net() {
  net_ = 0;
  _clear_bit(8);
}
inline float Trade::net() const {
  return net_;
}
inline void Trade::set_net(float value) {
  _set_bit(8);
  net_ = value;
}

// required fixed64 timestamp = 10;
inline bool Trade::has_timestamp() const {
  return _has_bit(9);
}
inline void Trade::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  _clear_bit(9);
}
inline ::google::protobuf::uint64 Trade::timestamp() const {
  return timestamp_;
}
inline void Trade::set_timestamp(::google::protobuf::uint64 value) {
  _set_bit(9);
  timestamp_ = value;
}

// required fixed64 tradeId = 11;
inline bool Trade::has_tradeid() const {
  return _has_bit(10);
}
inline void Trade::clear_tradeid() {
  tradeid_ = GOOGLE_ULONGLONG(0);
  _clear_bit(10);
}
inline ::google::protobuf::uint64 Trade::tradeid() const {
  return tradeid_;
}
inline void Trade::set_tradeid(::google::protobuf::uint64 value) {
  _set_bit(10);
  tradeid_ = value;
}

// -------------------------------------------------------------------

// GainLoss

// required string symbol = 1;
inline bool GainLoss::has_symbol() const {
  return _has_bit(0);
}
inline void GainLoss::clear_symbol() {
  if (symbol_ != &_default_symbol_) {
    symbol_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& GainLoss::symbol() const {
  return *symbol_;
}
inline void GainLoss::set_symbol(const ::std::string& value) {
  _set_bit(0);
  if (symbol_ == &_default_symbol_) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(value);
}
inline void GainLoss::set_symbol(const char* value) {
  _set_bit(0);
  if (symbol_ == &_default_symbol_) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(value);
}
inline void GainLoss::set_symbol(const char* value, size_t size) {
  _set_bit(0);
  if (symbol_ == &_default_symbol_) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GainLoss::mutable_symbol() {
  _set_bit(0);
  if (symbol_ == &_default_symbol_) {
    symbol_ = new ::std::string;
  }
  return symbol_;
}

// required int32 quantity = 2;
inline bool GainLoss::has_quantity() const {
  return _has_bit(1);
}
inline void GainLoss::clear_quantity() {
  quantity_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 GainLoss::quantity() const {
  return quantity_;
}
inline void GainLoss::set_quantity(::google::protobuf::int32 value) {
  _set_bit(1);
  quantity_ = value;
}

// required string open_date = 3;
inline bool GainLoss::has_open_date() const {
  return _has_bit(2);
}
inline void GainLoss::clear_open_date() {
  if (open_date_ != &_default_open_date_) {
    open_date_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& GainLoss::open_date() const {
  return *open_date_;
}
inline void GainLoss::set_open_date(const ::std::string& value) {
  _set_bit(2);
  if (open_date_ == &_default_open_date_) {
    open_date_ = new ::std::string;
  }
  open_date_->assign(value);
}
inline void GainLoss::set_open_date(const char* value) {
  _set_bit(2);
  if (open_date_ == &_default_open_date_) {
    open_date_ = new ::std::string;
  }
  open_date_->assign(value);
}
inline void GainLoss::set_open_date(const char* value, size_t size) {
  _set_bit(2);
  if (open_date_ == &_default_open_date_) {
    open_date_ = new ::std::string;
  }
  open_date_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GainLoss::mutable_open_date() {
  _set_bit(2);
  if (open_date_ == &_default_open_date_) {
    open_date_ = new ::std::string;
  }
  return open_date_;
}

// required float open_price = 4;
inline bool GainLoss::has_open_price() const {
  return _has_bit(3);
}
inline void GainLoss::clear_open_price() {
  open_price_ = 0;
  _clear_bit(3);
}
inline float GainLoss::open_price() const {
  return open_price_;
}
inline void GainLoss::set_open_price(float value) {
  _set_bit(3);
  open_price_ = value;
}

// required float open_net = 5;
inline bool GainLoss::has_open_net() const {
  return _has_bit(4);
}
inline void GainLoss::clear_open_net() {
  open_net_ = 0;
  _clear_bit(4);
}
inline float GainLoss::open_net() const {
  return open_net_;
}
inline void GainLoss::set_open_net(float value) {
  _set_bit(4);
  open_net_ = value;
}

// required .trading.OrderType order_type = 6;
inline bool GainLoss::has_order_type() const {
  return _has_bit(5);
}
inline void GainLoss::clear_order_type() {
  order_type_ = 0;
  _clear_bit(5);
}
inline trading::OrderType GainLoss::order_type() const {
  return static_cast< trading::OrderType >(order_type_);
}
inline void GainLoss::set_order_type(trading::OrderType value) {
  GOOGLE_DCHECK(trading::OrderType_IsValid(value));
  _set_bit(5);
  order_type_ = value;
}

// required string closing_date = 7;
inline bool GainLoss::has_closing_date() const {
  return _has_bit(6);
}
inline void GainLoss::clear_closing_date() {
  if (closing_date_ != &_default_closing_date_) {
    closing_date_->clear();
  }
  _clear_bit(6);
}
inline const ::std::string& GainLoss::closing_date() const {
  return *closing_date_;
}
inline void GainLoss::set_closing_date(const ::std::string& value) {
  _set_bit(6);
  if (closing_date_ == &_default_closing_date_) {
    closing_date_ = new ::std::string;
  }
  closing_date_->assign(value);
}
inline void GainLoss::set_closing_date(const char* value) {
  _set_bit(6);
  if (closing_date_ == &_default_closing_date_) {
    closing_date_ = new ::std::string;
  }
  closing_date_->assign(value);
}
inline void GainLoss::set_closing_date(const char* value, size_t size) {
  _set_bit(6);
  if (closing_date_ == &_default_closing_date_) {
    closing_date_ = new ::std::string;
  }
  closing_date_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GainLoss::mutable_closing_date() {
  _set_bit(6);
  if (closing_date_ == &_default_closing_date_) {
    closing_date_ = new ::std::string;
  }
  return closing_date_;
}

// required float closing_price = 8;
inline bool GainLoss::has_closing_price() const {
  return _has_bit(7);
}
inline void GainLoss::clear_closing_price() {
  closing_price_ = 0;
  _clear_bit(7);
}
inline float GainLoss::closing_price() const {
  return closing_price_;
}
inline void GainLoss::set_closing_price(float value) {
  _set_bit(7);
  closing_price_ = value;
}

// required float closing_net = 9;
inline bool GainLoss::has_closing_net() const {
  return _has_bit(8);
}
inline void GainLoss::clear_closing_net() {
  closing_net_ = 0;
  _clear_bit(8);
}
inline float GainLoss::closing_net() const {
  return closing_net_;
}
inline void GainLoss::set_closing_net(float value) {
  _set_bit(8);
  closing_net_ = value;
}

// required float gain_loss = 10;
inline bool GainLoss::has_gain_loss() const {
  return _has_bit(9);
}
inline void GainLoss::clear_gain_loss() {
  gain_loss_ = 0;
  _clear_bit(9);
}
inline float GainLoss::gain_loss() const {
  return gain_loss_;
}
inline void GainLoss::set_gain_loss(float value) {
  _set_bit(9);
  gain_loss_ = value;
}

// required fixed64 id = 11;
inline bool GainLoss::has_id() const {
  return _has_bit(10);
}
inline void GainLoss::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  _clear_bit(10);
}
inline ::google::protobuf::uint64 GainLoss::id() const {
  return id_;
}
inline void GainLoss::set_id(::google::protobuf::uint64 value) {
  _set_bit(10);
  id_ = value;
}


}  // namespace trading
#endif  // PROTOBUF_trades_2eproto__INCLUDED
